import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; // Added GLTFLoader import
import { TextureLoader } from "three"; // Add TextureLoader import
import { BaseEnvironment } from "./BaseEnvironment";
import { MapSystem } from "../../../systems/map/MapSystem";
import { SeveranceMaterials } from "../materials/SeveranceMaterials";
import { UnifiedMovementController } from "../../../systems/movement/UnifiedMovementController";
import {
  CorridorSystem,
  CORRIDOR_WIDTH,
  SEGMENT_LENGTH,
  CORRIDOR_HEIGHT,
  CORRIDOR_TRIM_HEIGHT,
} from "../../../systems/corridorSystem";
import { CORRIDOR_MAP } from "../../../systems/map/SeveranceCorridorMap.js";
import PerformanceArtLetterGenerator from '../performance/PerformanceArtLetterGenerator.js';


const DOORWAY_WIDTH = 1.8; // Widened from 1.2 for a more spacious doorframe


export class SeveranceEnvironment extends BaseEnvironment {
  constructor(options = {}) {
    super({
      ...options,
      usePostProcessing: true, // Enable post-processing for visual effects
      usePerformanceMonitoring: true, // Monitor performance for optimization
    });

    // Add post-processing configuration
    this.postProcessingConfig = {
      bloom: {
        enabled: true,
        strength: 0.5,
        radius: 0.4,
        threshold: 0.8
      },
      chromaticAberration: {
        enabled: true,
        offset: 0.001
      }
    };

    // Initialize game state
    this.gameState = {
      isPlaying: false,
      currentLocation: "entrance",
      playerHealth: 100,
      inventory: [],
      visitedLocations: new Set(["entrance"]),
      objectives: new Map(),
      settings: {
        mouseSensitivity: 0.002,
        volume: 0.8,
        fov: 75,
        headBobEnabled: true,
        headBobIntensity: 0.08,
        headBobSpeed: 1.8
      }
    };

    // Weather state
    this.weatherState = {
      isRaining: false,
      lastWeatherChange: Date.now(),
      minWeatherDuration: 120000, // Minimum 2 minutes between weather changes
    };

    // Store references to doors and interactive objects
    this.doors = new Map();
    this.interactiveObjects = new Map();

    // Environment state
    this.emergencyLighting = false;
    this.lightFlickerIntensity = 0;

    // Corridor segments
    this.corridorSegments = new Map();
    // Store references to all indoor ceiling meshes for rain occlusion
    this.ceilingMeshes = [];

    // Collidable walls
    this.wallMeshes = []; // Added to store wall meshes for collision

    // Initialize materials system
    this.materialSystem = new SeveranceMaterials(this.renderer);

    // Initialize asset collections
    this.assets = {
      lights: new Map(),
      models: new Map(),
      sounds: new Map(),
      materials: new Map(), // Added from LumonEnvironment for consistency
    };

    // Wayfinding elements (from LumonEnvironment)
    this.wayfinding = new Map();
    this.clock = new THREE.Clock(); // Added from LumonEnvironment

    // Door locations for interaction detection
    window.doorLocations = [];

    // Add door animation properties
    this.doorStates = new Map();
    this.DOOR_INTERACTION_DISTANCE = 2.5; // Distance at which doors start opening
    this.DOOR_ANIMATION_SPEED = 1.5; // Speed of door opening/closing
    this.DOOR_MAX_ANGLE = Math.PI / 2; // 90 degrees open
    this.DOOR_OPEN_DIRECTION = 1; // 1 for opening to the right, -1 for opening to the left

    // Trackable objects
    this.doorStates = new Map(); // Track door state for animation
    this.doors = new Map(); // Store references to door objects
    
    // Add model loaders
    this.gltfLoader = new GLTFLoader();
    this.doorModels = {
        doorFrame: null,
        doorPivot: null,
        cardReader: null
    };
    this.tunnelWallMeshes = []; // Store tunnel wall meshes for uniform updates
  }

  /**
   * Initialize environment systems
   * @protected
   * @override
   */
  async initializeSystems() {
    await super.initializeSystems();

    // Initialize material system first
    await this.materialSystem.initialize(this.renderer);

    // Initialize core gameplay systems (corridor must be set before setupEnvironment)
    this.systems.set(
      "corridor",
      new CorridorSystem(this.scene, this.materialSystem)
    );

    // Set up the environment before creating other systems
    await this.setupEnvironment();

    // Load door models before creating any doors
    await this.loadDoorModels();

    // Initialize movement controller
    if (!window.activeMovementController) {
      console.log("Initializing UnifiedMovementController");
      this.movementController = new UnifiedMovementController(this.camera, this);
      window.activeMovementController = this.movementController;
    } else {
      console.log("Using existing UnifiedMovementController");
      this.movementController = window.activeMovementController;
    }

    // Initialize each system
    for (const [name, system] of this.systems) {
      if (system.initialize) {
        await system.initialize(this.container);
      }
    }

    // Set up portfolio sections using the new method
    this.setupPortfolioSections();

    // Build the new, simplified corridor layout
    await this.buildNewCorridorLayout();

    // Optionally create wayfinding elements if needed
    await this.createWayfinding();

    // Initialize post-processing effects
    if (this.composer) {
      const { EffectComposer } = await import('three/examples/jsm/postprocessing/EffectComposer.js');
      const { RenderPass } = await import('three/examples/jsm/postprocessing/RenderPass.js');
      const { UnrealBloomPass } = await import('three/examples/jsm/postprocessing/UnrealBloomPass.js');
      const { ShaderPass } = await import('three/examples/jsm/postprocessing/ShaderPass.js');

      // Custom chromatic aberration shader
      const chromaticAberrationShader = {
        uniforms: {
          "tDiffuse": { value: null },
          "offset": { value: this.postProcessingConfig.chromaticAberration.offset }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float offset;
          varying vec2 vUv;
          void main() {
            vec4 cr = texture2D(tDiffuse, vUv + vec2(offset, 0));
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - vec2(offset, 0));
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
          }
        `
      };

      // Add bloom effect
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        this.postProcessingConfig.bloom.strength,
        this.postProcessingConfig.bloom.radius,
        this.postProcessingConfig.bloom.threshold
      );

      // Add chromatic abberation
      const chromaticAberrationPass = new ShaderPass(chromaticAberrationShader);

      // Add passes to composer
      this.composer.addPass(bloomPass);
      this.composer.addPass(chromaticAberrationPass);

      // Store passes for later adjustment
      this.postProcessingPasses = {
        bloom: bloomPass,
        chromaticAberration: chromaticAberrationPass
      };
    }

    console.log("✓ Environment systems initialized."); // Example log

    // ---> SET isPlaying TO TRUE HERE <---
    this.gameState.isPlaying = true;
    window.playerCanMove = true; // Also ensure playerCanMove is true here
    console.log(`[GAME STATE] Set isPlaying=${this.gameState.isPlaying}, playerCanMove=${window.playerCanMove}`);
  }

  // Add new method to load door models
  async loadDoorModels() {
    try {
        console.log("[Door Models] Starting to load door models...");
        
        // Load door frame model
        console.log("[Door Models] Loading door frame model...");
        const doorFrameResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/door frame.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Frame loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading door frame:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.doorFrame = doorFrameResult.scene;
        console.log("[Door Models] Door frame loaded successfully");
        
        // Load door pivot model
        console.log("[Door Models] Loading door pivot model...");
        const doorPivotResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/door pivot.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Pivot loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading door pivot:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.doorPivot = doorPivotResult.scene;
        console.log("[Door Models] Door pivot loaded successfully");
        
        // Load card reader model
        console.log("[Door Models] Loading card reader model...");
        const cardReaderResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/card reader.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Card reader loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading card reader:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.cardReader = cardReaderResult.scene;
        console.log("[Door Models] Card reader loaded successfully");
        
        // Verify all models loaded correctly
        if (!this.doorModels.doorFrame || !this.doorModels.doorPivot) {
            throw new Error("Required door models failed to load");
        }
        
        console.log("[Door Models] All door models loaded successfully");
        return true;
    } catch (error) {
        console.error("[Door Models] Critical error loading door models:", error);
        console.error("[Door Models] Stack trace:", error.stack);
        // Don't throw here - let the application continue with fallback behavior
        return false;
    }
  }

  /**
   * Set up the initial environment
   * @private
   */
  async setupEnvironment() {
    console.log("Setting up Severance environment...");

    // Remove default background and fog, will use a skybox instead
    // this.scene.background = new THREE.Color(0xffffff);
    // this.scene.fog = new THREE.Fog(0xffffff, 20, 40);

    // Initialize materials first
    await this.materialSystem.initialize();

    // Set initial camera position to start at the elevator entrance
    // Position further into the hallway to avoid any walls
    // this.camera.position.set(
    //   0,
    //   this.options.cameraHeight,
    //   SEGMENT_LENGTH * 1.5
    // );
    this.camera.rotation.set(0, Math.PI, 0); // Looking toward the end of the corridor (-Z direction)

    
    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambientLight);
    this.assets.lights.set("ambient", ambientLight);

    // Set up lighting with shader-based fluorescent lights
    await this.setupLighting();

    // Update all materials with environment map if needed
    if (this.environmentMap) {
      this.materialSystem.updateEnvironmentMap(this.environmentMap);
    }

    // Remove global floor plane - the skybox bottom will serve as the ground
    // {
    //   const floorGeometry = new THREE.PlaneGeometry(200, 200);
    //   let floorMaterial = this.materialSystem.getMaterial("outsideGround");
    //   if (this.isPlayerOutdoors && typeof this.isPlayerOutdoors === 'function' && !this.isPlayerOutdoors()) {
    //     floorMaterial = this.materialSystem.getMaterial("floor");
    //   }
    //   this.globalFloor = new THREE.Mesh(floorGeometry, floorMaterial);
    //   this.globalFloor.rotation.x = -Math.PI / 2;
    //   this.globalFloor.receiveShadow = true;
    //   this.scene.add(this.globalFloor);
    // }

    // Build the corridor layout using the improved method that handles all 
    // corridor systems and connections properly
    await this.buildNewCorridorLayout();
    
    // Create a skysphere using the sky material (distinct from ground)
    const skyMaterial = this.materialSystem.getMaterial("sky");
    if (skyMaterial) {
        const sphereRadius = 250; // Large radius
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 60, 40);
        // Flip geometry normals to face inward
        sphereGeometry.scale(-1, 1, 1);

        const sphereMaterial = skyMaterial.clone(); // Clone to avoid side effects
        sphereMaterial.side = THREE.DoubleSide; // Use DoubleSide for inverted sphere
        sphereMaterial.needsUpdate = true;

        const skysphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        // Position sphere centered around the origin (or player start)
        skysphere.position.set(0, 0, 0);
        this.scene.add(skysphere);
        console.log("Added skysphere using distinct sky material.");
    } else {
        console.warn("Sky material not found for skysphere, using fallback color background.");
        this.scene.background = new THREE.Color(0x808080); // Fallback gray
    }

    // Add a large ground plane at y=0 using the outsideGround material
    const groundMaterial = this.materialSystem.getMaterial("outsideGround");
    if (groundMaterial) {
        const groundSize = 400; // Large enough to cover visible area
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2; // Make it horizontal
        groundMesh.position.y = 0; // Place at ground level
        groundMesh.receiveShadow = true;
        this.scene.add(groundMesh);
        this.globalFloor = groundMesh;
        this.globalFloor.visible = false; // Start hidden, will be toggled in update
        console.log("Added distinct outside ground plane.");
    } else {
        console.warn("Outside ground material not found, ground plane not added.");
    }

    console.log("Environment setup complete");
  }

  /**
   * Initialize the rendering materials with custom shaders for the Severance aesthetic
   * @private
   */
  async initializeMaterials() {
    // Get the custom wall material from the material system instead of creating a new one
    try {
      this.wallMaterial = this.materialSystem.getMaterial("wall");
      console.log(
        "Successfully got wall material from material system:",
        this.wallMaterial.type
      );
    } catch (error) {
      console.warn(
        "Could not get 'wall' material from material system, creating fallback",
        error
      );

      // Fallback implementation - this shouldn't normally happen
      try {
        this.wallMaterial = new THREE.ShaderMaterial({
          uniforms: {
            wallColor: { value: new THREE.Color(0x888888) }, // Mid-grey for concrete base
            wallRoughness: { value: 0.8 }, // Higher roughness for concrete
            time: { value: 0.0 },
          },
          // Use material system to load vertex shader instead of inline definition
          // This ensures we're following the project organization guidelines
          vertexShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/common/vertex.glsl"
          ),
          fragmentShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/wall.glsl"
          ),
          side: THREE.DoubleSide,
        });

        console.log("Created fallback ShaderMaterial for walls");
      } catch (shaderError) {
        console.error(
          "Failed to create shader material fallback, using basic material",
          shaderError
        );

        // Ultra fallback - basic material if all else fails
        this.wallMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.75,
          side: THREE.DoubleSide,
        });

        console.log("Created basic MeshStandardMaterial for walls");
      }
    }

    // Make sure the wall material's side is set correctly
    if (this.wallMaterial) {
      this.wallMaterial.side = THREE.DoubleSide;
    }

    // Initialize corridor lighting shader material - using Severance's clinical lighting
    // Get lighting material from material system if available
    try {
      this.corridorLightingMaterial = this.materialSystem.getMaterial("light");
      console.log("Successfully got light material from material system");
    } catch (error) {
      console.warn(
        "Could not get 'light' shader material, creating fallback",
        error
      );

      try {
        this.corridorLightingMaterial = new THREE.ShaderMaterial({
          uniforms: {
            lightColor: { value: new THREE.Color(0xf0f7ff) }, // Subtle cool light
            intensity: { value: 0.8 }, // Brighter intensity for clinical look
            time: { value: 0.0 },
          },
          // Use material system to load vertex shader instead of inline definition
          vertexShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/common/vertex.glsl"
          ),
          fragmentShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/corridor.glsl"
          ),
          transparent: true,
          blending: THREE.AdditiveBlending,
        });

        console.log("Created fallback ShaderMaterial for corridor lighting");
      } catch (shaderError) {
        console.error(
          "Failed to create shader material for lighting, using basic material",
          shaderError
        );

        // Ultra fallback for lighting
        this.corridorLightingMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.2,
          blending: THREE.AdditiveBlending,
        });

        console.log("Created basic MeshBasicMaterial for corridor lighting");
      }
    }
  }

  /**
   * Creates a corridor network based on the Severance show layout
   * @private
   */
  createCorridorNetwork() {
    if (!this.corridorSegments || !this.scene) {
      console.error('Required properties not initialized');
      return;
    }

    // Clean up any old corridor or junction meshes
    this.corridorSegments.clear();
    if (this.scene.userData.junctionPositions) {
      this.scene.userData.junctionPositions.length = 0;
    }
    
    // Remove existing corridor elements
    const toRemove = [];
    this.scene.traverse((child) => {
      if (child.name && (child.name.startsWith('junction_') || child.name.startsWith('corridor_'))) {
        toRemove.push(child);
      }
    });
    toRemove.forEach(child => this.scene.remove(child));

    console.log("Creating Severance corridor network from CORRIDOR_MAP...");

    // Only allow main corridor nodes
    const mainCorridorNodeIds = new Set(['ELV', 'C1', 'C2', 'C3', 'C4', 'C5']);

    // Generate junctions for main corridor only
    for (const node of CORRIDOR_MAP.nodes) {
      if (!mainCorridorNodeIds.has(node.id)) {
        continue;
      }
      const worldX = node.pos[0] * SEGMENT_LENGTH;
      const worldZ = -node.pos[1] * SEGMENT_LENGTH;
      const position = new THREE.Vector3(worldX, 0, worldZ);
      this.createCorridorJunction(position, `junction_${node.id}`);
    }

    // Generate corridor segments for main corridor only
    for (const edge of CORRIDOR_MAP.edges) {
      if (!mainCorridorNodeIds.has(edge.from) || !mainCorridorNodeIds.has(edge.to)) {
        continue;
      }
      const fromNode = CORRIDOR_MAP.nodes.find((n) => n.id === edge.from);
      const toNode = CORRIDOR_MAP.nodes.find((n) => n.id === edge.to);
      if (!fromNode || !toNode) continue;
      const start = new THREE.Vector3(
        fromNode.pos[0] * SEGMENT_LENGTH,
        0,
        -fromNode.pos[1] * SEGMENT_LENGTH
      );
      const end = new THREE.Vector3(
        toNode.pos[0] * SEGMENT_LENGTH,
        0,
        -toNode.pos[1] * SEGMENT_LENGTH
      );
      const segmentId = `${edge.from}_${edge.to}`;
      this.createCorridorSegment(start, end, segmentId);
    }
  }

  /**
   * Adds a mesh to the list of collidable walls.
   * @param {THREE.Mesh} mesh The wall mesh to add.
   * @private
   */
  _addCollidableWall(mesh) {
    if (mesh instanceof THREE.Mesh) {
        this.wallMeshes.push(mesh);
        // Detailed logging for added walls
        const wallName = mesh.name || 'Unnamed Wall';
        const worldPos = new THREE.Vector3();
        mesh.getWorldPosition(worldPos);
        console.log(`[Env Collision] Added collidable wall: ${wallName} at world pos (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})`);
    } else {
        console.warn("Attempted to add non-Mesh object to collidable walls:", mesh);
    }
  }


  /**
   * Creates the floor for a corridor segment.
   * @param {number} length Length of the segment.
   * @param {THREE.Material} floorMaterial Material for the floor.
   * @returns {THREE.Mesh} The floor mesh.
   * @private
   */
  _createSegmentFloor(length, floorMaterial) {
    const floorGeometry = new THREE.PlaneGeometry(CORRIDOR_WIDTH, length);
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0; // Floor level
    // floor.position.z = length / 2; // Position set in createCorridorSegment
    return floor;
  }

  /**
   * Creates the ceiling for a corridor segment.
   * @param {number} length Length of the segment.
   * @param {THREE.Material} ceilingMaterial Material for the ceiling.
   * @returns {THREE.Mesh} The ceiling mesh.
   * @private
   */
  _createSegmentCeiling(length, ceilingMaterial) {
    const ceilingGeometry = new THREE.PlaneGeometry(CORRIDOR_WIDTH, length);
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = CORRIDOR_HEIGHT; // Position at ceiling height
    // ceiling.position.z = length / 2; // Position set in createCorridorSegment
    return ceiling;
  }

  /**
   * Creates the walls for a corridor segment.
   * @param {number} length Length of the segment geometry.
   * @param {THREE.Material} wallMaterial Material for the walls.
   * @param {THREE.Group} segmentGroup The group to add walls to.
   * @param {number} centerZ The adjusted center Z position for the geometry.
   * @private
   */
  _createSegmentWalls(length, wallMaterial, segmentGroup, centerZ) {
    const wallThickness = 0.1;
    const wallGeometry = new THREE.BoxGeometry(length, CORRIDOR_HEIGHT, wallThickness);

    // Use Tim Rodenbröker-inspired corridor wall material
    const segmentWallMaterial = this.materialSystem.getMaterial('corridorWall').clone();

    // Check for doorways near this segment
    const doorways = this.getDoorwaysForSegment(segmentGroup.position, length, segmentGroup); // Pass segmentGroup

    // Create left wall segments (with gaps for doors)
    this.createWallWithDoorways(
      -CORRIDOR_WIDTH / 2 - wallThickness / 2,
      centerZ,
      length,
      wallGeometry,
      segmentWallMaterial,
      segmentGroup,
      doorways.left,
      Math.PI / 2
    );

    // Create right wall segments (with gaps for doors)
    this.createWallWithDoorways(
      CORRIDOR_WIDTH / 2 + wallThickness / 2,
      centerZ,
      length,
      wallGeometry,
      segmentWallMaterial,
      segmentGroup,
      doorways.right,
      -Math.PI / 2
    );
  }

  // New helper method to create wall segments with doorways
  createWallWithDoorways(xPos, zPos, length, wallGeometry, material, parentGroup, doorways, rotation) {
    if (!doorways || doorways.length === 0) {
      // No doorways, create single wall
      const wall = new THREE.Mesh(
        wallGeometry,
        material
      );
      wall.position.set(xPos, CORRIDOR_HEIGHT / 2, zPos);
      wall.rotation.y = rotation;
      parentGroup.add(wall);
      this._addCollidableWall(wall);
      // Set wallScale and add to tunnelWallMeshes for uniform updates
      if (wall.material.uniforms && wall.material.uniforms.wallScale) {
        wall.material.uniforms.wallScale.value.set(wallGeometry.parameters.width, wallGeometry.parameters.height);
      }
      this.tunnelWallMeshes.push(wall);
      return;
    }

    console.log(`Creating wall with ${doorways.length} doorways at x:${xPos.toFixed(2)}, z:${zPos.toFixed(2)}, rotation:${rotation.toFixed(2)}`);

    // Sort doorways by position
    doorways.sort((a, b) => a.position.z - b.position.z);

    // Add small gap buffer to prevent z-fighting and tiny wall segments
    const minSegmentSize = 0.2;
    let currentZ = -length / 2;

    // Create wall segments between doorways
    doorways.forEach((doorway, index) => {
      const doorStart = doorway.position.z - doorway.width / 2;
      const doorEnd = doorway.position.z + doorway.width / 2;

      console.log(`Door ${index} spans local z: ${doorStart.toFixed(2)} to ${doorEnd.toFixed(2)}`);

      // Create wall segment before door if needed and if segment would be large enough
      if (doorStart > currentZ + minSegmentSize) {
        const segmentLength = doorStart - currentZ;
        const wallGeom = new THREE.BoxGeometry(segmentLength, CORRIDOR_HEIGHT, 0.1);
        const wallSegment = new THREE.Mesh(wallGeom, material);
        
        // Position the wall segment correctly
        wallSegment.position.set(
          xPos,
          CORRIDOR_HEIGHT / 2,
          currentZ + segmentLength / 2
        );
        wallSegment.rotation.y = rotation;
        
        parentGroup.add(wallSegment);
        this._addCollidableWall(wallSegment);
        console.log(`Created wall segment before door ${index}, length: ${segmentLength.toFixed(2)}`);
        // Set wallScale and add to tunnelWallMeshes for uniform updates
        if (wallSegment.material.uniforms && wallSegment.material.uniforms.wallScale) {
          wallSegment.material.uniforms.wallScale.value.set(segmentLength, CORRIDOR_HEIGHT);
        }
        this.tunnelWallMeshes.push(wallSegment);
      } else {
        console.log(`Skipping small wall segment before door ${index}, would be ${(doorStart - currentZ).toFixed(2)} units`);
      }

      currentZ = doorEnd;
    });

    // Create final wall segment after last door if needed
    if (currentZ < length / 2 - minSegmentSize) {
      const segmentLength = length / 2 - currentZ;
      const wallGeom = new THREE.BoxGeometry(segmentLength, CORRIDOR_HEIGHT, 0.1);
      const wallSegment = new THREE.Mesh(wallGeom, material);
      wallSegment.position.set(
        xPos,
        CORRIDOR_HEIGHT / 2,
        currentZ + segmentLength / 2
      );
      wallSegment.rotation.y = rotation;
      parentGroup.add(wallSegment);
      this._addCollidableWall(wallSegment);
      console.log(`Created final wall segment, length: ${segmentLength.toFixed(2)}`);
      // Set wallScale and add to tunnelWallMeshes for uniform updates
      if (wallSegment.material.uniforms && wallSegment.material.uniforms.wallScale) {
        wallSegment.material.uniforms.wallScale.value.set(segmentLength, CORRIDOR_HEIGHT);
      }
      this.tunnelWallMeshes.push(wallSegment);
    } else {
      console.log(`Skipping small final wall segment, would be ${(length/2 - currentZ).toFixed(2)} units`);
    }
  }

  // New helper method to find doorways for a corridor segment
  getDoorwaysForSegment(segmentPosition, length, segmentGroup) {
    const doorways = {
      left: [],
      right: []
    };

    // Check all doors
    for (const [name, doorState] of this.doorStates) {
      const doorInfo = window.doorLocations.find(d => d.name === name);
      if (!doorInfo) continue;

      // Calculate door position relative to segment
      // --- Transform world door position to segment's local space ---
      const localDoorPos = new THREE.Vector3();
      segmentGroup.worldToLocal(localDoorPos.copy(doorInfo.position)); // Use segmentGroup passed to _createSegmentWalls
      
      // Extended doorway check - ensure we're within segment length
      const halfLength = length / 2;
      if (Math.abs(localDoorPos.z) > halfLength) {
        // Door is outside this segment's Z range
        continue;
      }

      // Check if door is near this wall segment
      const doorwayWidth = DOORWAY_WIDTH; // Increased from 1.5 for wider doorways
      const doorwayInfo = {
        position: localDoorPos, // Use local position for Z calculation
        width: doorwayWidth
      };

      // Increased detection threshold for wall alignment
      const detectionThreshold = 1.2; // Increased further from 0.8

      // Determine which wall this door belongs to based on LOCAL X
      if (Math.abs(localDoorPos.x - CORRIDOR_WIDTH/2) < detectionThreshold) {
        doorways.right.push(doorwayInfo);
        console.log(`Doorway detected for segment ${segmentGroup.name || 'unnamed'}: ${name} on RIGHT wall at local Z: ${localDoorPos.z.toFixed(2)}`);
      } else if (Math.abs(localDoorPos.x + CORRIDOR_WIDTH/2) < detectionThreshold) {
        doorways.left.push(doorwayInfo);
        console.log(`Doorway detected for segment ${segmentGroup.name || 'unnamed'}: ${name} on LEFT wall at local Z: ${localDoorPos.z.toFixed(2)}`);
      }
    }

    console.log(`Segment ${segmentGroup.name || 'unnamed'} has ${doorways.left.length} left doorways and ${doorways.right.length} right doorways`);
    return doorways;
  }

  /**
   * Creates the baseboard trim for a corridor segment.
   * @param {number} length Length of the segment geometry.
   * @param {THREE.Material} trimMaterial Material for the trim.
   * @param {THREE.Group} segmentGroup The group to add trim to.
   * @param {number} centerZ The adjusted center Z position for the geometry.
   * @private
   */
  _createSegmentTrim(length, trimMaterial, segmentGroup, centerZ) {
    const trimHeight = CORRIDOR_TRIM_HEIGHT;
    const trimDepth = 0.05; // Small depth for the trim
    // Geometry length matches the effective segment length
    const baseboardGeometry = new THREE.BoxGeometry(length, trimHeight, trimDepth);

    // Left baseboard
    const leftBaseboard = new THREE.Mesh(baseboardGeometry, trimMaterial);
    leftBaseboard.position.set(
      -CORRIDOR_WIDTH / 2 + trimDepth / 2, // Offset slightly inward
      trimHeight / 2, // Position at floor level
      centerZ // Use adjusted center Z
    );
    leftBaseboard.rotation.y = Math.PI / 2; // Align with wall
    segmentGroup.add(leftBaseboard);

    // Right baseboard
    const rightBaseboard = new THREE.Mesh(baseboardGeometry, trimMaterial);
    rightBaseboard.position.set(
      CORRIDOR_WIDTH / 2 - trimDepth / 2, // Offset slightly inward
      trimHeight / 2,
      centerZ // Use adjusted center Z
    );
    rightBaseboard.rotation.y = -Math.PI / 2; // Align with wall
    segmentGroup.add(rightBaseboard);
  }

  /**
   * Creates a corridor segment between two points
   * @param {THREE.Vector3} start Start position
   * @param {THREE.Vector3} end End position
   * @param {string} id Segment identifier
   * @private
   */
  createCorridorSegment(start, end, id) {
    console.log(`Creating corridor segment ${id}`);

    // Create container for the segment
    const segment = new THREE.Group();
    segment.name = `corridor_${id}`;

    // Store start and end points in userData for corridor connectivity
    segment.userData = {
      startPoint: start.clone(),
      endPoint: end.clone(),
      id: id,
    };

    // Calculate segment length and direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    direction.normalize();

    // Calculate segment orientation
    const horizontalDir = new THREE.Vector3(
      direction.x,
      0,
      direction.z
    ).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      horizontalDir
    );

    // Apply rotation to the segment
    segment.quaternion.copy(quaternion);
    segment.position.copy(start);

    // --- Geometry Adjustment for Junctions ---
    const junctionOffset = CORRIDOR_WIDTH / 2; // Reduced from CORRIDOR_WIDTH/1.5 to align with junction size
    const isStartJunction = this._isNearJunction(start);
    const isEndJunction = this._isNearJunction(end);

    let adjustedStart = 0;
    let adjustedEnd = 0;

    if (isStartJunction) {
        adjustedStart = junctionOffset;
        console.log(`Segment ${id}: Adjusting start by ${adjustedStart} units (junction detected)`);
    }
    if (isEndJunction) {
        adjustedEnd = junctionOffset;
        console.log(`Segment ${id}: Adjusting end by ${adjustedEnd} units (junction detected)`);
    }

    const effectiveLength = length - adjustedStart - adjustedEnd;
    // Calculate the Z position for the center of the *shortened* geometry
    // It starts at adjustedStart and extends for effectiveLength
    const geometryCenterZ = adjustedStart + effectiveLength / 2;

    // Ensure effectiveLength is positive before creating geometry
    if (effectiveLength <= 0) {
        console.warn(`Segment ${id} has zero or negative effective length after junction adjustment. Skipping geometry.`);
        // Add segment to scene and store reference (even if empty, for consistency)
        this.scene.add(segment);
        this.corridorSegments.set(id, segment);
        return segment; // Return early
    }

    // Get materials from the system
    const wallMaterial = this.materialSystem.getMaterial("wall");
    const floorMaterial = this.materialSystem.getMaterial("floor"); // Always use corridor floor
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const trimMaterial = this.materialSystem.getMaterial("trim");

    // Create and add components using helper methods, passing adjusted values
    const floor = this._createSegmentFloor(effectiveLength, floorMaterial);
    floor.position.z = geometryCenterZ; // Adjust position
    segment.add(floor);

    const ceiling = this._createSegmentCeiling(effectiveLength, ceilingMaterial);
    ceiling.position.z = geometryCenterZ; // Adjust position
    segment.add(ceiling);
    // Record corridor ceiling for indoors detection
    this.ceilingMeshes.push(ceiling);

    // Skip walls for key corridor segments we've unblocked:
    // - C5 -> C6 (starting main corridor)
    // - C6 -> C7 (main corridor beyond C6)
    // - C6 -> Perpetuity (MP)
    // - C6 -> Security wing and C6 -> Testing wing (crossing corridor)
    const skipWallSegmentIds = new Set([
      'C5_C6', 'C6_C7', 'C6_PERP1',
      'C6_J_SEC', 'C6_J_TEST',
      'J_SEC_SEC1', 'J_TEST_TEST1'
    ]);
    if (!skipWallSegmentIds.has(id)) {
      this._createSegmentWalls(effectiveLength, wallMaterial, segment, geometryCenterZ);
    }
    this._createSegmentTrim(effectiveLength, trimMaterial, segment, geometryCenterZ);

    // Add segment to scene and store reference
    this.scene.add(segment);
    this.corridorSegments.set(id, segment);

    return segment;
  }

  /**
   * Checks if a given position is close to any known junction point.
   * @param {THREE.Vector3} position The position to check.
   * @param {number} threshold Optional distance squared threshold.
   * @returns {boolean} True if the position is near a junction, false otherwise.
   * @private
   */
  _isNearJunction(position, threshold = 1.0) { // Increased from 0.1 to 1.0 for better junction detection
    if (!this.scene.userData.junctionPositions) {
      return false;
    }
    for (const junctionPos of this.scene.userData.junctionPositions) {
      if (position.distanceToSquared(junctionPos) < threshold) {
        return true;
      }
    }
    return false;
  }

  /**
   * Creates the floor for a corridor junction.
   * @param {number} junctionSize Size of the junction area.
   * @param {THREE.Material} floorMaterial Material for the floor.
   * @returns {THREE.Mesh} The floor mesh.
   * @private
   */
   _createJunctionFloor(junctionSize, floorMaterial) {
    const floorGeometry = new THREE.PlaneGeometry(junctionSize, junctionSize);
    // Always use corridor floor for junctions
    const mat = this.materialSystem.getMaterial("floor");
    const floor = new THREE.Mesh(floorGeometry, mat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0.01; // Slight offset to prevent z-fighting
    return floor;
   }

   /**
    * Creates the ceiling for a corridor junction.
    * @param {number} junctionSize Size of the junction area.
    * @param {THREE.Material} ceilingMaterial Material for the ceiling.
    * @returns {THREE.Mesh} The ceiling mesh.
    * @private
    */
   _createJunctionCeiling(junctionSize, ceilingMaterial) {
    const ceilingGeometry = new THREE.PlaneGeometry(junctionSize, junctionSize);
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = CORRIDOR_HEIGHT;
    return ceiling;
   }

   /**
    * Creates the ceiling light fixture for a corridor junction.
    * @param {number} junctionSize Size of the junction area.
    * @param {THREE.Material} lightMaterial Material for the light fixture.
    * @returns {THREE.Mesh} The light fixture mesh.
    * @private
    */
   _createJunctionLightFixture(junctionSize, lightMaterial) {
    const lightGeometry = new THREE.CircleGeometry(junctionSize / 4, 16);
    const lightFixture = new THREE.Mesh(lightGeometry, lightMaterial);
    lightFixture.rotation.x = Math.PI / 2;
    lightFixture.position.y = CORRIDOR_HEIGHT - 0.05;
    return lightFixture;
   }

   /**
    * Creates the floor marking for a corridor junction.
    * @param {string} id Identifier for the junction (used to generate text).
    * @returns {THREE.Mesh} The floor marking mesh.
    * @private
    */
   _createJunctionMarking(id) {
    // Extract the node ID and add a prefix based on type
    const nodeId = id.split("_")[1];
    let markingText = nodeId;
    
    // Add prefixes based on junction type
    if (nodeId.startsWith('C')) {
        markingText = 'MC' + nodeId.substring(1); // Main Corridor
    } else if (nodeId.startsWith('J_')) {
        markingText = 'JC' + nodeId.substring(2); // Junction Connector
    } else if (nodeId === 'ELV') {
        markingText = 'EL1'; // Elevator
    } else {
        markingText = 'RM' + nodeId.substring(0, 2); // Room/Area
    }
    
    const markingPosition = new THREE.Vector3(0, 0.01, 0);
    const markingScale = 0.4;
    return this.createFloorMarking(markingText, markingPosition, markingScale);
  }

  /**
   * Creates a corridor junction/intersection for visual interest at corridor connections
   * @param {THREE.Vector3} position Position of the junction
   * @param {string} id Identifier for the junction
   * @private
   */
  createCorridorJunction(position, id) {
    console.log(`Creating corridor junction ${id}`);

    const junction = new THREE.Group();
    junction.name = `junction_${id}`;
    junction.position.copy(position);

    // Store junction data for corridor connection checks
    junction.userData = {
      id: id,
      position: position.clone(),
      isJunction: true,
      radius: CORRIDOR_WIDTH * 1.8,
    };

    // Create a larger floor area for the junction
    const junctionSize = CORRIDOR_WIDTH * 1.0;
    const floorMaterial = this.materialSystem.getMaterial("floor");
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const lightMaterial = this.materialSystem.getMaterial("light");

    // Create and add components using helper methods
    const floor = this._createJunctionFloor(junctionSize, floorMaterial);
    junction.add(floor);

    const ceiling = this._createJunctionCeiling(junctionSize, ceilingMaterial);
    junction.add(ceiling);
    // Record junction ceiling for indoors detection
    this.ceilingMeshes.push(ceiling);

    const lightFixture = this._createJunctionLightFixture(junctionSize, lightMaterial);
    junction.add(lightFixture);

    // --- IMPROVED: Junction Wall System ---
    const junctionWallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    if (junctionWallMaterial.uniforms && junctionWallMaterial.uniforms.wallColor) {
      junctionWallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      junctionWallMaterial.needsUpdate = true;
    } else if (junctionWallMaterial.color) {
      junctionWallMaterial.color.setHex(0xffffff);
    }

    const wallThickness = 0.1;
    const wallHeight = CORRIDOR_HEIGHT;
    const halfSize = junctionSize / 2;
    
    // Determine which directions have corridor or room connections
    const nodeId = id.split("_")[1];
    const connections = {
      north: false,
      south: false,
      east: false,
      west: false
    };
    
    for (const edge of CORRIDOR_MAP.edges) {
      if (edge.from === nodeId || edge.to === nodeId) {
        const otherNodeId = edge.from === nodeId ? edge.to : edge.from;
        const otherNode = CORRIDOR_MAP.nodes.find(n => n.id === otherNodeId);
        const thisNode = CORRIDOR_MAP.nodes.find(n => n.id === nodeId);
        if (otherNode && thisNode) {
          const dx = otherNode.pos[0] - thisNode.pos[0];
          const dz = otherNode.pos[1] - thisNode.pos[1];
          if (Math.abs(dx) > Math.abs(dz)) {
            if (dx > 0) connections.east = true;
            else connections.west = true;
          } else {
            if (dz > 0) connections.south = true;
            else connections.north = true;
          }
        }
      }
    }
    
    // Also check for direct room connections (room nodes adjacent to this junction)
    const roomNodeIds = new Set(['MDR1', 'OD1', 'WELL1', 'BREAK1']);
    for (const roomNodeId of roomNodeIds) {
      const roomNode = CORRIDOR_MAP.nodes.find(n => n.id === roomNodeId);
      const thisNode = CORRIDOR_MAP.nodes.find(n => n.id === nodeId);
      if (roomNode && thisNode) {
        const dx = roomNode.pos[0] - thisNode.pos[0];
        const dz = roomNode.pos[1] - thisNode.pos[1];
        if (Math.abs(dx) > Math.abs(dz)) {
          if (dx > 0) connections.east = true;
          else if (dx < 0) connections.west = true;
        } else {
          if (dz > 0) connections.south = true;
          else if (dz < 0) connections.north = true;
        }
      }
    }

    console.log(`Junction ${nodeId} connections (corridor/room):`, connections);
    
    const wallLength = junctionSize;

    // Helper to create a full side wall
    const createSideWall = (posX, posZ, rotationY, dirName) => {
        const geom = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
        const wall = new THREE.Mesh(geom, junctionWallMaterial.clone());
        wall.position.set(posX, wallHeight / 2, posZ);
        wall.rotation.y = rotationY;
        junction.add(wall);
        this._addCollidableWall(wall);
        console.log(`Created wall for junction ${nodeId} at (${posX.toFixed(2)}, ${posZ.toFixed(2)}), rotation ${rotationY.toFixed(2)} [${dirName}]`);
    };

    // Only add walls where there is truly no corridor or room connection
    if (!connections.north) {
        // Special case: open MC5 (C5) to outside by skipping north wall
        if (nodeId === "C5") {
            console.log("Skipping north wall for MC5 (C5) to allow exit to outside.");
        } else {
            createSideWall(0, halfSize, Math.PI, 'north'); // North Wall (facing South)
        }
    }
    if (!connections.south) {
        createSideWall(0, -halfSize, 0, 'south');    // South Wall (facing North)
    }
    if (!connections.east) {
        createSideWall(halfSize, 0, -Math.PI / 2, 'east'); // East Wall (facing West)
    }
    if (!connections.west) {
        createSideWall(-halfSize, 0, Math.PI / 2, 'west');  // West Wall (facing East)
    }

    // Store junction position for corridor connectivity
    if (!this.scene.userData.junctionPositions) {
      this.scene.userData.junctionPositions = [];
    }
    this.scene.userData.junctionPositions.push(position.clone());

    this.scene.add(junction);
    return junction;
  }

  /**
   * Creates an elevator vestibule at the entrance of the corridor network
   * @param {THREE.Vector3} position Position of the elevator vestibule
   * @private
   */
  createElevatorVestibule(position) {
    console.log("Creating Elevator Vestibule at:", position);

    const vestibule = new THREE.Group();
    vestibule.name = "elevator_vestibule";
    vestibule.position.copy(position);

    const hallWidth = CORRIDOR_WIDTH * 1.5; // Make the hall slightly wider than corridor
    const hallDepth = SEGMENT_LENGTH * 0.5; // Depth of the hall area
    const hallHeight = CORRIDOR_HEIGHT;

    // --- Create Hall Geometry ---
    let wallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    const wallThickness = 0.1; // Define wall thickness
    // Clone, ensure DoubleSide, and force color via NEW uniform value if possible
    wallMaterial = wallMaterial.clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }

    // Back Wall (opposite elevator)
    const backWallGeometry = new THREE.BoxGeometry(hallWidth, hallHeight, wallThickness);
    const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
    backWall.position.y = hallHeight / 2;
    backWall.position.z = -hallDepth - wallThickness / 2; // Position at the back of the vestibule
    vestibule.add(backWall);
    this._addCollidableWall(backWall); // Add vestibule back wall

    // Add baseboard trim
    const trimGeometry = new THREE.BoxGeometry(
        hallWidth, // Use hallWidth
        CORRIDOR_TRIM_HEIGHT,
        0.05
    );
    const trimMaterial = this.materialSystem.getMaterial("trim");

    const trim = new THREE.Mesh(trimGeometry, trimMaterial);
    trim.position.set(0, CORRIDOR_TRIM_HEIGHT / 2, -0.025);

    // Add ceiling light
    const lightGeometry = new THREE.PlaneGeometry(hallWidth * 0.5, 0.4);
    const lightMaterial = this.materialSystem.getMaterial("light");

    const light = new THREE.Mesh(lightGeometry, lightMaterial);
    light.position.set(0, hallHeight - 0.05, -hallDepth / 2);
    light.rotation.x = Math.PI / 2;
    vestibule.add(light);

    // Add ceiling
    const ceilingGeometry = new THREE.PlaneGeometry(hallWidth, hallDepth);
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.set(0, hallHeight, -hallDepth / 2);
    vestibule.add(ceiling);
    
    // Add ceiling to ceilingMeshes for indoor detection
    this.ceilingMeshes.push(ceiling);

    // Create side walls using BoxGeometry
    const sideWallGeometry = new THREE.BoxGeometry(hallDepth, hallHeight, wallThickness);
    // Left vestibule wall
    const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
    leftWall.position.x = -hallWidth / 2 - wallThickness / 2;
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.y = hallHeight / 2;
    leftWall.position.z = -hallDepth / 2;
    vestibule.add(leftWall);
    this._addCollidableWall(leftWall);
    // Right vestibule wall
    const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
    rightWall.position.x = hallWidth / 2 + wallThickness / 2;
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.y = hallHeight / 2;
    rightWall.position.z = -hallDepth / 2;
    vestibule.add(rightWall);
    this._addCollidableWall(rightWall);

    this.scene.add(vestibule);
    return vestibule;
  }

  /**
   * Creates a wall-mounted detail (sign, artwork etc.)
   * @param {THREE.Vector3} position Position of the detail
   * @returns {THREE.Group} The wall detail object
   * @private
   */
  createWallMountedDetail(position) {
    const detail = new THREE.Group();
    detail.position.copy(position);

    // Choose detail type randomly - now only 2 options (was 3)
    const detailType = Math.floor(Math.random() * 2);

    if (detailType === 0) {
      // Framed artwork/certificate
      const frameGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.04);
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.5,
        metalness: 0.2,
      });

      const frame = new THREE.Mesh(frameGeometry, frameMaterial);
      detail.add(frame);

      // Add artwork/certificate inside frame
      const artGeometry = new THREE.PlaneGeometry(0.45, 0.65);
      const artMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9,
        metalness: 0.0,
      });

      const art = new THREE.Mesh(artGeometry, artMaterial);
      art.position.z = 0.021;
      detail.add(art);
    } else {
      // Small sign
      const signGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.02);
      const signMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.3,
        metalness: 0.7,
      });

      const sign = new THREE.Mesh(signGeometry, signMaterial);
      detail.add(sign);
    }

    return detail;
  }

  /**
   * Creates a floor marking (number or text)
   * @param {string|number} text Text or number to display
   * @param {THREE.Vector3} position Position of the marking
   * @param {number} scale Scale of the marking (default: 0.2)
   * @returns {THREE.Mesh} The floor marking mesh
   * @private
   */
  createFloorMarking(text, position, scale = 0.2) {
    const canvas = document.createElement("canvas");
    canvas.width = 128;
    canvas.height = 128;
    const context = canvas.getContext("2d");

    // Draw the text on canvas
    context.fillStyle = "#ffffff";
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = "#333333";
    context.font = "bold 80px Arial";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillText(text.toString(), canvas.width / 2, canvas.height / 2);

    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);

    // Create marking plane - use MeshLambertMaterial instead of MeshBasicMaterial
    // as it works better for floor markings without needing emissive properties
    const markingGeometry = new THREE.PlaneGeometry(scale, scale);
    const markingMaterial = new THREE.MeshLambertMaterial({
      map: texture,
      transparent: true,
      depthWrite: false,
    });

    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
    marking.position.copy(position);
    marking.rotation.x = -Math.PI / 2;

    return marking;
  }

  /**
   * Create a department door with frame and sign (non-blocking)
   * @param {Object} sectionConfig - Configuration for the portfolio section
   * @private
   */
  async createPortfolioSectionDoor(sectionConfig) {
    console.log(`[Door Creation] Creating portfolio section door for ${sectionConfig.name}...`);

    // Check if door models were loaded successfully
    if (!this.doorModels.doorFrame || !this.doorModels.doorPivot) {
        console.error(`[Door Creation] Door models not loaded for ${sectionConfig.name}. Skipping door creation.`);
        return null;
    }

    const doorGroup = new THREE.Group();
    doorGroup.name = `door_${sectionConfig.name}`;
    
    let doorFrameModel, doorPivotModel, cardReaderModel, doorPanelMesh, doorPivotContainer;

    // --- Door Frame --- 
    console.log(`[Door Creation] Using GLB frame model for ${sectionConfig.name}`);
    doorFrameModel = this.doorModels.doorFrame.clone();
    doorFrameModel.position.y = 0; // GLB origin at base
    doorGroup.add(doorFrameModel);
    
    // --- Door Pivot and Panel --- 
    console.log(`[Door Creation] Using GLB pivot/panel model for ${sectionConfig.name}`);
    doorPivotModel = this.doorModels.doorPivot.clone();
    doorPivotContainer = doorPivotModel; // Now doorPivotContainer is properly declared
    
    // Find the actual door panel mesh within the loaded model
    doorPivotModel.traverse(child => {
        if (child.isMesh && !doorPanelMesh) {
            doorPanelMesh = child;
            console.log(`[Door Creation] Found door panel mesh in GLB: ${child.name || 'Unnamed'}`);
        }
    });

    if (!doorPanelMesh) {
        console.error(`[Door Creation] Could not find mesh inside door pivot model for ${sectionConfig.name}!`);
        return null;
    }

    // Apply material to the door panel mesh
    let doorMaterial = this.materialSystem.getMaterial("door").clone();
    doorMaterial.transparent = true;
    doorMaterial.opacity = 1.0;
    doorMaterial.depthWrite = true;
    doorMaterial.side = THREE.DoubleSide;
    
    // Apply interior color tint if specified
    if (doorMaterial instanceof THREE.MeshStandardMaterial && sectionConfig.interiorColor) {
        const baseColor = doorMaterial.color.clone();
        const interiorColor = new THREE.Color(sectionConfig.interiorColor);
        doorMaterial.color.lerp(interiorColor, 0.2);
    }
    
    doorPanelMesh.material = doorMaterial;
    doorPanelMesh.userData.originalMaterial = doorMaterial;
    doorPanelMesh.userData.doorFrame = doorFrameModel;
    
    // --- Hinge Pivot Setup ---
    // Create a new Group to act as the actual pivot point (hinge)
    const hingePivot = new THREE.Group();
    // Position the hinge at the edge of the doorframe (where the physical hinges would be)
    hingePivot.position.x = -DOORWAY_WIDTH / 2; 
    // The door width value for positioning
    const doorWidth = DOORWAY_WIDTH;
    // Position door pivot model so it aligns with the frame while still rotating around the hinge
    doorPivotModel.position.x = doorWidth / 2; 
    // Add the door model container to the hinge
    hingePivot.add(doorPivotModel);
    // --- End Hinge Pivot Setup ---

    // Add the hinge pivot (which now contains the door model) to the main door group
    doorGroup.add(hingePivot); // Changed from doorPivotContainer
    console.log(`[Door Creation] Added HINGE container for ${sectionConfig.name} at local pos:`, hingePivot.position); // Log hinge position
    
    // Initialize door state - PIVOT IS NOW THE HINGE GROUP
    this.doorStates.set(sectionConfig.name, {
        isOpen: false,
        currentAngle: 0,
        targetAngle: 0,
        pivot: hingePivot, // Use the new hinge group as the pivot
        openDirection: this.DOOR_OPEN_DIRECTION
    });
    
    // Link state to the hinge pivot for potential future reference
    hingePivot.userData.doorState = this.doorStates.get(sectionConfig.name); 

    // --- Card Reader --- 
    if (this.doorModels.cardReader) {
        console.log(`[Door Creation] Using GLB card reader model for ${sectionConfig.name}`);
        cardReaderModel = this.doorModels.cardReader.clone();
        cardReaderModel.position.set(DOORWAY_WIDTH/2 + 0.15, 2.5/2, 0.1);
        doorGroup.add(cardReaderModel);
    }

    // Add indicator light
    const indicatorGeometry = new THREE.CircleGeometry(0.02, 8);
    const indicatorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x00ff00, 
        emissive: 0x00ff00, 
        emissiveIntensity: 0.5, 
        roughness: 0.3, 
        metalness: 0.2 
    });
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
    indicator.position.copy(cardReaderModel ? cardReaderModel.position : new THREE.Vector3(DOORWAY_WIDTH/2 + 0.15, 2.5/2, 0.1));
    indicator.position.y += 0.06;
    indicator.position.z += 0.03;
    doorGroup.add(indicator);

    // --- Sign --- 
    const signGeometry = new THREE.PlaneGeometry(DOORWAY_WIDTH - 0.2, 0.3);
    const canvas = document.createElement("canvas");
    canvas.width = 512;
    canvas.height = 128;
    const context = canvas.getContext("2d");
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas.width, canvas.height);
    const mainText = sectionConfig.floorMarking || sectionConfig.name.toUpperCase().substring(0, 4);
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.font = "bold 72px Arial";
    context.fillStyle = "#FFFFFF";
    context.fillText(mainText, canvas.width/2, canvas.height/2 - 10);
    context.font = "bold 24px Arial";
    context.fillStyle = "#FFFFFF";
    context.fillText(sectionConfig.description || sectionConfig.name.replace("_", " "), canvas.width/2, canvas.height/2 + 35);
    const textTexture = new THREE.CanvasTexture(canvas);
    textTexture.anisotropy = 1;
    textTexture.needsUpdate = true;
    const signMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
    const sign = new THREE.Mesh(signGeometry, signMaterial);
    sign.position.y = 2.5 + 0.5;
    sign.position.z = 0.15;
    doorGroup.add(sign);
    const signLight = new THREE.PointLight(0xffffff, 2.0, 1.5);
    signLight.position.copy(sign.position);
    signLight.position.z += 0.2;
    doorGroup.add(signLight);

    // --- Add invisible interaction mesh in the doorway ---
    const interactionGeometry = new THREE.BoxGeometry(DOORWAY_WIDTH, 2.5, 0.3); // Doorway size
    const interactionMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const interactionMesh = new THREE.Mesh(interactionGeometry, interactionMaterial);
    interactionMesh.position.set(0, 2.5/2, 0); // Centered in the doorway
    interactionMesh.userData.doorName = sectionConfig.name;
    interactionMesh.userData.interactable = true;
    interactionMesh.name = sectionConfig.name + '_interaction';
    doorGroup.add(interactionMesh);
    // Store reference for getInteractableObjects
    if (!this._doorInteractionMeshes) this._doorInteractionMeshes = new Map();
    this._doorInteractionMeshes.set(sectionConfig.name, interactionMesh);

    // Set final position and rotation
    doorGroup.position.copy(sectionConfig.position);
    doorGroup.rotation.y = sectionConfig.rotation;
    this.scene.add(doorGroup);

    // Store references
    this.doors.set(sectionConfig.name, {
        doorGroup,
        frame: doorFrameModel,
        doorPanel: doorPanelMesh,
        doorPivot: hingePivot, // Store reference to the hinge pivot
        sign,
        cardReader: cardReaderModel,
        openDirection: this.DOOR_OPEN_DIRECTION,
    });

    // Add interactable object reference
    if (window.doorLocations) {
        doorPanelMesh.userData.interactable = true;
        doorPanelMesh.userData.doorName = sectionConfig.name;
        
        window.doorLocations.push({
            name: sectionConfig.name,
            position: sectionConfig.position.clone(),
            radius: 1.5,
            description: sectionConfig.description || sectionConfig.name.replace("_", " "),
            openDirection: this.DOOR_OPEN_DIRECTION,
            mesh: doorPanelMesh
        });
    }

    console.log(`[Door Creation] Successfully created door for ${sectionConfig.name}`);
    return doorGroup;
  }

  // --- Portfolio Section Configuration ---
  portfolioSectionsConfig = {
      DESIGN: {
        nodeId: "MDR1",
        name: "Interaction_Design",
        description: "UX/UI & Interaction Projects",
        rotation: -Math.PI / 2, // Changed from Math.PI / 2 to face corridor
        size: new THREE.Vector3(12, 4, 12),
        interiorColor: 0x4285f4,
        material: "default",
        floorMarking: "DESIGN",
        interiorType: "DESIGN",
        doorOffset: new THREE.Vector3(0, 0, 0) // Changed from (0,0,-1.5)
      },
      DEV: {
        nodeId: "OD1",
        name: "Development",
        description: "Code & Software Projects",
        rotation: Math.PI / 2,
        size: new THREE.Vector3(15, 4, 10),
        interiorColor: 0x34a853,
        material: "default",
        floorMarking: "CODE",
        interiorType: "DEV",
        doorOffset: new THREE.Vector3(0, 0, 0)
      },
      FILM: {
        nodeId: "WELL1",
        name: "Film_Cinema",
        description: "Filmmaking & Cinematography",
        rotation: -Math.PI / 2, // Keep facing -X (towards corridor)
        size: new THREE.Vector3(10, 4, 15),
        interiorColor: 0xfbbc05,
        material: "default",
        floorMarking: "FILM",
        interiorType: "FILM",
        doorOffset: new THREE.Vector3(-0.5, 0, 0) // Slight offset towards corridor for better connection
      },
      ART: {
        nodeId: "BREAK1",
        name: "Performance_Art",
        description: "Performance Pieces & Documentation",
        rotation: Math.PI / 2,
        size: new THREE.Vector3(10, 4, 10),
        interiorColor: 0xea4335,
        material: "default",
        floorMarking: "ART",
        interiorType: "ART",
        doorOffset: new THREE.Vector3(0, 0, 0) // Match Film_Cinema door position
      },
  };

  /**
   * Calculates the appropriate door position offset from an anchor node.
   * @param {THREE.Vector3} position Anchor node position.
   * @param {number} rotation Intended door rotation.
   * @returns {THREE.Vector3} Calculated door position.
   * @private
   */
  _calculateDoorPosition(position, rotation, config) {
    const doorPosition = position.clone();
    const doorOffsetDistance = CORRIDOR_WIDTH / 2 + 0.1; // Place slightly outside corridor

    // Apply any custom door offset if specified in the config
    if (config && config.doorOffset) {
      doorPosition.add(config.doorOffset);
    }

    // Determine offset based on rotation (simplified logic)
    if (Math.abs(rotation) < 0.1) { // Rotation 0 (Facing +Z)
      doorPosition.z += doorOffsetDistance;
    } else if (Math.abs(rotation - Math.PI) < 0.1) { // Rotation PI (Facing -Z)
      doorPosition.z -= doorOffsetDistance;
    } else if (Math.abs(rotation - Math.PI / 2) < 0.1) { // Rotation PI/2 (Facing +X)
      doorPosition.x += doorOffsetDistance;
    } else if (Math.abs(rotation + Math.PI / 2) < 0.1) { // Rotation -PI/2 (Facing -X)
      doorPosition.x -= doorOffsetDistance;
    }
    return doorPosition;
  }

  /**
   * Helper to get world position from map node ID.
   * @param {string} nodeId The ID of the node in CORRIDOR_MAP.
   * @returns {THREE.Vector3 | null} The world position or null if not found.
   * @private
   */
  _getNodeWorldPosition(nodeId) {
      const node = CORRIDOR_MAP.nodes.find((n) => n.id === nodeId);
      if (!node) {
        console.error(`Node ${nodeId} not found in CORRIDOR_MAP`);
        return null;
      }
      return new THREE.Vector3(
        node.pos[0] * SEGMENT_LENGTH,
        0,
        -node.pos[1] * SEGMENT_LENGTH // Negative Z extends away from elevator
      );
  }


  /**
   * Sets up the portfolio sections, defining their locations and properties.
   * This replaces the old setupDepartments method.
   * @private
   */
  setupPortfolioSections() {
    console.log("Setting up Portfolio Sections...");

    // Create geometry and doors for each section defined in config
    for (const config of Object.values(this.portfolioSectionsConfig)) {
      const anchorPosition = this._getNodeWorldPosition(config.nodeId);
      if (!anchorPosition) {
        console.warn(`Skipping section ${config.name} due to missing node position for ${config.nodeId}.`);
        continue;
      }

      console.log(`Setting up portfolio section: ${config.name} at node ${config.nodeId}`);

      // Define bounds (assuming anchorPosition is the center for now)
      const halfSize = config.size.clone().multiplyScalar(0.5);
      const bounds = new THREE.Box3(
        anchorPosition.clone().sub(halfSize),
        anchorPosition.clone().add(halfSize)
      );
      bounds.min.y = 0;
      bounds.max.y = config.size.y;

      const sectionData = {
        ...config,
        position: anchorPosition,
        bounds: bounds,
      };

      // Add section to map system if available
      const mapSystem = this.systems.get("map");
      if (mapSystem && mapSystem.defineZone) {
        mapSystem.defineZone(sectionData.name, sectionData.bounds, config.interiorColor || '#ffffff');
      }

      // --- Door positioning using junction-based approach for all doors ---
      let doorPosition;
      
      // Get the junction related to this section
      const junctionMapping = {
        "Interaction_Design": "J_MDR",
        "Development": "J_OD",
        "Film_Cinema": "J_WELL",
        "Performance_Art": "J_BREAK"
      };
      
      const junctionNodeId = junctionMapping[config.name];
      if (junctionNodeId) {
        console.log(`[Door Positioning] Calculating ${config.name} door position based on ${junctionNodeId}.`);
        const junctionPosition = this._getNodeWorldPosition(junctionNodeId);
        
        if (junctionPosition) {
          // Position door near the junction, facing the corridor
          doorPosition = junctionPosition.clone();
          
          // Apply appropriate offset based on the door's rotation
          if (Math.abs(config.rotation - Math.PI / 2) < 0.1) { // Facing +X
            doorPosition.x += CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation + Math.PI / 2) < 0.1) { // Facing -X
            doorPosition.x -= CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation) < 0.1) { // Facing +Z
            doorPosition.z += CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation - Math.PI) < 0.1) { // Facing -Z
            doorPosition.z -= CORRIDOR_WIDTH / 2;
          }
          
          console.log(`[Door Positioning] Calculated ${config.name} door position: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)}) based on ${junctionNodeId}.`);
          
          // Add a small outward offset for all doors calculated this way
          // This helps prevent clipping with potentially misaligned corridor ends
          const outwardOffset = 0.1; // Offset distance - Using a slightly larger offset for better visibility
          if (Math.abs(config.rotation - Math.PI / 2) < 0.1) { // Facing +X
            doorPosition.x += outwardOffset;
          } else if (Math.abs(config.rotation + Math.PI / 2) < 0.1) { // Facing -X
            doorPosition.x -= outwardOffset;
          } else if (Math.abs(config.rotation) < 0.1) { // Facing +Z
            doorPosition.z += outwardOffset;
          } else if (Math.abs(config.rotation - Math.PI) < 0.1) { // Facing -Z
            doorPosition.z -= outwardOffset;
          }
          console.log(`[Door Positioning] Applied outward offset (${outwardOffset}), new pos: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);

        } else {
          console.warn(`[Door Positioning] Could not find junction ${junctionNodeId} for ${config.name} door placement. Falling back.`);
          // Fallback to original calculation if junction not found
          doorPosition = this._calculateDoorPosition(anchorPosition, config.rotation, config);
        }
      } else {
        // Default calculation for doors without junction mapping
        doorPosition = this._calculateDoorPosition(anchorPosition, config.rotation, config);
      }
      // --------------------------------------------------

      this.createPortfolioSectionDoor({ ...sectionData, position: doorPosition });

      // Create interior space
      // Pass the calculated doorPosition to interior creation for wall checking
      this.createPortfolioSectionInteriors(sectionData.name, anchorPosition, sectionData.size, sectionData.interiorType, doorPosition);

      // --- Create tunnel from main corridor to door ---
      // Find the nearest corridor wall point to the door
      const nearestCorridorWall = this._findNearestCorridorWallPoint(doorPosition);
      if (nearestCorridorWall) {
        // Use the same width and height as the door/vestibule
        this._createCorridorToDoorTunnel(nearestCorridorWall.point, doorPosition, 1.2, CORRIDOR_HEIGHT);
      }

      // --- Create vestibule wall connecting door to room doorway ---
      // Find the doorway position (project door position onto room wall plane)
      // Use the same logic as in _createSectionWalls to find the wall and doorway center
      const doorwayWidth = 1.2;
      const wallHeight = config.size.y;
      // Find which wall is closest to the door
      const halfSizeX = config.size.x / 2;
      const halfSizeZ = config.size.z / 2;
      const wallPositions = [
        { name: 'back',  position: new THREE.Vector3(anchorPosition.x, anchorPosition.y + wallHeight / 2, anchorPosition.z + halfSizeZ), length: config.size.x, axis: 'x', rotationY: 0 },
        { name: 'front', position: new THREE.Vector3(anchorPosition.x, anchorPosition.y + wallHeight / 2, anchorPosition.z - halfSizeZ), length: config.size.x, axis: 'x', rotationY: Math.PI },
        { name: 'left',  position: new THREE.Vector3(anchorPosition.x - halfSizeX, anchorPosition.y + wallHeight / 2, anchorPosition.z), length: config.size.z, axis: 'z', rotationY: Math.PI / 2 },
        { name: 'right', position: new THREE.Vector3(anchorPosition.x + halfSizeX, anchorPosition.y + wallHeight / 2, anchorPosition.z), length: config.size.z, axis: 'z', rotationY: -Math.PI / 2 }
      ];
      let minDist = Infinity;
      let doorWall = null;
      wallPositions.forEach((wallData) => {
        const dist = wallData.position.distanceTo(doorPosition);
        if (dist < minDist) {
          minDist = dist;
          doorWall = wallData;
        }
      });
      // Project door position onto wall axis to get doorway center
      let doorwayCenter = doorWall.position.clone();
      if (doorWall.axis === 'x') {
        doorwayCenter.x = doorPosition.x;
      } else {
        doorwayCenter.z = doorPosition.z;
      }
      // The vestibule wall runs from doorPosition to doorwayCenter
      this._createDoorVestibuleWall(doorPosition, doorwayCenter, doorwayWidth, wallHeight, doorWall.rotationY);

      // Add floor markings at the anchor node position
      // const markingPosition = anchorPosition.clone();
      // markingPosition.y = 0.015;
      // const floorMarking = this.createFloorMarking(
      //   sectionData.floorMarking || sectionData.name.substring(0, 3),
      //   markingPosition,
      //   0.8
      // );
      // this.scene.add(floorMarking);
    }

    console.log("Portfolio Sections setup completed");
    
    // Add door frames after sections are created
    this.createDoorFrameWalls();
  }

  /**
   * Creates a vestibule wall connecting the corridor door to the room's doorway.
   * @param {THREE.Vector3} doorPos - Position of the door (corridor side)
   * @param {THREE.Vector3} doorwayPos - Position of the doorway (room wall)
   * @param {number} width - Width of the doorway/vestibule
   * @param {number} height - Height of the wall
   * @param {number} rotationY - Y rotation of the wall
   */
  _createDoorVestibuleWall(doorPos, doorwayPos, width, height, rotationY) {
    const depth = doorPos.distanceTo(doorwayPos);
    if (depth < 0.05) return; // No need if already touching
    const wallThickness = 0.12; // Thickness for side walls and ceiling
    // Clamp the tunnel height to a maximum of 2.5 (door height)
    const ceilingHeight = height; // Place ceiling at top of wall
    // Widen tunnel to fit both corridor and room wall, plus a small overlap to prevent leaks
    const vestibuleWidth = Math.max(width, CORRIDOR_WIDTH) + 0.15;
    // Calculate direction vector from door to doorway
    const dir = new THREE.Vector3().subVectors(doorwayPos, doorPos).normalize();
    // Midpoint for center reference
    const mid = new THREE.Vector3().addVectors(doorPos, doorwayPos).multiplyScalar(0.5);
    // Find right vector (perpendicular to dir, in XZ plane)
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(dir, up).normalize();
    // --- Ceiling ---
    const ceilingGeom = new THREE.BoxGeometry(vestibuleWidth, wallThickness, depth);
    const wallMaterial = this.materialSystem.getMaterial("corridorWall").clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }
    const ceiling = new THREE.Mesh(ceilingGeom, wallMaterial.clone());
    // Place ceiling at top
    ceiling.position.copy(mid);
    ceiling.position.y = doorPos.y + ceilingHeight - wallThickness/2;
    // Orient ceiling to connect the two points
    ceiling.lookAt(doorwayPos.x, ceiling.position.y, doorwayPos.z);
    ceiling.rotation.y = rotationY;
    this.scene.add(ceiling);
    this._addCollidableWall(ceiling);
    // Add ceiling to ceilingMeshes for rain/snow occlusion
    this.ceilingMeshes.push(ceiling);
    // --- Add vestibule floor with chevron pattern ---
    const floorMaterial = this.materialSystem.getMaterial('floor');
    const floorGeom = new THREE.BoxGeometry(vestibuleWidth, wallThickness, depth);
    const floor = new THREE.Mesh(floorGeom, floorMaterial);
    floor.position.copy(mid);
    floor.position.y = doorPos.y + wallThickness/2; // At ground level
    floor.lookAt(doorwayPos.x, floor.position.y, doorwayPos.z);
    floor.rotation.y = rotationY;
    this.scene.add(floor);
    // --- Side Walls ---
    const sideGeom = new THREE.BoxGeometry(wallThickness, ceilingHeight, depth);
    // Left wall
    const leftWall = new THREE.Mesh(sideGeom, wallMaterial.clone());
    leftWall.position.copy(mid);
    leftWall.position.add(right.clone().multiplyScalar(-(vestibuleWidth/2 - wallThickness/2)));
    leftWall.position.y = doorPos.y + ceilingHeight/2;
    leftWall.lookAt(doorwayPos.x, leftWall.position.y, doorwayPos.z);
    leftWall.rotation.y = rotationY;
    this.scene.add(leftWall);
    this._addCollidableWall(leftWall);
    // Right wall
    const rightWallMesh = new THREE.Mesh(sideGeom, wallMaterial.clone());
    rightWallMesh.position.copy(mid);
    rightWallMesh.position.add(right.clone().multiplyScalar((vestibuleWidth/2 - wallThickness/2)));
    rightWallMesh.position.y = doorPos.y + ceilingHeight/2;
    rightWallMesh.lookAt(doorwayPos.x, rightWallMesh.position.y, doorwayPos.z);
    rightWallMesh.rotation.y = rotationY;
    this.scene.add(rightWallMesh);
    this._addCollidableWall(rightWallMesh);
    // Log
    console.log(`[Vestibule] Created tunnel (ceiling + wider sides) from door to room at (${mid.x.toFixed(2)}, ${mid.y.toFixed(2)}, ${mid.z.toFixed(2)})`);
  }

  /**
   * Find the nearest junction to a position
   * @param {THREE.Vector3} position The position to check
   * @returns {THREE.Vector3|null} The nearest junction position or null
   * @private
   */
  findNearestJunction(position) {
    let nearestJunction = null;
    let nearestDistance = Infinity;

    // Find all junctions in the scene
    const junctions = this.scene.children.filter(
      (child) => child.name && child.name.startsWith("junction_")
    );

    // Find the nearest junction
    junctions.forEach((junction) => {
      const distance = position.distanceTo(junction.position);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearestJunction = junction.position;
      }
    });

    return nearestJunction ? nearestJunction.clone() : null;
  }

  /**
   * Set up the lighting system to match Severance's clinical aesthetic
   * @private
   */
  async setupLighting() {
    console.log("[Environment] Setting up lighting...");

    // Create ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambientLight);
    
    // Create directional light for subtle shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(50, 50, 50);
    this.scene.add(directionalLight);
    
    // Add the global point light
    const globalLight = new THREE.PointLight(0xffffff, 0.5);
    globalLight.position.set(0, 20, 0);
    this.scene.add(globalLight);
    
    // Add special bright doorway lights with no falloff to ensure interior visibility
    if (window.doorLocations) {
      for (const doorLocation of window.doorLocations) {
        if (!doorLocation.position) continue;
        
        // Create super bright light at doorway
        const doorwayLight = new THREE.PointLight(0xffffff, 5.0, 0); // No distance falloff
        doorwayLight.position.copy(doorLocation.position);
        doorwayLight.position.y += 1.8; // Head height
        
        this.scene.add(doorwayLight);
        console.log(`[Lighting] Added super bright light at doorway: ${doorLocation.name}`);
      }
    }

    // Set up corridor lighting
    this._setupCorridorLighting();

    console.log("[Environment] Lighting setup complete.");
  }

  /**
   * Set up corridor lighting
   * @private
   */
  _setupCorridorLighting() {
    // Create fluorescent panel lights - the iconic ceiling fixtures from the show
    const lightMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xf7faff, // Slightly bluish tint for the Severance look
      emissiveIntensity: 0.9,
      roughness: 0.2,
      metalness: 0.1,
    });
    
    // Store lights for flickering effects
    this.assets.lights.set("fluorescents", new THREE.Group());

    // Add subtle directional light for minimal shadowing
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
    directionalLight.position.set(0, 1, 0);
    directionalLight.castShadow = false;
    this.scene.add(directionalLight);
    
    console.log("[Environment] Corridor lighting set up");
  }

  /**
   * Update the environment state
   * @param {number} deltaTime - Time since last frame in seconds
   * @override
   */
  update(deltaTime) {
    // Ensure deltaTime is always a valid positive number
    if (typeof deltaTime !== "number" || !isFinite(deltaTime) || deltaTime <= 0) {
      deltaTime = this.clock.getDelta();
    }
    
    // Call the parent class update method
    super.update(deltaTime);
    
    // Update corridor controller
    const corridorSystem = this.systems.get("corridor");
    if (corridorSystem && corridorSystem.update) {
      corridorSystem.update(deltaTime);
    }

    // Update movement system
    if (this.movementController && this.movementController.update) {
      this.movementController.update(deltaTime);
    }

    // Doors animation updates
    this.updateDoorAnimations(deltaTime);

    // Update post-processing effects (like chromatic aberration)
    this.updatePostProcessing(deltaTime);

    // Update dynamic lighting
    this.updateLighting(deltaTime);

    // Update weather effects (potentially)
    this.updateWeather(deltaTime);

    // Update any interaction buttons (E to interact)
    if (this.camera) {
      this.updateInteractionButtons(this.camera);
    }

    // Update art room animations
    if (this._artRoomAnimations && this._artRoomAnimations.length > 0) {
      for (const animationFn of this._artRoomAnimations) {
        animationFn(deltaTime);
      }
    }
    
    // Check if there's an active performance art letter generator
    if (this.letterGenerator && this.letterGenerator.update) {
      // Ensure the letter generator gets updated even if not part of _artRoomAnimations
      this.letterGenerator.update(deltaTime);
    }
    
    // Update all systems
    for (const [name, system] of this.systems) {
      if (system.update) {
        system.update(deltaTime);
      }
    }

    // --- Floor visibility fix for corridor flicker ---
    if (this.globalFloor) {
      if (this._wasOutdoors === undefined) this._wasOutdoors = null;
      const isOutdoors = this.isPlayerOutdoors();
      if (isOutdoors !== this._wasOutdoors) {
        this.globalFloor.visible = isOutdoors;
        this._wasOutdoors = isOutdoors;
      }
    }
  }

  /**
   * Update lighting effects
   * @private
   */
  updateLighting(deltaTime) {
    if (this.emergencyLighting) {
      this.lightFlickerIntensity = Math.random() * 0.4 + 0.6;
      const lights = this.assets.lights.get("fluorescents");
      if (lights) {
        lights.children.forEach((light) => {
          light.intensity = this.lightFlickerIntensity;
        });
      }
    }
  }

  /**
   * Set player position and rotation
   * @param {THREE.Vector3} position - New player position
   * @param {THREE.Euler} rotation - New player rotation
   */
  setPlayerPosition(position, rotation) {
    if (this.camera) {
      this.camera.position.copy(position);
      this.camera.rotation.copy(rotation);
    }
    // Also update the movement controller's internal state
    if (this.movementController) {
      this.movementController.position.copy(position);
      this.movementController.rotation.copy(rotation);
      // Optionally update global references if still needed
      window.playerPosition = this.movementController.position;
      window.playerRotation = this.movementController.rotation.y;
      window.cameraPitch = this.movementController.rotation.x;
    }
  }

  /**
   * Get the current player location
   * @returns {string} The current department or corridor name
   */
  getCurrentLocation() {
    if (!this.camera) return "Unknown";

    // Check if in any department - REMOVED departmentBounds check
    /*
    for (const [name, bounds] of this.departmentBounds) {
      if (bounds.containsPoint(this.camera.position)) {
        return name;
      }
    }
    */

    // TODO: Implement logic to detect which portfolio section the player is in,
    // potentially based on proximity to section entrances or defined zones.
    // For now, just return "CORRIDOR".

    // If not in a department, must be in a corridor
    return "CORRIDOR";
  }

  /**
   * Get current segment based on player position
   * @returns {Object} Segment information
   */
  getCurrentSegment() {
    // Get player position
    const position = this.camera.position;

    // Find closest corridor segment
    let closestSegment = null;
    let closestDistance = Infinity;

    for (const [id, segment] of this.corridorSegments) {
      // Calculate distance to segment
      const segmentWorldPos = new THREE.Vector3();
      segment.getWorldPosition(segmentWorldPos);
      const distance = position.distanceTo(segmentWorldPos);

      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = { id, segment };
      }
    }

    // Get department information - REMOVED departmentBounds check
    /*
    for (const [deptName, bounds] of this.departmentBounds) {
      if (bounds.containsPoint(position)) {
        return {
          department: deptName.toLowerCase(),
          position: position.clone(),
        };
      }
    }
    */

    // TODO: Adapt this to return portfolio section info later.
    // For now, it primarily returns corridor info based on segments.

    // Return corridor segment info if found
    if (closestSegment) {
      const segmentId = closestSegment.id;
      // Extract department from segment ID (e.g., "mdr_hallway" -> "mdr")
      const department = segmentId.includes("_")
        ? segmentId.split("_")[0]
        : "corridor";

      return {
        department: department,
        position: position.clone(),
      };
    }

    return { department: "unknown", position: position.clone() };
  }

  /**
   * Toggle emergency lighting mode
   * @param {boolean} enabled - Whether to enable emergency lighting
   */
  setEmergencyLighting(enabled) {
    this.emergencyLighting = enabled;

    // Update all lights
    this.assets.lights.forEach((light) => {
      if (light instanceof THREE.Group) {
        light.children.forEach((child) => {
          if (child instanceof THREE.Light) {
            child.intensity = enabled ? 0.1 : 1.0;
          }
        });
      } else if (light instanceof THREE.Light) {
        light.intensity = enabled ? 0.1 : 1.0;
      }
    });
  }

  /**
   * Clean up resources
   * @override
   */
  dispose() {
    // Clean up all Three.js resources
    console.log("Disposing SeveranceEnvironment");
    
    // Dispose letter generator if it exists
    if (this.letterGenerator) {
      this.letterGenerator.dispose();
      this.letterGenerator = null;
    }
    
    this.disposeCollidableWalls();
    this.disposeInteractableObjects();

    // Clear animations
    this._artRoomAnimations = [];

    // Clean up systems
    for (const system of this.systems.values()) {
      if (system.dispose) {
        system.dispose();
      }
    }

    // Clear references
    this.systems.clear();
    this.doors.clear();
    this.interactiveObjects.clear();
    // REMOVED: this.departmentBounds.clear();
    this.corridorSegments.clear();
    this.wayfinding.clear(); // Clear wayfinding elements

    // Don't dispose movement controller here as it's managed by main.js

    // Clear global references
    window.doorLocations = [];
  }

  /**
   * Creates the interior walls for a standard rectangular portfolio section.
   * Adds the walls to the collidable mesh list.
   * @param {THREE.Vector3} center Center position of the section.
   * @param {THREE.Vector3} size Size of the section (x, y, z).
   * @param {THREE.Material} wallMaterial The material to use for the walls.
   * @param {THREE.Group} parentGroup The group to add the walls to.
   * @param {THREE.Vector3} doorPosition The position of the door for this section.
   * @private
   */
  _createSectionWalls(center, size, wallMaterial, parentGroup, doorPosition) {
      const halfSizeX = size.x / 2;
      const halfSizeZ = size.z / 2;
      const wallHeight = size.y;
      const doorwayWidth = DOORWAY_WIDTH; // Use the constant for consistency
      const sectionWallMaterial = wallMaterial.clone();
      if (sectionWallMaterial.uniforms && sectionWallMaterial.uniforms.wallColor) {
        sectionWallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
        sectionWallMaterial.needsUpdate = true;
      } else if (sectionWallMaterial.color) {
        sectionWallMaterial.color.setHex(0xffffff);
      }

      // Define potential wall positions and orientations
      const wallPositions = [
          { name: 'back',  position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z + halfSizeZ), length: size.x, axis: 'x', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: 0 },
          { name: 'front', position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z - halfSizeZ), length: size.x, axis: 'x', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: Math.PI },
          { name: 'left',  position: new THREE.Vector3(center.x - halfSizeX, center.y + wallHeight / 2, center.z), length: size.z, axis: 'z', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: Math.PI / 2 },
          { name: 'right', position: new THREE.Vector3(center.x + halfSizeX, center.y + wallHeight / 2, center.z), length: size.z, axis: 'z', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: -Math.PI / 2 }
      ];

      // Find the wall closest to the door
      let minDist = Infinity;
      let doorWallIdx = -1;
      wallPositions.forEach((wallData, idx) => {
        const dist = wallData.position.distanceTo(doorPosition);
        if (dist < minDist) {
          minDist = dist;
          doorWallIdx = idx;
        }
      });

      wallPositions.forEach((wallData, idx) => {
        if (idx === doorWallIdx) {
          // This is the wall with the doorway
          // Project door position onto wall axis
          let doorCoord, wallCenterCoord, halfLen;
          if (wallData.axis === 'x') {
            doorCoord = doorPosition.x;
            wallCenterCoord = wallData.position.x;
            halfLen = wallData.length / 2;
          } else {
            doorCoord = doorPosition.z;
            wallCenterCoord = wallData.position.z;
            halfLen = wallData.length / 2;
          }
          // Compute left and right segment lengths
          const leftLen = Math.max(0, (doorCoord - doorwayWidth/2) - (wallCenterCoord - halfLen));
          const rightLen = Math.max(0, (wallCenterCoord + halfLen) - (doorCoord + doorwayWidth/2));
          // Left segment
          if (leftLen > 0.05) {
            const leftGeom = wallData.geometry(leftLen);
            // Clone material and set wallScale for this segment
            const matL = sectionWallMaterial.clone();
            if (matL.uniforms && matL.uniforms.wallScale) {
              matL.uniforms.wallScale.value.set(leftLen, wallHeight);
            }
            const leftMesh = new THREE.Mesh(leftGeom, matL);
            // Position left segment
            if (wallData.axis === 'x') {
              leftMesh.position.set(
                wallCenterCoord - halfLen + leftLen/2,
                wallData.position.y,
                wallData.position.z
              );
            } else {
              leftMesh.position.set(
                wallData.position.x,
                wallData.position.y,
                wallCenterCoord - halfLen + leftLen/2
              );
            }
            leftMesh.rotation.y = wallData.rotationY;
            parentGroup.add(leftMesh);
            this._addCollidableWall(leftMesh);
          }
          // Right segment
          if (rightLen > 0.05) {
            const rightGeom = wallData.geometry(rightLen);
            // Clone material and set wallScale for this segment
            const matR = sectionWallMaterial.clone();
            if (matR.uniforms && matR.uniforms.wallScale) {
              matR.uniforms.wallScale.value.set(rightLen, wallHeight);
            }
            const rightMesh = new THREE.Mesh(rightGeom, matR);
            // Position right segment
            if (wallData.axis === 'x') {
              rightMesh.position.set(
                wallCenterCoord + halfLen - rightLen/2,
                wallData.position.y,
                wallData.position.z
              );
            } else {
              rightMesh.position.set(
                wallData.position.x,
                wallData.position.y,
                wallCenterCoord + halfLen - rightLen/2
              );
            }
            rightMesh.rotation.y = wallData.rotationY;
            parentGroup.add(rightMesh);
            this._addCollidableWall(rightMesh);
          }
          // Log
          console.log(`[Section Walls] Created doorway in wall '${wallData.name}' for section ${parentGroup.name}`);
        } else {
          // Normal wall
          // Clone material and set wallScale for full wall
          const matW = sectionWallMaterial.clone();
          if (matW.uniforms && matW.uniforms.wallScale) {
            matW.uniforms.wallScale.value.set(wallData.length, wallHeight);
          }
          const wall = new THREE.Mesh(wallData.geometry(wallData.length), matW);
              // Adjust position slightly based on thickness and rotation to align outer face
              const offset = new THREE.Vector3(0, 0, 0.05).applyAxisAngle(new THREE.Vector3(0, 1, 0), wallData.rotationY);
              wall.position.copy(wallData.position).add(offset);
              wall.rotation.y = wallData.rotationY;
              parentGroup.add(wall);
              this._addCollidableWall(wall);
              console.log(`[Section Walls] Created wall '${wallData.name}' for section ${parentGroup.name}`);
          }
      });
  }

  /**
   * Creates a basic placeholder interior for a section.
   * @param {THREE.Group} interiorGroup The group to add the placeholder to.
   * @param {THREE.Vector3} center Center position.
   * @param {THREE.Vector3} size Size of the section.
   * @param {THREE.Vector3} doorPosition Position of the door for lighting.
   * @private
   */
  _createPlaceholderInterior(interiorGroup, center, size, doorPosition) {
    // --- Add door entrance lighting if doorPosition is provided ---
    if (doorPosition) {
      // Create vector from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Create a special white light at the entryway
      const entryLight = new THREE.SpotLight(0xffffff, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0))); // Above the door
      
      // Point the spotlight into the room
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // FIX: Add more visible elements to interior
    
    // Create a general interior light
    const interiorLight = new THREE.PointLight(0xffffff, 1.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // Add some ceiling lights
    const ceilingLightCount = 4;
    for (let i = 0; i < ceilingLightCount; i++) {
      const lightX = center.x + (Math.random() - 0.5) * size.x * 0.8;
      const lightZ = center.z + (Math.random() - 0.5) * size.z * 0.8;
      
      // Create ceiling light fixture
      const lightFixture = new THREE.Group();
      
      // Light housing
      const housingGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const housingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc, 
        roughness: 0.5,
        metalness: 0.8 
      });
      const housing = new THREE.Mesh(housingGeometry, housingMaterial);
      housing.position.y = -0.05;
      lightFixture.add(housing);
      
      // Light lens
      const lensGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.02, 16);
      const lensMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.1
      });
      const lens = new THREE.Mesh(lensGeometry, lensMaterial);
      lens.position.y = -0.09;
      lightFixture.add(lens);
      
      // Position the fixture
      lightFixture.position.set(lightX, center.y + size.y - 0.05, lightZ);
      interiorGroup.add(lightFixture);
      
      // Add the actual light source below the fixture
      const light = new THREE.PointLight(0xffffee, 1.5, size.y * 1.5, 1);
      light.position.set(lightX, center.y + size.y - 0.2, lightZ);
      interiorGroup.add(light);
    }
    
    // Create furniture
    /*
    const placeholderGeometry = new THREE.BoxGeometry(size.x * 0.8, size.y * 0.75, size.z * 0.8);
    const placeholderMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.8,
        wireframe: false // Change to solid rather than wireframe
    });
    const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    // Position placeholder centered within the section bounds
    placeholderMesh.position.set(center.x, center.y + size.y * 0.375, center.z);
    interiorGroup.add(placeholderMesh);
    */
    
    console.log(`Added placeholder interior with lighting for ${interiorGroup.name}`);
  }

  // --- Specific Interior Creation Methods --- //

  /** Creates interior for Interaction Design section. */
  _createDesignInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating DESIGN interior (Tim Rodenbröker style) at ${center.x}, ${center.z}`);
    
    // Remove any old poster or mural meshes from previous renders
    const toRemove = [];
    interiorGroup.traverse(child => {
      if (child.isMesh && (
        (child.geometry && (child.geometry.type === 'PlaneGeometry' || child.geometry.type === 'BoxGeometry')) &&
        (child.material && (child.material.map instanceof THREE.CanvasTexture || child.material.color?.getHex() === 0x222222))
      )) {
        toRemove.push(child);
      }
    });
    toRemove.forEach(mesh => {
      if (mesh.parent) mesh.parent.remove(mesh);
    });
    
    // Entry and general lighting
    if (doorPosition) {
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      const entryLight = new THREE.SpotLight(0x4285f4, 4.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0)));
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    const interiorLight = new THREE.PointLight(0xffffff, 2.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // --- Professional Gallery Wall with Framed Posters ---
    // Helper to create a framed poster (canvas-based)
    /*
    function createFramedPoster(text, accentColor, width = 1.1, height = 1.6) {
      // Create canvas for poster art
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');
      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Accent geometric design
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = accentColor;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(canvas.width, 0);
      ctx.lineTo(canvas.width, canvas.height * 0.4);
      ctx.lineTo(0, canvas.height * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      // Main text
      ctx.font = 'bold 72px Arial';
      ctx.fillStyle = accentColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width/2, canvas.height/2 - 40);
      // Subtitle
      ctx.font = '32px Arial';
      ctx.fillStyle = '#222';
      ctx.fillText('Creative Coding', canvas.width/2, canvas.height/2 + 40);
      // Signature
      ctx.font = 'italic 24px Arial';
      ctx.fillStyle = '#888';
      ctx.fillText('Tim Rodenbröker', canvas.width/2, canvas.height - 50);
      // Texture
      const texture = new THREE.CanvasTexture(canvas);
      // Frame
      const frameDepth = 0.05;
      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, frameDepth),
        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.3 })
      );
      // Poster
      const poster = new THREE.Mesh(
        new THREE.PlaneGeometry(width * 0.92, height * 0.92),
        new THREE.MeshStandardMaterial({ map: texture, roughness: 0.5, metalness: 0.1 })
      );
      poster.position.z = frameDepth/2 + 0.001;
      // Group
      const group = new THREE.Group();
      group.add(frame);
      group.add(poster);
      return group;
    }
    */

    // Arrange 4 posters on the back wall (Z), spread along X, facing into the room
    /*
    const posterWallZ = center.z - size.z/2 + 0.08;
    const posterY = center.y + 1.3;
    const posterSpacing = 1.4;
    const accentColors = ['#4285f4', '#ea4335', '#fbbc05', '#34a853'];
    const posterTitles = ['Generative Grid', 'Type & Code', 'Color Systems', 'Motion Design'];
    for (let i = 0; i < 4; i++) {
      const poster = createFramedPoster(posterTitles[i], accentColors[i]);
      poster.position.set(center.x - posterSpacing * 1.5 + i * posterSpacing, posterY, posterWallZ);
      poster.rotation.y = 0;
      interiorGroup.add(poster);
      // Accent spotlight above each poster (slightly in front of the poster)
      const spot = new THREE.SpotLight(accentColors[i], 2.2, 5.0, Math.PI/8, 0.5, 1);
      spot.position.set(poster.position.x, poster.position.y + 1.1, poster.position.z + 0.1);
      spot.target.position.copy(poster.position);
      spot.target.updateMatrixWorld();
      interiorGroup.add(spot);
      interiorGroup.add(spot.target);
    }
    */

    // --- Geometric Mural on Left Wall ---
    // Use a large plane with a canvas texture
    /*
    const muralWidth = size.x * 0.7;
    const muralHeight = size.y * 0.7;
    const muralCanvas = document.createElement('canvas');
    muralCanvas.width = 1024;
    muralCanvas.height = 1024;
    const muralCtx = muralCanvas.getContext('2d');
    muralCtx.fillStyle = '#f4f4f4';
    muralCtx.fillRect(0, 0, muralCanvas.width, muralCanvas.height);
    // Draw geometric pattern (grid + circles)
    muralCtx.strokeStyle = '#4285f4';
    muralCtx.lineWidth = 6;
    for (let i = 1; i < 6; i++) {
      muralCtx.beginPath();
      muralCtx.moveTo(i * 170, 0);
      muralCtx.lineTo(i * 170, muralCanvas.height);
      muralCtx.stroke();
      muralCtx.beginPath();
      muralCtx.moveTo(0, i * 170);
      muralCtx.lineTo(muralCanvas.width, i * 170);
      muralCtx.stroke();
    }
    muralCtx.globalAlpha = 0.18;
    muralCtx.fillStyle = '#ea4335';
    muralCtx.beginPath();
    muralCtx.arc(300, 300, 180, 0, 2 * Math.PI);
    muralCtx.fill();
    muralCtx.globalAlpha = 0.12;
    muralCtx.fillStyle = '#fbbc05';
    muralCtx.beginPath();
    muralCtx.arc(700, 700, 140, 0, 2 * Math.PI);
    muralCtx.fill();
    const muralTexture = new THREE.CanvasTexture(muralCanvas);
    const mural = new THREE.Mesh(
      new THREE.PlaneGeometry(muralWidth, muralHeight),
      new THREE.MeshStandardMaterial({ map: muralTexture, roughness: 0.6, metalness: 0.1 })
    );
    mural.position.set(center.x - size.x/2 + 0.08, center.y + muralHeight/2 + 0.2, center.z);
    mural.rotation.y = Math.PI/2;
    interiorGroup.add(mural);
    // Add a soft white light to wash the mural
    const muralLight = new THREE.SpotLight(0xffffff, 1.2, 7.0, Math.PI/6, 0.7, 1);
    muralLight.position.set(mural.position.x + 0.2, mural.position.y + 1.2, mural.position.z);
    muralLight.target.position.copy(mural.position);
    muralLight.target.updateMatrixWorld();
    interiorGroup.add(muralLight);
    interiorGroup.add(muralLight.target);
    */

    // --- Minimal, Modern Central Table ---
    const tableGeometry = new THREE.BoxGeometry(2.2, 0.09, 1.1);
    const tableMaterial = new THREE.MeshStandardMaterial({ color: 0xf4f4f4, roughness: 0.25, metalness: 0.18 });
    const table = new THREE.Mesh(tableGeometry, tableMaterial);
    table.position.set(center.x, center.y + 0.7, center.z);
    interiorGroup.add(table);
    // Add a blue accent line on the table (as a thin box)
    const accentGeom = new THREE.BoxGeometry(2.0, 0.01, 0.07);
    const accentMat = new THREE.MeshStandardMaterial({ color: 0x4285f4, roughness: 0.2, metalness: 0.5 });
    const accent = new THREE.Mesh(accentGeom, accentMat);
    accent.position.set(center.x, table.position.y + 0.055, center.z);
    interiorGroup.add(accent);

    // --- Subtle Floor Logo/Marking near Entrance ---
    if (doorPosition) {
      const logoCanvas = document.createElement('canvas');
      logoCanvas.width = 256;
      logoCanvas.height = 256;
      const logoCtx = logoCanvas.getContext('2d');
      logoCtx.clearRect(0, 0, 256, 256);
      logoCtx.globalAlpha = 0.18;
      logoCtx.fillStyle = '#4285f4';
      logoCtx.beginPath();
      logoCtx.arc(128, 128, 110, 0, 2 * Math.PI);
      logoCtx.fill();
      logoCtx.globalAlpha = 1.0;
      logoCtx.font = 'bold 48px Arial';
      logoCtx.fillStyle = '#222';
      logoCtx.textAlign = 'center';
      logoCtx.textBaseline = 'middle';
      logoCtx.fillText('DESIGN', 128, 128);
      const logoTexture = new THREE.CanvasTexture(logoCanvas);
      const logoMat = new THREE.MeshStandardMaterial({ map: logoTexture, transparent: true, opacity: 0.7, roughness: 0.4 });
      const logoMesh = new THREE.Mesh(new THREE.CircleGeometry(0.9, 48), logoMat);
      logoMesh.position.copy(doorPosition.clone());
      logoMesh.position.y = center.y + 0.02;
      logoMesh.rotation.x = -Math.PI/2;
      interiorGroup.add(logoMesh);
    }
  }

  /** Creates interior for Development section. */
  async _createDevInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating DEV interior at ${center.x}, ${center.z}`);
    // --- Special lighting at door entrance ---
    if (doorPosition) {
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      const entryLight = new THREE.SpotLight(0x34a853, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0)));
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // General interior light - modified for more dramatic effect
    const interiorLight = new THREE.PointLight(0xffffff, 1.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
     
    const accentColors = [
      new THREE.Color(0x34a853), // Green
      new THREE.Color(0x4285f4), // Blue
      new THREE.Color(0xfbbc05), // Yellow
      new THREE.Color(0xea4335)  // Red
    ];
    
    // Keep only the blue accent light and sphere (index 1)
    const blueIndex = 1;
    const angle = (blueIndex / 4) * Math.PI * 2;
    const dist = size.x * 0.3;
    const x = center.x + Math.cos(angle) * dist;
    const z = center.z + Math.sin(angle) * dist;

    const accentLight = new THREE.PointLight(accentColors[blueIndex], 2.5, size.x * 0.6, 2);
    accentLight.position.set(x, center.y + 1.0, z);
    interiorGroup.add(accentLight);

    // --- Create Kruger Slogans on Walls (keep this from original) ---
    (async () => {
      const slogans = await fetchMCPContent('dev_slogans');
      const wallColor = '#fff';
      const krugerColor = '#e10600';
      // Determine which wall has the door to skip text on that wall
      let doorWall = null;
      const eps = 0.1;
      if (doorPosition) {
        // Define wall positions and axes as in _createSectionWalls
        const halfSizeX = size.x / 2;
        const halfSizeZ = size.z / 2;
        const wallHeight = size.y;
        const wallPositions = [
          { name: 'back',  position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z + halfSizeZ), axis: 'x' },
          { name: 'front', position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z - halfSizeZ), axis: 'x' },
          { name: 'left',  position: new THREE.Vector3(center.x - halfSizeX, center.y + wallHeight / 2, center.z), axis: 'z' },
          { name: 'right', position: new THREE.Vector3(center.x + halfSizeX, center.y + wallHeight / 2, center.z), axis: 'z' }
        ];
        let minDist = Infinity;
        let doorWallName = null;
        wallPositions.forEach((wallData) => {
          const dist = wallData.position.distanceTo(doorPosition);
          if (dist < minDist) {
            minDist = dist;
            doorWallName = wallData.name;
          }
        });
        doorWall = doorWallName;
        console.log('[DEV WALL DETECT] (MATCHED TO GEOMETRY) doorPosition:', doorPosition, 'center:', center, 'size:', size, '=> doorWall:', doorWall);
      }
      // Helper to create a cropped text texture
      function createCroppedKrugerTextTexture(text, cropStart, cropEnd, totalWidth, height, opts) {
        // cropStart and cropEnd are in [0,1] (fraction of totalWidth)
        const canvas = document.createElement('canvas');
        canvas.width = Math.round((cropEnd - cropStart) * totalWidth);
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        // Draw the full text to a temp canvas
        const fullCanvas = document.createElement('canvas');
        fullCanvas.width = totalWidth;
        fullCanvas.height = height;
        const fullCtx = fullCanvas.getContext('2d');
        // Background
        fullCtx.fillStyle = opts.bgColor || '#fff';
        fullCtx.fillRect(0, 0, totalWidth, height);
        // Text
        fullCtx.font = opts.font || 'bold 96px Helvetica Neue, Arial, sans-serif';
        fullCtx.fillStyle = opts.fgColor || '#e10600';
        fullCtx.textAlign = opts.align || 'center';
        fullCtx.textBaseline = opts.vAlign || 'middle';
        // Auto-wrap: split text if too long
        const words = text.split(' ');
        let line = '', lines = [], maxWidth = totalWidth * 0.9;
        for (let w of words) {
          const test = line + w + ' ';
          if (fullCtx.measureText(test).width > maxWidth) {
            lines.push(line);
            line = w + ' ';
          } else {
            line = test;
          }
        }
        lines.push(line);
        const lineHeight = 100;
        const yStart = height/2 - (lines.length-1)*lineHeight/2;
        lines.forEach((l, i) => fullCtx.fillText(l.trim(), totalWidth/2, yStart + i*lineHeight));
        // Copy cropped region to output canvas
        ctx.drawImage(fullCanvas, cropStart*totalWidth, 0, (cropEnd-cropStart)*totalWidth, height, 0, 0, (cropEnd-cropStart)*totalWidth, height);
        return new THREE.CanvasTexture(canvas);
      }
      // Back wall (Z+)
      if (doorWall !== 'back') {
        console.log('[DEV WALL TEXT] Creating full-size back wall mesh');
        const backWall = new THREE.Mesh(
          new THREE.PlaneGeometry(size.x, size.y),
          new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[0], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
        );
        backWall.position.set(center.x, center.y + size.y / 2, center.z + size.z / 2 - 0.05);
        backWall.rotation.y = Math.PI;
        interiorGroup.add(backWall);
      } else {
        // Split the wall mesh into two, leaving a gap for the doorway
        const DOORWAY_WIDTH = 1.8; // Should match the constant used elsewhere
        const wallLen = size.x;
        // Doorway center in world X
        const doorCoord = doorPosition.x;
        const wallCenterCoord = center.x;
        const halfLen = wallLen / 2;
        // Compute left and right segment widths
        const leftLen = Math.max(0, (doorCoord - DOORWAY_WIDTH/2) - (wallCenterCoord - halfLen));
        const rightLen = Math.max(0, (wallCenterCoord + halfLen) - (doorCoord + DOORWAY_WIDTH/2));
        const wallY = center.y + size.y / 2;
        const wallZ = center.z + size.z / 2 - 0.05;
        console.log('[DEV WALL SPLIT] doorWall=back, doorPosition:', doorPosition, 'center:', center, 'leftLen:', leftLen, 'rightLen:', rightLen, 'wallLen:', wallLen);
        // Left segment
        if (leftLen > 0.05) {
          console.log('[DEV WALL SPLIT] Creating left segment with width', leftLen);
          const leftGeom = new THREE.PlaneGeometry(leftLen, size.y);
          const leftTex = createCroppedKrugerTextTexture(slogans[0], 0, leftLen/wallLen, 2048, 512, { bgColor: wallColor, fgColor: krugerColor });
          const leftMat = new THREE.MeshBasicMaterial({ map: leftTex, side: THREE.DoubleSide });
          const leftMesh = new THREE.Mesh(leftGeom, leftMat);
          leftMesh.position.set(wallCenterCoord - halfLen + leftLen/2, wallY, wallZ);
          leftMesh.rotation.y = Math.PI;
          interiorGroup.add(leftMesh);
        } else {
          console.log('[DEV WALL SPLIT] Skipping left segment, width too small:', leftLen);
        }
        // Right segment
        if (rightLen > 0.05) {
          console.log('[DEV WALL SPLIT] Creating right segment with width', rightLen);
          const rightGeom = new THREE.PlaneGeometry(rightLen, size.y);
          const rightTex = createCroppedKrugerTextTexture(slogans[0], 1 - rightLen/wallLen, 1, 2048, 512, { bgColor: wallColor, fgColor: krugerColor });
          const rightMat = new THREE.MeshBasicMaterial({ map: rightTex, side: THREE.DoubleSide });
          const rightMesh = new THREE.Mesh(rightGeom, rightMat);
          rightMesh.position.set(wallCenterCoord + halfLen - rightLen/2, wallY, wallZ);
          rightMesh.rotation.y = Math.PI;
          interiorGroup.add(rightMesh);
        } else {
          console.log('[DEV WALL SPLIT] Skipping right segment, width too small:', rightLen);
        }
      }
      // Front wall (Z-)
      if (doorWall !== 'front') {
        console.log('[DEV WALL TEXT] Creating full-size front wall mesh');
        const frontWall = new THREE.Mesh(
          new THREE.PlaneGeometry(size.x, size.y),
          new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[1], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
        );
        frontWall.position.set(center.x, center.y + size.y / 2, center.z - size.z / 2 + 0.05);
        frontWall.rotation.y = 0;
        interiorGroup.add(frontWall);
      }
      // Left wall (X-)
      if (doorWall !== 'left') {
        console.log('[DEV WALL TEXT] Creating full-size left wall mesh');
        const leftWall = new THREE.Mesh(
          new THREE.PlaneGeometry(size.z, size.y),
          new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[2], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
        );
        leftWall.position.set(center.x - size.x / 2 + 0.05, center.y + size.y / 2, center.z);
        leftWall.rotation.y = Math.PI / 2;
        interiorGroup.add(leftWall);
      }
      // Right wall (X+)
      if (doorWall !== 'right') {
        console.log('[DEV WALL TEXT] Creating full-size right wall mesh');
        const rightWall = new THREE.Mesh(
          new THREE.PlaneGeometry(size.z, size.y),
          new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[3], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
        );
        rightWall.position.set(center.x + size.x / 2 - 0.05, center.y + size.y / 2, center.z);
        rightWall.rotation.y = -Math.PI / 2;
        interiorGroup.add(rightWall);
      }
    })();
    
    // --- Tim Rodenbroeker Style: Create Generative Art Floor ---
    // Floor removed to match Severance aesthetic
    
    // Store reference to floor shader for animation updates
    this._codeRoomFloorShader = null;
    
    // --- Tim Rodenbroeker Style: Create Generative Art Nodes ---
    const createGenerativeNode = (position, nodeType) => {
      const nodeGroup = new THREE.Group();
      nodeGroup.position.copy(position);
      
      // Base parameters
      const nodeRadius = 0.2;
      let nodeColor, emissiveColor, particleCount;
      
      switch (nodeType) {
        case 'flow':
          nodeColor = new THREE.Color(0x4285f4); // Blue
          emissiveColor = new THREE.Color(0x4285f4);
          particleCount = 24;
          break;
        case 'data':
          nodeColor = new THREE.Color(0xfbbc05); // Yellow
          emissiveColor = new THREE.Color(0xfbbc05);
          particleCount = 18;
          break;
        case 'compute':
          nodeColor = new THREE.Color(0xea4335); // Red
          emissiveColor = new THREE.Color(0xea4335);
          particleCount = 12;
          break;
        default:
          nodeColor = new THREE.Color(0x34a853); // Green
          emissiveColor = new THREE.Color(0x34a853);
          particleCount = 6;
      }
      
      // Create core sphere
      const coreGeom = new THREE.SphereGeometry(nodeRadius, 16, 16);
      const coreMat = new THREE.MeshStandardMaterial({
        color: nodeColor,
        emissive: emissiveColor,
        emissiveIntensity: 0.7,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });
      
      const core = new THREE.Mesh(coreGeom, coreMat);
      nodeGroup.add(core);
      
      // Add orbiting particles
      const particleGeom = new THREE.SphereGeometry(nodeRadius * 0.15, 8, 8);
      const particleMat = new THREE.MeshStandardMaterial({
        color: nodeColor,
        emissive: emissiveColor,
        emissiveIntensity: 0.9,
        roughness: 0.1,
        metalness: 0.9
      });
      
      const orbitRadii = [nodeRadius * 2, nodeRadius * 3, nodeRadius * 4];
      
      for (let i = 0; i < particleCount; i++) {
        const particle = new THREE.Mesh(particleGeom, particleMat);
        
        // Determine which orbit
        const orbitIndex = Math.floor(i / (particleCount / orbitRadii.length));
        const orbitRadius = orbitRadii[Math.min(orbitIndex, orbitRadii.length - 1)];
        
        // Position in the orbit
        const angle = (i % (particleCount / orbitRadii.length)) / (particleCount / orbitRadii.length) * Math.PI * 2;
        const x = Math.cos(angle) * orbitRadius;
        const z = Math.sin(angle) * orbitRadius;
        
        // Add some height variation based on angle
        const y = Math.sin(angle * 2) * (orbitRadius * 0.5);
        
        particle.position.set(x, y, z);
        nodeGroup.add(particle);
        
        // Add to animated objects
        const particleId = `node_${nodeType}_particle_${i}`;
        particle.name = particleId;
        
        this._animatedObjects = this._animatedObjects || new Map();
        this._animatedObjects.set(particleId, {
          object: particle,
          centerX: particle.position.x,
          centerZ: particle.position.z,
          radius: orbitRadius,
          speed: 0.6 + (Math.random() * 0.4), // Variable speed
          phase: i * (Math.PI * 2 / particleCount),
          verticalAmplitude: orbitRadius * 0.25,
          verticalFrequency: 1.5 + Math.random()
        });
      }
      
      // Add light
      const nodeLight = new THREE.PointLight(nodeColor, 1.0, nodeRadius * 10, 2);
      nodeGroup.add(nodeLight);
      
      return nodeGroup;
    };
    
    // Create only the blue node (type: 'flow')
    const nodes = [
      { type: 'flow', position: new THREE.Vector3(center.x - size.x * 0.3, center.y + 1.2, center.z - size.z * 0.2) }
    ];
    
    nodes.forEach(node => {
      const nodeGroup = createGenerativeNode(node.position, node.type);
      interiorGroup.add(nodeGroup);
      
      // --- Create Node Info Button ---
      const nodeButtonCanvas = document.createElement('canvas');
      nodeButtonCanvas.width = 320;
      nodeButtonCanvas.height = 100;
      const nodeButtonCtx = nodeButtonCanvas.getContext('2d');
      
      // Style similar to terminal button
      const borderRadius = 8;
      const padding = 10;
      const indicatorSize = 30;
      const indicatorMargin = 15;
      const text = "INFO";
      
      nodeButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      const textMetrics = nodeButtonCtx.measureText(text);
      const textWidth = textMetrics.width;
      const totalWidth = indicatorMargin + indicatorSize + indicatorMargin + textWidth + padding * 2;
      const totalHeight = indicatorSize + padding * 2;
      
      nodeButtonCanvas.width = totalWidth;
      nodeButtonCanvas.height = totalHeight;
      
      // Draw background (dark, semi-transparent)
      nodeButtonCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
      nodeButtonCtx.beginPath();
      nodeButtonCtx.roundRect(0, 0, totalWidth, totalHeight, borderRadius);
      nodeButtonCtx.fill();
      
      // Draw border (teal)
      nodeButtonCtx.strokeStyle = '#5CDED3';
      nodeButtonCtx.lineWidth = 2;
      nodeButtonCtx.stroke();
      
      // Draw Key Indicator background (teal square)
      const indicatorX = padding;
      const indicatorY = padding;
      nodeButtonCtx.fillStyle = '#5CDED3';
      nodeButtonCtx.beginPath();
      nodeButtonCtx.roundRect(indicatorX, indicatorY, indicatorSize, indicatorSize, 4);
      nodeButtonCtx.fill();
      
      // Draw 'E' inside indicator (black)
      nodeButtonCtx.font = 'bold 24px "Neue Montreal", sans-serif';
      nodeButtonCtx.fillStyle = '#000';
      nodeButtonCtx.textAlign = 'center';
      nodeButtonCtx.textBaseline = 'middle';
      nodeButtonCtx.fillText('E', indicatorX + indicatorSize / 2, indicatorY + indicatorSize / 2 + 1);
      
      // Draw Text ("INFO")
      nodeButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      nodeButtonCtx.fillStyle = '#FFFFFF';
      nodeButtonCtx.textAlign = 'left';
      nodeButtonCtx.textBaseline = 'middle';
      nodeButtonCtx.fillText(text, indicatorX + indicatorSize + indicatorMargin, totalHeight / 2 + 1);
      
      // Create button texture and material
      const nodeButtonTex = new THREE.CanvasTexture(nodeButtonCanvas);
      nodeButtonTex.needsUpdate = true;
      nodeButtonTex.minFilter = THREE.LinearFilter;
      nodeButtonTex.magFilter = THREE.LinearFilter;
      const nodeButtonMat = new THREE.MeshBasicMaterial({ map: nodeButtonTex, transparent: true, side: THREE.DoubleSide });
      
      // Create button mesh
      const buttonAspect = nodeButtonCanvas.width / nodeButtonCanvas.height;
      const buttonHeight = 0.22;
      const buttonWidth = buttonHeight * buttonAspect;
      const nodeButtonMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(buttonWidth, buttonHeight),
        nodeButtonMat
      );
      
      // Position button above and in front of the node
      nodeButtonMesh.position.set(
        node.position.x,
        node.position.y + 1.0,
        node.position.z + 0.8
      );
      nodeButtonMesh.rotation.y = 0;
      nodeButtonMesh.renderOrder = 9999;
      nodeButtonMesh.visible = true;
      nodeButtonMesh.name = 'nodeInfoButton';
      interiorGroup.add(nodeButtonMesh);
      
      // Create interaction mesh for the node
      const nodeInteractionGeom = new THREE.BoxGeometry(1.0, 2.0, 1.0);
      const nodeInteractionMat = new THREE.MeshBasicMaterial({ visible: false });
      const nodeInteractionMesh = new THREE.Mesh(nodeInteractionGeom, nodeInteractionMat);
      nodeInteractionMesh.position.copy(node.position);
      nodeInteractionMesh.userData.interactable = true;
      nodeInteractionMesh.userData.isNodeInfo = true;
      nodeInteractionMesh.userData.nodeType = node.type;
      nodeInteractionMesh.userData.link = 'http://parsaa74.github.io/german-art-schools';
      nodeInteractionMesh.userData.infoContent = `This is a ${node.type} node representing the flow of data and algorithms in Tim Rodenbröker's generative art style. This node showcases the intersection of code and creativity, where mathematical operations transform into visual poetry.\n\nClick the link to explore more about computational design and creative coding.`;
      nodeInteractionMesh.name = 'nodeInfoInteraction';
      interiorGroup.add(nodeInteractionMesh);
      
      // Add to node info interactables for getInteractableObjects
      if (!this._nodeInfoInteractables) this._nodeInfoInteractables = [];
      this._nodeInfoInteractables.push(nodeInteractionMesh);
      
      console.log(`Created info button for ${node.type} node at position (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)})`);
    });
    
    // --- Create Interactive Terminal (modified from original) ---
    const terminalWidth = 4.0;
    const terminalHeight = 4.0;
    
    // Create a dynamic canvas for the terminal
    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    
    // --- NEW: Draw terminal window UI ---
    const drawTerminalWindow = (time) => {
      // Background
      ctx.fillStyle = '#1a1a1a'; // Dark background
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      // Border
      ctx.strokeStyle = '#33ff33'; // Bright green border
      ctx.lineWidth = 6; // Thicker border
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
      
      // Title Bar
      const titleBarHeight = 60;
      ctx.fillStyle = '#0d0d0d'; // Slightly darker title bar
      ctx.fillRect(ctx.lineWidth / 2, ctx.lineWidth / 2, canvas.width - ctx.lineWidth, titleBarHeight);
      
      // Title Text
      ctx.font = 'bold 32px "Neue Montreal", monospace';
      ctx.fillStyle = '#33ff33';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('tty0', canvas.width / 2, titleBarHeight / 2 + 5); // Changed "TERMINAL" to "tty0"
          
      // Control Buttons (simple circles)
      const buttonRadius = 12;
      const buttonY = titleBarHeight / 2 + 5;
      const buttonSpacing = 40;
      // Close (red)
      ctx.fillStyle = '#ff5f57';
          ctx.beginPath();
      ctx.arc(buttonSpacing, buttonY, buttonRadius, 0, Math.PI * 2);
          ctx.fill();
      // Minimize (yellow)
      ctx.fillStyle = '#febc2e';
                ctx.beginPath();
      ctx.arc(buttonSpacing * 2, buttonY, buttonRadius, 0, Math.PI * 2);
      ctx.fill();
      // Maximize (green)
      ctx.fillStyle = '#28cd41';
      ctx.beginPath();
      ctx.arc(buttonSpacing * 3, buttonY, buttonRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Terminal Content Area
      const contentStartY = titleBarHeight + ctx.lineWidth / 2 + 20;
      const contentPadding = 40;
      
      // Existing code-like text overlay (adjusted position)
      ctx.font = '18px "JetBrains Mono", monospace'; // Slightly larger font
      ctx.fillStyle = '#33ff33';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top'; // Align text to top of line
      
      const timeOffset = Math.floor(time * 3) % 10;
      const codeLines = [ // Updated content for a more "suckless" feel
        `[${(time*1000).toFixed(0)}] boot_params: ro quiet splash`,
        `[${(time*1000+15).toFixed(0)}] kernel: microcode: updated early to revision 0x01`,
        `[${(time*1000+40).toFixed(0)}] systemd[1]: Starting basic system...`,
        `[${(time*1000+55).toFixed(0)}] /dev/kvm: KVM configured`,
        `--------------------------------------------------`,
        `  #!/bin/sh`,
        `  # simple.sh - a truly minimal script`,
        `  while true; do`,
        `    echo "dwm rocks" > /dev/null`,
        `    sleep 0.1`,
        `  done`,
        `--------------------------------------------------`,
        `[${(time*1000+100).toFixed(0)}] Console: switching to colour frame buffer...`,
        `login:`
      ];
      
      let y = contentStartY;
      codeLines.forEach(line => {
        if (y < canvas.height - ctx.lineWidth - 20) { // Prevent overflow
          ctx.fillText(line, contentPadding, y);
          y += 26; // Line height
        }
      });
    
      // Blinking cursor (optional)
      if (Math.floor(time * 2) % 2 === 0) {
        ctx.fillStyle = '#33ff33';
        ctx.fillRect(contentPadding, y, 10, 20); // Draw cursor
      }
    };
    
    // Initial draw using the new function
    drawTerminalWindow(performance.now() * 0.001);
    // --- END NEW UI DRAWING ---
    
    // Create terminal material with the canvas texture
    const screenTexture = new THREE.CanvasTexture(canvas);
    
    const terminalMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: screenTexture,
      emissive: 0xffffff,
      emissiveMap: screenTexture,
      emissiveIntensity: 0.7,
      metalness: 0.3,
      roughness: 0.4,
      transparent: true
    });
    
    // Rounded rectangle frame (same as original)
    const frameThickness = 0.08;
    const frameRadius = 0.12;
    // Use a rounded rectangle shape for the frame
    const shape = new THREE.Shape();
    const w = terminalWidth + frameThickness;
    const h = terminalHeight + frameThickness;
    shape.absarc(-w/2 + frameRadius, -h/2 + frameRadius, frameRadius, Math.PI, Math.PI/2, true);
    shape.absarc(w/2 - frameRadius, -h/2 + frameRadius, frameRadius, Math.PI/2, 0, true);
    shape.absarc(w/2 - frameRadius, h/2 - frameRadius, frameRadius, 0, -Math.PI/2, true);
    shape.absarc(-w/2 + frameRadius, h/2 - frameRadius, frameRadius, -Math.PI/2, -Math.PI, true);
    const extrudeSettings = { depth: 0.08, bevelEnabled: false };
    const frameGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x22262a,
      metalness: 0.7,
      roughness: 0.25,
      emissive: 0x0a0a1a,
      emissiveIntensity: 0.2
    });
    
//     // Create the terminal screen
    const terminal = new THREE.Mesh(
      new THREE.PlaneGeometry(terminalWidth, terminalHeight),
      terminalMaterial
    );
    terminal.position.set(center.x - size.x/2 + 0.14, center.y + 1.2, center.z);
    terminal.rotation.y = Math.PI/2;
    terminal.name = 'dev_terminal';
    interiorGroup.add(terminal);
    
    // Set up animation for the terminal screen
    this._terminalCanvas = canvas;
    this._terminalTexture = screenTexture;
    this._terminalLastUpdate = performance.now();
    this._terminalUpdateInterval = 500; // Update every 500ms for performance
    this._terminalDrawFunction = drawTerminalWindow; // Store drawing function
    
    // Add floating E button in front of the screen, at the same height (unchanged)
    // --- NEW: Update E button appearance ---
    const eButtonCanvas = document.createElement('canvas');
    // Adjust canvas size for potentially wider button
    eButtonCanvas.width = 320; // Keep width
    eButtonCanvas.height = 100; // Reduce height slightly
    const eButtonCtx = eButtonCanvas.getContext('2d');
    
    // Style similar to door interaction prompt
    const borderRadius = 8;
    const padding = 10;
    const indicatorSize = 30;
    const indicatorMargin = 15;
    const text = "INTERACT";
    
    eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif'; // Match prompt font if possible
    const textMetrics = eButtonCtx.measureText(text);
    const textWidth = textMetrics.width;
    const totalWidth = indicatorMargin + indicatorSize + indicatorMargin + textWidth + padding * 2;
    const totalHeight = indicatorSize + padding * 2;
    
    // Readjust canvas size based on content
    eButtonCanvas.width = totalWidth;
    eButtonCanvas.height = totalHeight;
    
    // Draw background (dark, semi-transparent)
    eButtonCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
    eButtonCtx.beginPath();
    eButtonCtx.roundRect(0, 0, totalWidth, totalHeight, borderRadius);
    eButtonCtx.fill();
    
    // Draw border (teal)
    eButtonCtx.strokeStyle = '#5CDED3';
    eButtonCtx.lineWidth = 2;
    eButtonCtx.stroke();
    
    // Draw Key Indicator background (teal square)
    const indicatorX = padding;
    const indicatorY = padding;
    eButtonCtx.fillStyle = '#5CDED3';
    eButtonCtx.beginPath();
    eButtonCtx.roundRect(indicatorX, indicatorY, indicatorSize, indicatorSize, 4); // Slightly rounded square
    eButtonCtx.fill();
    
    // Draw 'E' inside indicator (black)
    eButtonCtx.font = 'bold 24px "Neue Montreal", sans-serif';
    eButtonCtx.fillStyle = '#000';
    eButtonCtx.textAlign = 'center';
    eButtonCtx.textBaseline = 'middle';
    eButtonCtx.fillText('E', indicatorX + indicatorSize / 2, indicatorY + indicatorSize / 2 + 1); // Adjust baseline slightly
    
    // Draw Text ("INTERACT")
    eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
    eButtonCtx.fillStyle = '#FFFFFF'; // White text
    eButtonCtx.textAlign = 'left';
    eButtonCtx.textBaseline = 'middle';
    eButtonCtx.fillText(text, indicatorX + indicatorSize + indicatorMargin, totalHeight / 2 + 1);
    
    // --- END: Update E button appearance ---
    
    const eButtonTex = new THREE.CanvasTexture(eButtonCanvas);
    eButtonTex.needsUpdate = true;
    eButtonTex.minFilter = THREE.LinearFilter;
    eButtonTex.magFilter = THREE.LinearFilter;
    const eButtonMat = new THREE.MeshBasicMaterial({ map: eButtonTex, transparent: true, side: THREE.DoubleSide });
    // Adjust plane geometry aspect ratio to match new canvas
    const buttonAspect = eButtonCanvas.width / eButtonCanvas.height;
    const buttonHeight = 0.22; // Keep height relatively small
    const buttonWidth = buttonHeight * buttonAspect;
    const eButtonMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(buttonWidth, buttonHeight),
      eButtonMat
    );
    eButtonMesh.position.set(terminal.position.x + 0.4, terminal.position.y, terminal.position.z);
    eButtonMesh.rotation.y = Math.PI/2;
    eButtonMesh.name = 'dev_terminal_ebutton';
    eButtonMesh.visible = true; // TEMP: Always visible for debug
    interiorGroup.add(eButtonMesh);
    
    // Create invisible interaction volume for terminal (no changes to original)
    const terminalInteractionGeom = new THREE.BoxGeometry(1.0, 2.0, 2.0);
    const terminalInteractionMat = new THREE.MeshBasicMaterial({ visible: false });
    const terminalInteractionMesh = new THREE.Mesh(terminalInteractionGeom, terminalInteractionMat);
    terminalInteractionMesh.position.set(center.x - size.x/2 + 0.4, center.y + 1.2, center.z);
    terminalInteractionMesh.userData.interactable = true;
    terminalInteractionMesh.userData.isDevTerminal = true;
    terminalInteractionMesh.name = 'dev_terminal_interaction';
    interiorGroup.add(terminalInteractionMesh);
    
    // Register for interaction and proximity logic
    if (!this._devTerminalInteractable) this._devTerminalInteractable = [];
    this._devTerminalInteractable.push({ mesh: terminal, eButton: eButtonMesh, interactionMesh: terminalInteractionMesh });
  }

  /** Creates interior for Film & Cinematography section. */
  async _createFilmInterior(interiorGroup, center, size, doorPosition) {
    console.log("[DEBUG FILM INTERIOR] Entered _createFilmInterior"); // <<< ADDED
    console.log("[DEBUG FILM INTERIOR] interiorGroup name:", interiorGroup.name); // <<< ADDED
    console.log(`Creating FILM interior at ${center.x}, ${center.z}`);
    
    // --- Special lighting at door entrance, similar to Design interior ---
    if (doorPosition) {
      // Create vector from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Create a special warm amber light (matching film color theme) at the entryway
      const entryLight = new THREE.SpotLight(0xfbbc05, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0))); // Above the door
      
      // Point the spotlight into the room
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // --- Only add: GLTF chairs, lamps, screen, curtain, speakers, projector ---

    const loader = new GLTFLoader();
    const textureLoader = new TextureLoader(); // Create texture loader for posters
    
    // Load chair.gltf
    const chairGltf = await new Promise((resolve, reject) => {
      loader.load('/chair.glb', resolve, undefined, reject);
    });
    // Load lamp.gltf
    const lampGltf = await new Promise((resolve, reject) => {
      loader.load('/lamp.glb', resolve, undefined, reject);
    });
    // Load projector.glb
    const projectorGltf = await new Promise((resolve, reject) => {
      loader.load('/projector.glb', resolve, undefined, reject);
    });
    const projectorScreenGltf = await new Promise((resolve, reject) => {
      loader.load('/projector_screen.glb', resolve, undefined, reject);
    });
    
    // Load poster textures
    const poster1Texture = await textureLoader.loadAsync('/assets/textures/posters/poster1.jpg');
    // const poster2Texture = await textureLoader.loadAsync('/assets/textures/posters/Severance_Photo_0201.jpg');

    const chairMesh = chairGltf.scene;
    const lampMesh = lampGltf.scene;
    const projectorMesh = projectorGltf.scene;
    chairMesh.scale.set(1, 1, 1); // Adjust if needed
    lampMesh.scale.set(1, 1, 1); // Adjust if needed
    projectorMesh.scale.set(1, 1, 1); // Adjust if needed

    // --- Apply custom light shader to lamp bulb ---
    // Find the bulb mesh in lampMesh (by name or material)
    let bulbMeshes = [];
    lampMesh.traverse((child) => {
      if (child.isMesh && (child.name.toLowerCase().includes('bulb') || child.name.toLowerCase().includes('light'))) {
        bulbMeshes.push(child);
      }
    });
    if (bulbMeshes.length === 0) {
      // Try fallback: find mesh with high white/emissive material
      lampMesh.traverse((child) => {
        if (child.isMesh && child.material && child.material.emissive && child.material.emissive.getHex() === 0xffffff) {
          bulbMeshes.push(child);
        }
      });
    }
    if (bulbMeshes.length === 0) {
      console.warn('[Lamp Shader] No bulb mesh found in lamp.glb. No shader applied.');
    } else {
      const lampShaderMat = createLampLightShaderMaterial();
      bulbMeshes.forEach(bulb => {
        bulb.material = lampShaderMat;
        bulb.material.needsUpdate = true;
      });
    }

    // --- Place four GLTF chairs in a gentle arc facing the screen wall (assume screen is on +Z wall) ---
    const chairPositions = [
      { x: center.x - 1.2, z: center.z + 1.2, rot: 0.08 },
      { x: center.x - 0.4, z: center.z + 1.4, rot: 0.03 },
      { x: center.x + 0.4, z: center.z + 1.4, rot: -0.03 },
      { x: center.x + 1.2, z: center.z + 1.2, rot: -0.08 },
    ];
    for (let i = 0; i < 4; i++) {
      const chair = chairMesh.clone(true);
      chair.position.set(chairPositions[i].x, center.y, chairPositions[i].z);
      chair.rotation.y = chairPositions[i].rot;
      chair.position.y = center.y;
      interiorGroup.add(chair);
    }

    // --- Place projector.glb at a realistic position and scale ---
    const projectorScale = 0.4;
    projectorMesh.scale.set(projectorScale, projectorScale, projectorScale);
    const projectorY = center.y + 2.2;
    const projectorZ = center.z + size.z / 2 - 3.0;
    projectorMesh.position.set(center.x, projectorY, projectorZ);
    projectorMesh.rotation.set(-Math.PI / 16, 0, 0);
    interiorGroup.add(projectorMesh);

    // --- Add projector_screen.glb (realistic pull-down screen) ---
    const screen = projectorScreenGltf.scene;
    // Dynamically size and position the screen to fit the room and maintain aspect ratio
    const screenAspect = 16 / 9;
    const marginX = 0.5; // meters from each side wall
    const marginTop = 0.4; // meters from ceiling
    const marginBottom = 0.5; // Reset to previous value for size calculation
    const maxWidth = size.x - 2 * marginX;
    const maxHeight = size.y - marginTop - marginBottom;
    // Compute width and height that fit the aspect ratio and room
    let screenWidth = maxWidth;
    let screenHeight = screenWidth / screenAspect;
    if (screenHeight > maxHeight) {
      screenHeight = maxHeight;
      screenWidth = screenHeight * screenAspect;
    }
    // Scale the screen (reduced by 20% from previous 3x)
    screenWidth *= 2.4; // Reduced from 3 to 2.4 (20% smaller)
    screenHeight *= 2.4; // Reduced from 3 to 2.4 (20% smaller)
    // The GLB's native size (from Blender) is 6.4 x 3.6 meters
    const nativeWidth = 6.4;
    const nativeHeight = 3.6;
    const scaleX = screenWidth / nativeWidth;
    const scaleY = screenHeight / nativeHeight;
    // Use uniform scale for X and Y (Z can match X)
    const scale = Math.min(scaleX, scaleY);
    screen.scale.set(scale, scale, scale);
    // Position: flush with +Z wall, centered horizontally, BOTTOM just above the floor
    const screenZ = center.z + size.z / 2 - 0.08; // 8cm from wall
    // Correct floor Y calculation and add height offset
    const floorY = center.y - size.y / 2;
    const heightOffset = 1.5; // Raise screen by 1 meter from base position
    const screenY = floorY + marginBottom + heightOffset; // Add heightOffset to raise the screen
    screen.position.set(center.x, screenY, screenZ);
    screen.rotation.y = 0; // Facing -Z (into the room)
    interiorGroup.add(screen);
    // --- Place four lamp.glb in the four corners, each with a point light ---
    const margin = 0.45;
    const lampCorners = [
      { x: center.x - size.x / 2 + margin, z: center.z - size.z / 2 + margin },
      { x: center.x + size.x / 2 - margin, z: center.z - size.z / 2 + margin },
      { x: center.x - size.x / 2 + margin, z: center.z + size.z / 2 - margin },
      { x: center.x + size.x / 2 - margin, z: center.z + size.z / 2 - margin },
    ];
    for (let i = 0; i < 4; i++) {
      const lamp = lampMesh.clone(true);
      lamp.position.set(lampCorners[i].x, center.y, lampCorners[i].z);
      interiorGroup.add(lamp);
      // Add a point light at the bulb position (try to find bulb in this lamp instance)
      let bulbPos = null;
      lamp.traverse((child) => {
        if (child.isMesh && (child.name.toLowerCase().includes('bulb') || child.name.toLowerCase().includes('light'))) {
          bulbPos = child.getWorldPosition(new THREE.Vector3());
        }
      });
      // If not found, use lamp's position
      if (!bulbPos) bulbPos = lamp.position.clone();
      const lampLight = new THREE.PointLight(0xffffcc, 2.0, 5.0, 1.0);
      lampLight.position.copy(bulbPos);
      interiorGroup.add(lampLight);
    }

    // --- Add two framed film posters on the wall ---
    const createFramedPoster = (posterTexture, position, rotation) => {
      // Create poster group
      const posterGroup = new THREE.Group();
      
      // Get the aspect ratio from the texture
      const imageAspect = posterTexture.image ? 
        posterTexture.image.width / posterTexture.image.height : 
        0.75; // Default aspect ratio if image data isn't available yet
      
      // Create frame with proper aspect ratio
      const frameHeight = 1.4;
      const frameWidth = frameHeight * imageAspect;
      const frameDepth = 0.04;
      const frameBorderSize = 0.05;
      
      // Frame material - matte black, matching Severance aesthetic
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.8,
        metalness: 0.2
      });
      
      // Poster material with texture
      const posterMaterial = new THREE.MeshStandardMaterial({
        map: posterTexture,
        roughness: 0.6,
        metalness: 0.0
      });
      
      // Create outer frame
      const outerFrameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const outerFrame = new THREE.Mesh(outerFrameGeometry, frameMaterial);
      posterGroup.add(outerFrame);
      
      // Create inner poster (slightly smaller and in front of frame)
      const posterWidth = frameWidth - (frameBorderSize * 2);
      const posterHeight = frameHeight - (frameBorderSize * 2);
      const posterGeometry = new THREE.PlaneGeometry(posterWidth, posterHeight);
      const poster = new THREE.Mesh(posterGeometry, posterMaterial);
      poster.position.z = frameDepth / 2 + 0.001; // Place slightly in front of frame
      posterGroup.add(poster);
      
      // Add subtle matboard/matte between frame and poster
      const matteWidth = frameWidth - frameBorderSize * 0.8;
      const matteHeight = frameHeight - frameBorderSize * 0.8;
      const matteGeometry = new THREE.PlaneGeometry(matteWidth, matteHeight);
      const matteMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        roughness: 0.9,
        metalness: 0.0
      });
      const matte = new THREE.Mesh(matteGeometry, matteMaterial);
      matte.position.z = frameDepth / 2 + 0.0005; // Between frame and poster
      posterGroup.add(matte);
      
      // Add glass in front (slight reflection)
      const glassGeometry = new THREE.PlaneGeometry(frameWidth - frameBorderSize * 0.3, frameHeight - frameBorderSize * 0.3);
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0.05,
        metalness: 0.0,
        transmission: 0.98,
        transparent: true,
        opacity: 0.1,
        reflectivity: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
      });
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.z = frameDepth / 2 + 0.002; // In front of everything
      posterGroup.add(glass);
      
      // Set position and rotation
      posterGroup.position.copy(position);
      posterGroup.rotation.set(rotation.x, rotation.y, rotation.z);
      
      return posterGroup;
    };
    
    // --- Helper to create an interactable mesh and button ---
    function addWatchInteractionToFrame(frameGroup, position, link, filmTitle, filmYear, filmCast, filmRole, filmSummary, interiorGroup) {
      // Create an invisible box for interaction
      const interactGeom = new THREE.BoxGeometry(1.3, 1.6, 0.2); // Slightly larger than frame
      // Make interaction mesh invisible (no debugging needed in production)
      const interactMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, visible: false });
      const interactMesh = new THREE.Mesh(interactGeom, interactMat);

      // --- DEBUG: Log poster and interiorGroup info ---
      console.log(`[AWIF DEBUG] Poster Position (world): (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
      console.log(`[AWIF DEBUG] Called for interiorGroup: ${interiorGroup.name}`);

      // Position the interaction mesh at the frame origin (local coordinates)
      interactMesh.position.set(0, 0, 0);
      // Extract the orientation from the frame group's rotation
      const frameRotation = frameGroup.rotation.clone();
      const normalVector = new THREE.Vector3(0, 0, 1).applyEuler(frameRotation);
      // Offset in the direction the frame is facing
      interactMesh.position.add(normalVector.clone().multiplyScalar(0.25));
      // Store frame data
      interactMesh.userData.isWatchInteractable = true;
      interactMesh.userData.interactable = true; // Consistent with doors
      interactMesh.userData.watchLink = link;
      interactMesh.userData.filmTitle = filmTitle;
      interactMesh.userData.filmYear = filmYear;
      interactMesh.userData.filmCast = filmCast;
      interactMesh.userData.filmRole = filmRole;
      interactMesh.userData.filmSummary = filmSummary;
      interactMesh.userData.frameRotation = frameRotation;
      // --- Add floating 3D 'E' button mesh - Updated Style ---
      const eButtonCanvas = document.createElement('canvas');
      eButtonCanvas.width = 320; 
      eButtonCanvas.height = 100;
      const eButtonCtx = eButtonCanvas.getContext('2d');
      const borderRadius = 8;
      const padding = 10;
      const indicatorSize = 30;
      const indicatorMargin = 15;
      const text = "INTERACT";
      eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      const textMetrics = eButtonCtx.measureText(text);
      const textWidth = textMetrics.width;
      const totalWidth = indicatorMargin + indicatorSize + indicatorMargin + textWidth + padding * 2;
      const totalHeight = indicatorSize + padding * 2;
      eButtonCanvas.width = totalWidth;
      eButtonCanvas.height = totalHeight;
      eButtonCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
      eButtonCtx.beginPath();
      eButtonCtx.roundRect(0, 0, totalWidth, totalHeight, borderRadius);
      eButtonCtx.fill();
      eButtonCtx.strokeStyle = '#5CDED3';
      eButtonCtx.lineWidth = 2;
      eButtonCtx.stroke();
      const indicatorX = padding;
      const indicatorY = padding;
      eButtonCtx.fillStyle = '#5CDED3';
      eButtonCtx.beginPath();
      eButtonCtx.roundRect(indicatorX, indicatorY, indicatorSize, indicatorSize, 4);
      eButtonCtx.fill();
      eButtonCtx.font = 'bold 24px "Neue Montreal", sans-serif';
      eButtonCtx.fillStyle = '#000';
      eButtonCtx.textAlign = 'center';
      eButtonCtx.textBaseline = 'middle';
      eButtonCtx.fillText('E', indicatorX + indicatorSize / 2, indicatorY + indicatorSize / 2 + 1);
      eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      eButtonCtx.fillStyle = '#FFFFFF';
      eButtonCtx.textAlign = 'left';
      eButtonCtx.textBaseline = 'middle';
      eButtonCtx.fillText(text, indicatorX + indicatorSize + indicatorMargin, totalHeight / 2 + 1);
      
      const eButtonTex = new THREE.CanvasTexture(eButtonCanvas);
      eButtonTex.needsUpdate = true;
      eButtonTex.minFilter = THREE.LinearFilter;
      eButtonTex.magFilter = THREE.LinearFilter;
      const eButtonMat = new THREE.MeshBasicMaterial({ map: eButtonTex, transparent: true, side: THREE.DoubleSide });

      const buttonAspect = eButtonCanvas.width / eButtonCanvas.height;
      const buttonHeight = 0.22;
      const buttonWidth = buttonHeight * buttonAspect;
      const buttonMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(buttonWidth, buttonHeight),
        eButtonMat
      );
      // Calculate world position for the button (above and in front of the poster)
      const upVector = new THREE.Vector3(0, 1, 0);
      const rightVector = new THREE.Vector3().crossVectors(normalVector, upVector).normalize();
      const adjustedUpVector = new THREE.Vector3().crossVectors(rightVector, normalVector).normalize();
      // World position: start at poster position, move up and out
      const buttonWorldPos = position.clone();
      buttonWorldPos.add(adjustedUpVector.clone().multiplyScalar(0.9)); // Move up
      buttonWorldPos.add(normalVector.clone().multiplyScalar(1.5)); // Move out from frame - DEBUG INCREASED OFFSET
      buttonMesh.position.copy(buttonWorldPos);
      // Set rotation to match poster's facing direction
      const lookAtMatrix = new THREE.Matrix4();
      lookAtMatrix.lookAt(
        new THREE.Vector3(0, 0, 0),
        normalVector,
        adjustedUpVector
      );
      buttonMesh.setRotationFromMatrix(lookAtMatrix);
      buttonMesh.renderOrder = 9999;
      buttonMesh.visible = true;
      buttonMesh.name = 'posterEButton';
      // Add button directly to the interiorGroup
      interiorGroup.add(buttonMesh);
      // --- DEBUG: Log button's parent ---
      console.log(`[AWIF DEBUG] Added button to parent: ${buttonMesh.parent ? buttonMesh.parent.name : 'null'}, Expected parent: ${interiorGroup.name}`);
      // Store reference for later
      interactMesh.userData.eButtonMesh = buttonMesh;
      // Add to frame group for interaction
      frameGroup.add(interactMesh);
      if (!frameGroup.userData.interactables) frameGroup.userData.interactables = [];
      frameGroup.userData.interactables.push(interactMesh);
      return interactMesh;
    }

    // First poster - left wall, closer to the screen
    const poster1Position = new THREE.Vector3(
      center.x - size.x / 2 + 0.1, // Left wall
      center.y + 1.5, // Eye level
      center.z + size.z / 2 - 2.0 // Near the screen
    );
    const poster1Rotation = new THREE.Vector3(0, Math.PI / 2, 0);
    const framedPoster1 = createFramedPoster(poster1Texture, poster1Position, poster1Rotation);
    interiorGroup.add(framedPoster1);
    // Add interaction mesh and button to first poster
    console.log("[DEBUG FILM INTERIOR] About to call addWatchInteractionToFrame for poster1"); // <<< ADDED
    const poster1Interact = addWatchInteractionToFrame(
      framedPoster1, poster1Position,
      'https://your-link-here',
      '38:01',
      '2017',
      'parsa azari',
      'actor',
      'A solitary watchmaker, tormented by every sound, becomes obsessed with a silent stranger in his shop, spiraling into a surreal inner crisis that reaches a startling, self-inflicted climax.',
      interiorGroup
    );

    // --- Collage frame helper ---
    function createFramedCollage(textures, position, rotation) {
      // Collage config
      const n = textures.length;
      let gridRows = 1, gridCols = n;
      if (n === 4) { gridRows = 2; gridCols = 2; }
      else if (n === 3) { gridRows = 1; gridCols = 3; }
      else if (n === 2) { gridRows = 1; gridCols = 2; }
      // Frame size
      const frameHeight = 1.4;
      const frameWidth = frameHeight * gridCols / gridRows;
      const frameDepth = 0.04;
      const frameBorderSize = 0.05;
      // Frame
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111, roughness: 0.8, metalness: 0.2
      });
      const outerFrameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const outerFrame = new THREE.Mesh(outerFrameGeometry, frameMaterial);
      // Matboard
      const matteWidth = frameWidth - frameBorderSize * 0.8;
      const matteHeight = frameHeight - frameBorderSize * 0.8;
      const matteGeometry = new THREE.PlaneGeometry(matteWidth, matteHeight);
      const matteMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee, roughness: 0.9, metalness: 0.0
      });
      const matte = new THREE.Mesh(matteGeometry, matteMaterial);
      matte.position.z = frameDepth / 2 + 0.0005;
      // Glass
      const glassGeometry = new THREE.PlaneGeometry(frameWidth - frameBorderSize * 0.3, frameHeight - frameBorderSize * 0.3);
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, roughness: 0.05, metalness: 0.0, transmission: 0.98,
        transparent: true, opacity: 0.1, reflectivity: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.1
      });
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.z = frameDepth / 2 + 0.002;
      // Collage group
      const group = new THREE.Group();
      group.add(outerFrame);
      group.add(matte);
      // Add images in grid
      const cellW = (matteWidth - 0.04) / gridCols;
      const cellH = (matteHeight - 0.04) / gridRows;
      for (let i = 0; i < n; i++) {
        const row = Math.floor(i / gridCols);
        const col = i % gridCols;
        const x = -matteWidth/2 + cellW/2 + col*cellW;
        const y = matteHeight/2 - cellH/2 - row*cellH;
        const imgGeom = new THREE.PlaneGeometry(cellW*0.95, cellH*0.95);
        const imgMat = new THREE.MeshStandardMaterial({ map: textures[i], roughness: 0.6, metalness: 0.0 });
        const img = new THREE.Mesh(imgGeom, imgMat);
        img.position.set(x, y, frameDepth/2 + 0.001);
        group.add(img);
      }
      group.add(glass);
      group.position.copy(position);
      group.rotation.set(rotation.x, rotation.y, rotation.z);
      return group;
    }

    // Film stills for the second film (collage)
    const stillFilenames = [
      'poster2(1).jpg',
      'poster2(2).jpg',
      'poster2(3).jpg',
      'poster2(4).jpg'
    ];
    const stillBasePath = '/assets/textures/posters/';
    const stillRotation = new THREE.Vector3(0, Math.PI / 2, 0);
    const collagePosition = new THREE.Vector3(
      center.x - size.x / 2 + 0.1,
      center.y + 1.5,
      center.z + size.z / 2 - 4.5 // Place further from the screen
    );
    // Load all still textures asynchronously
    const stillTextures = await Promise.all(
      stillFilenames.map(filename => textureLoader.loadAsync(stillBasePath + filename))
    );
    const collage = createFramedCollage(stillTextures, collagePosition, stillRotation);
    interiorGroup.add(collage);
    // Add interaction mesh and button to collage
    console.log("[DEBUG FILM INTERIOR] About to call addWatchInteractionToFrame for collage"); // <<< ADDED
    const collageInteract = addWatchInteractionToFrame(
      collage, collagePosition,
      'https://youtu.be/PuEuzuM9Mig?si=jDVdbPAFdwopsvJ6',
      'The one who dances on your grave',
      '2019',
      'nastaran moradi',
      'cinematographer',
      'In a society of systematic erasure, Nastaran navigates her increasing invisibility. Poetic vignettes follow her through daily existence as economic pressures and patriarchal structures intensify around her.',
      interiorGroup
    );
    // Add a spotlight above the collage
    const collageSpotPos = collagePosition.clone();
    collageSpotPos.x += 0.5;
    collageSpotPos.y += 0.8;
    // createPosterSpotlight(collageSpotPos, collagePosition); // Disabled: function not defined

    // --- Add to interactables ---
    if (!this._customWatchInteractables) this._customWatchInteractables = [];
    this._customWatchInteractables.push(poster1Interact, collageInteract);
    console.log('[DEBUG] _customWatchInteractables after push:', this._customWatchInteractables);
    console.log('[DEBUG] Number of poster interactables:', this._customWatchInteractables.length);

    // Spotlights for each poster
    const poster1SpotPosition = poster1Position.clone();
    poster1SpotPosition.x += 0.5;
    poster1SpotPosition.y += 0.8;
    // createPosterSpotlight(poster1SpotPosition, poster1Position); // Disabled: function not defined

    const poster2SpotPosition = collagePosition.clone();
    poster2SpotPosition.x += 0.5;
    poster2SpotPosition.y += 0.8;
    // createPosterSpotlight(poster2SpotPosition, collagePosition); // Disabled: function not defined
    
    // All other 3D elements (screen, curtain, speakers, primitives, lights) are removed for minimalism.
    // DEBUG: Force visible test button at center of room
    // const debugButtonGeom = new THREE.PlaneGeometry(1, 0.5);
    // const debugButtonMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
    // const debugButtonMesh = new THREE.Mesh(debugButtonGeom, debugButtonMat);
    // debugButtonMesh.position.set(0, 2, 0); // Center of room, 2m above floor
    // debugButtonMesh.renderOrder = 9999;
    // debugButtonMesh.visible = true;
    // debugButtonMesh.name = 'posterEButton_DEBUG';
    // interiorGroup.add(debugButtonMesh);
    // console.log('[DEBUG] Added forced debug button at (0,2,0)', debugButtonMesh);

    // --- Add Favorite Films Gallery on Right Wall ---
    console.log("[DEBUG FILM INTERIOR] Creating favorite films gallery on right wall");
    
    // Define the favorite films from the attached folder with TMDB links
    const favoriteFilms = [
      { filename: 'mulholland-drive.jpg', title: 'Mulholland Drive', director: 'David Lynch', year: '2001', link: 'https://www.themoviedb.org/movie/1018-mulholland-drive' },
      { filename: 'Morvern-Callar.jpg', title: 'Morvern Callar', director: 'Lynne Ramsay', year: '2002', link: 'https://www.themoviedb.org/movie/18602-morvern-callar' },
      { filename: 'Still-life.jpg', title: 'Still Life', director: 'Jia Zhangke', year: '2006', link: 'https://www.themoviedb.org/movie/213592' },
      { filename: 'what-time-is-it-there.jpg', title: 'What Time Is It There?', director: 'Tsai Ming-liang', year: '2001', link: 'https://www.themoviedb.org/movie/24166' },
      { filename: 'Wendy-and-Lucy.jpg', title: 'Wendy and Lucy', director: 'Kelly Reichardt', year: '2008', link: 'https://www.themoviedb.org/movie/8942-wendy-and-lucy' },
      { filename: 'Scenes-from-a-Marriage.jpg', title: 'Scenes from a Marriage', director: 'Ingmar Bergman', year: '1973', link: 'https://www.themoviedb.org/tv/65170-scener-ur-ett-ktenskap' },
      { filename: 'In-einem-Jahr-mit-13-Monden.webp', title: 'In a Year with 13 Moons', director: 'Rainer Werner Fassbinder', year: '1978', link: 'https://www.themoviedb.org/movie/42206-in-einem-jahr-mit-13-monden' },
      { filename: 'A-Man-Escaped.jpg', title: 'A Man Escaped', director: 'Robert Bresson', year: '1956', link: 'https://www.themoviedb.org/movie/15244-un-condamne-a-mort-s-est-echappe' },
      { filename: 'Old-Joy.webp', title: 'Old Joy', director: 'Kelly Reichardt', year: '2006', link: 'https://www.themoviedb.org/movie/26518-old-joy' }
    ];
    
    // Load all favorite film textures
    const favoriteFilmTextures = await Promise.all(
      favoriteFilms.map(film => textureLoader.loadAsync(`/assets/images/film/favorite films/${film.filename}`))
    );
    
    // Define right wall position and rotation for gallery
    const rightWallX = center.x + size.x / 2 - 0.1; // Right wall position
    const rightWallRotation = new THREE.Vector3(0, -Math.PI / 2, 0); // Face into room from right wall
    
    // Row layout parameters - single horizontal row
    const totalFilms = favoriteFilms.length; // 9 films
    const wallDepth = size.z; // Total depth of the room
    const availableWallSpace = wallDepth * 0.8; // Use 80% of wall space for distribution
    const spacingBetweenFrames = availableWallSpace / (totalFilms - 1); // Even distribution
    
    // Calculate starting position - lower height, centered on wall
    const rowY = center.y + 1.2; // Brought down from 2.8 to 1.2 (more eye level)
    const startZ = center.z - (wallDepth * 0.4); // Start from one end of the usable wall space
    
    // Create frames for each favorite film in a single row
    for (let i = 0; i < favoriteFilms.length; i++) {
      const x = rightWallX;
      const y = rowY; // Same height for all (single row)
      const z = startZ + (i * spacingBetweenFrames); // Evenly distributed along wall
      const position = new THREE.Vector3(x, y, z);
      
      const frame = createFramedPoster(favoriteFilmTextures[i], position, rightWallRotation);
      interiorGroup.add(frame);
      
      // Add interaction mesh and button to frame
      const interact = addWatchInteractionToFrame(
        frame, position,
        favoriteFilms[i].link, // TMDB link for each film
        favoriteFilms[i].title,
        favoriteFilms[i].year,
        favoriteFilms[i].director,
        'Director',
        `${favoriteFilms[i].title} (${favoriteFilms[i].year}) directed by ${favoriteFilms[i].director}`,
        interiorGroup
      );
      
      // Add to interactables
      if (!this._customWatchInteractables) this._customWatchInteractables = [];
      this._customWatchInteractables.push(interact);
    }
  }

  /** Creates interior for Performance Art section. */
  async _createArtInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating ART interior at ${center.x}, ${center.z}`);
    
    // Store reference to this environment instance for use in inner functions
    const self = this;
    
    // Create a general interior light with warmer gallery lighting
    const interiorLight = new THREE.PointLight(0xfff2e6, 0.8, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // Create a central circular stage (kept from original)
    const stageGeometry = new THREE.CylinderGeometry(2.0, 2.0, 0.2, 32);
    const stageMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xdddddd, 
      roughness: 0.2,
      metalness: 0.3 
    });
    const stage = new THREE.Mesh(stageGeometry, stageMaterial);
    stage.position.set(center.x, center.y + 0.1, center.z);
    interiorGroup.add(stage);

    // --- Create the Performance Art Letter Generator ---
    try {
      console.log("Creating Performance Art Letter Generator...");
      this.letterGenerator = new PerformanceArtLetterGenerator(
        interiorGroup, 
        new THREE.Vector3(center.x, center.y + 1.2, center.z), // Position above stage
        2.0  // Radius of generator sphere
      );
      
      // Add to art room animations to ensure it's updated each frame
      if (!this._artRoomAnimations) this._artRoomAnimations = [];
      this._artRoomAnimations.push((deltaTime) => {
        if (this.letterGenerator) {
          this.letterGenerator.update(deltaTime);
        }
      });
      console.log("Performance Art Letter Generator created successfully");
    } catch (error) {
      console.error("Failed to create Performance Art Letter Generator:", error);
    }

    // --- Create Gallery Wall ---
    const addInfoInteractionToArtPoster = (imageGroup, position, interiorGroup, posterTitle) => {
      // Create an invisible box for interaction
      const interactGeom = new THREE.BoxGeometry(1.3, 1.6, 0.2);
      const interactMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, visible: false });
      const interactMesh = new THREE.Mesh(interactGeom, interactMat);
      interactMesh.position.set(0, 0, 0);
      // Offset in the direction the poster is facing (z+)
      const normalVector = new THREE.Vector3(0, 0, 1).applyEuler(imageGroup.rotation.clone());
      interactMesh.position.add(normalVector.clone().multiplyScalar(0.25));
      interactMesh.userData.isArtInfoInteractable = true;
      interactMesh.userData.interactable = true;
      interactMesh.userData.posterTitle = posterTitle;
      interactMesh.userData.imageUrls = getArtPosterImagePaths(posterTitle); // Get and store image URLs

      if (posterTitle === "Circle of Confusion") {
        interactMesh.userData.infoContent =
          "Circle of Confusion was a collaborative video-performance between Parsa Azari and Parsa Samadpour which came out of an idea: a sense of discomfort that we go through both in terms of our identity forming and our bodily as we grow.\n" +
          "This led to a video which was testament to our physical boundaries as two performers inside a studio and this video was projected in a rather vulnerable but transparent space to try to convey a shameful secret to the audience by showing it publicly.\n" +
          "The video was of us both practicing rope jumping as much as we could. Both were restricted by different types of barriers throughout the shoot and this clips of us trying and retrying was dissolved into one other to create an impossible image.\n" +
          "Audience was tested by the performers and went through trial to be able to move the secret part of the gallery.\n" +
          "This performance was part of the 7th annual 30 Performances 30 Artists 30 Days Festival which were held in TMoCA (Tehran Museum of Contemporary Arts), curated by Amir Rad.\n" +
          "Link: https://vimeo.com/327524174";
      } else if (posterTitle === "Friends") {
        interactMesh.userData.infoContent =
          "04/01/2016 – 04/01/2016\n" +
          "InstaMeet (Friend) (Performance Art, 30 min) (2016, 6th Annual 30 Performances 30 Artists 30 Days\n" +
          "Festival, TMoCA)\n" +
          "InstaMeet/Friend, was a multi-media effort which was attempting to capture a real life virtualization of networking\n" +
          "effects of social media on the nature of communication. this was done through a gamification of the relationship\n" +
          "between the performer and the audience throughout the performance. each person would be given an ID card\n" +
          "(containing their real life username on Instagram) and a mask to which they would wear in the gallery. the audience\n" +
          "interacted with the performer via his instagram account which was livestreamed in the gallery for everyone to see\n" +
          "where performer did posted various videos and photos of the event, replied to comments, took pictures of audience\n" +
          "and himself and so on. performer handpicked and brought them out to a deserted corner of the gallery, and before\n" +
          "taking their pictures, he unmasked the subjects to reveal their irl IDs in the photos with their username tagged. this\n" +
          "sort of doxxing (a rather newer term that's more widely used these days) generated a reactionary affect in the\n" +
          "audience and did encouraged them to interact more and more in the aforementioned website all awhile experiencing\n" +
          "all this in the hollowed out space of gallery.\n" +
          "this performance was part of the 5th annual festival of \"30 performances 30 artists 30 days\" in the Tehran Museum of\n" +
          "Contemporary Arts, Curated by Amir Rad. Performer did a reperformance based on InstaMeet in the Radical\n" +
          "Performance festival a year later in 2017.\n" +
          "شخب - رابخا -2/5162- یس - سنمروفرپ - یس - دنمرنه - یس - زور /ir.honaronline.www://https Link";
      } else if (posterTitle === "Dissolve") {
        interactMesh.userData.infoContent =
          "14/12/2016 – 14/12/2016\n" +
          "Dissolve (Video/Performance Art, 30 min) (2016, 6th Annual 30 Performances 30 Artists 30 Days\n" +
          "Festival, TMoCA)\n" +
          "Dissolve, was initially conceived as a meditation on the ephemeral nature of the modern day lives and and an\n" +
          "exploration of the challenging effects that the accelerated speed of our lives have had on the familial and on a bigger\n" +
          "scale, societal roles that we've been burdened with.\n" +
          "the Performance art piece that was accompanied by a video which portrayed the Performer in a rather performative\n" +
          "situations, doing transient and mundane chores of everyday life; entering rooms, exiting them, going to sleep and\n" +
          "waking from it. these short clips gets repeatedly dissolved into another, just as the different places and tasks get\n" +
          "dissolve into one another in an absolute displacement; meanwhile the performer who was placed in the middle of\n" +
          "gallery and with canvas behind him, had obtained the figure of a painter, who instead of brushing the canvas with\n" +
          "paint was looking through multiple volumes of Persian dictionaries for words, hand picking a few and writing them on\n" +
          "DIGITAL SKILLS\n" +
          "CREATIVE WORKS \n" +
          "the canvas. the words were picked randomly in a dadaian fashion but maintained a coherent sense over (fabricated or\n" +
          "not) definitions of roles and groundings of humans within societal norms and traditions within familial bonds. he\n" +
          "gradually tried to interact with the audience in the room to give them the opportunity to rethink words, pick and write\n" +
          "them. eventually the canvas got filled with words and their definitions that made it utterly unreadable and totally\n" +
          "black.This performance piece was part of 6th Annual \"30 Performances, 30 Artists, 30 Days Festival\" which was\n" +
          "annually held at Tehran Museum of Contemporary Art.\n" +
          "- شخب - یمسجت -4/91566- یتقو - یانعم - گنهرف - تغل - گنر - یم - دزاب - یزاب - اب - تاملک - انعم - هتخاب - رد - نیموس - یارجا /ir.honaronline.www://https Link\n" +
          "لاویتسف - یس - سنمروفرپ - یس - دنمرنه - یس - زو";
      } else {
      interactMesh.userData.infoContent = `Boilerplate info for ${posterTitle}`;
      }
      // --- Add floating 3D 'E' button mesh ---
      const eButtonCanvas = document.createElement('canvas');
      eButtonCanvas.width = 320; 
      eButtonCanvas.height = 100;
      const eButtonCtx = eButtonCanvas.getContext('2d');
      const borderRadius = 8;
      const padding = 10;
      const indicatorSize = 30;
      const indicatorMargin = 15;
      const text = "INFO";
      eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      const textMetrics = eButtonCtx.measureText(text);
      const textWidth = textMetrics.width;
      const totalWidth = indicatorMargin + indicatorSize + indicatorMargin + textWidth + padding * 2;
      const totalHeight = indicatorSize + padding * 2;
      eButtonCanvas.width = totalWidth;
      eButtonCanvas.height = totalHeight;
      eButtonCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
      eButtonCtx.beginPath();
      eButtonCtx.roundRect(0, 0, totalWidth, totalHeight, borderRadius);
      eButtonCtx.fill();
      eButtonCtx.strokeStyle = '#5CDED3';
      eButtonCtx.lineWidth = 2;
      eButtonCtx.stroke();
      const indicatorX = padding;
      const indicatorY = padding;
      eButtonCtx.fillStyle = '#5CDED3';
      eButtonCtx.beginPath();
      eButtonCtx.roundRect(indicatorX, indicatorY, indicatorSize, indicatorSize, 4);
      eButtonCtx.fill();
      eButtonCtx.font = 'bold 24px "Neue Montreal", sans-serif';
      eButtonCtx.fillStyle = '#000';
      eButtonCtx.textAlign = 'center';
      eButtonCtx.textBaseline = 'middle';
      eButtonCtx.fillText('E', indicatorX + indicatorSize / 2, indicatorY + indicatorSize / 2 + 1);
      eButtonCtx.font = 'bold 28px "Neue Montreal", sans-serif';
      eButtonCtx.fillStyle = '#FFFFFF';
      eButtonCtx.textAlign = 'left';
      eButtonCtx.textBaseline = 'middle';
      eButtonCtx.fillText(text, indicatorX + indicatorSize + indicatorMargin, totalHeight / 2 + 1);
      const eButtonTex = new THREE.CanvasTexture(eButtonCanvas);
      eButtonTex.needsUpdate = true;
      eButtonTex.minFilter = THREE.LinearFilter;
      eButtonTex.magFilter = THREE.LinearFilter;
      const eButtonMat = new THREE.MeshBasicMaterial({ map: eButtonTex, transparent: true, side: THREE.DoubleSide });
      const buttonAspect = eButtonCanvas.width / eButtonCanvas.height;
      const buttonHeight = 0.22;
      const buttonWidth = buttonHeight * buttonAspect;
      const buttonMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(buttonWidth, buttonHeight),
        eButtonMat
      );
      // Place button above and in front of the poster (local coordinates)
      buttonMesh.position.set(0, 0.9, 1.5); // up and out in local space
      // Set rotation to face forward (z+)
      buttonMesh.rotation.set(0, 0, 0);
      buttonMesh.renderOrder = 9999;
      buttonMesh.visible = true;
      buttonMesh.name = 'artPosterEButton';
      imageGroup.add(buttonMesh); // <-- add to imageGroup, not interiorGroup
      interactMesh.userData.eButtonMesh = buttonMesh;
      imageGroup.add(interactMesh);
      if (!imageGroup.userData.interactables) imageGroup.userData.interactables = [];
      imageGroup.userData.interactables.push(interactMesh);
      
      // Add to art poster interactables collection for getInteractableObjects
      if (!self._artPosterInteractables) self._artPosterInteractables = [];
      self._artPosterInteractables.push(interactMesh);
      console.log(`[DEBUG] Added art poster interactable for '${posterTitle}' with ${interactMesh.userData.imageUrls.length} images.`);
      
      return interactMesh;
    };

    const createGalleryWall = async (wallPosition, wallRotation, posterTitle, count = 6) => {
        console.log(`Creating gallery wall for ${posterTitle} with ${count} images`);
        const wallGroup = new THREE.Group();
        
        try {
            // Create grid layout for images
            const imageHeight = 1.1; // Smaller posters
            const imageWidth = imageHeight * 1.5; // Fixed aspect ratio
            const imageSpacing = 0.2;
            const imagesPerRow = 3;
            
            // Set the texture loader
            const textureLoader = new THREE.TextureLoader();
            
            // Create the appropriate path based on posterTitle
            const basePath = `/assets/Images/performance/solo performances/${posterTitle.toLowerCase()}/`;
            console.log(`Looking for images at path: ${basePath}`);
            
            for (let i = 0; i < count; i++) {
                const row = Math.floor(i / imagesPerRow);
                const col = i % imagesPerRow;
                // Create image group
                const imageGroup = new THREE.Group();
                
                // Create a colored rectangle with a border
                const fallbackGeometry = new THREE.PlaneGeometry(imageWidth, imageHeight);
                
                // Use specific colors for each gallery wall (as fallback)
                let color;
                if (posterTitle === 'Circle of Confusion') {
                    color = new THREE.Color(0.2 + Math.random() * 0.3, 0.1 + Math.random() * 0.2, 0.6 + Math.random() * 0.4); // Blues/purples
                } else if (posterTitle === 'Dissolve') {
                    color = new THREE.Color(0.6 + Math.random() * 0.4, 0.2 + Math.random() * 0.3, 0.1 + Math.random() * 0.2); // Oranges/reds
                } else { // Friends
                    color = new THREE.Color(0.1 + Math.random() * 0.2, 0.6 + Math.random() * 0.4, 0.2 + Math.random() * 0.3); // Greens
                }
                
                // First, create the frame
                const frameGeometry = new THREE.PlaneGeometry(imageWidth + 0.1, imageHeight + 0.1);
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0,
                    roughness: 0.5,
                    metalness: 0.3
                });
                
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.z = 0.01;
                imageGroup.add(frame);
                
                // Get appropriate image filename based on gallery type
                let imageName = null;
                
                if (posterTitle === 'Circle of Confusion') {
                    // Files are named: photo_2025-05-01_17-25-22.jpg, photo_2025-05-01_17-25-22 (2).jpg, etc.
                    // Note: No (1) file, starts with no suffix then goes to (2)
                    if (i === 0) {
                        imageName = 'photo_2025-05-01_17-25-22.jpg';
                    } else if (i < 6) {
                        // Use (2) through (6) for indexes 1-5
                        imageName = `photo_2025-05-01_17-25-22 (${i+1}).jpg`;
                    }
                } else if (posterTitle === 'Dissolve') {
                    // Files are named: سی پرفورمنس ،سی هنرمند، سی روز 3.jpg, سی پرفورمنس ،سی هنرمند، سی روز 3 (1).jpg, etc.
                    if (i === 0) {
                        imageName = 'سی پرفورمنس ،سی هنرمند، سی روز 3.jpg';
                    } else if (i < 18) { // We have up to (18)
                        imageName = `سی پرفورمنس ،سی هنرمند، سی روز 3 (${i}).jpg`;
                    }
                } else if (posterTitle === 'Friends') {
                    // Files have various names, map them explicitly
                    const friendsImages = [
                        'photo_2025-05-01_17-29-01.jpg',
                        'M2RjNjJmMjZk.jpg',
                        'NzIwYjJkZmQ1.jpg',
                        'ZTBjZDc1NzQ4.jpg',
                        'ZTgyOGRjYjRj.jpg',
                        'MGE1ZjJiODcw.jpg',
                        'YmQ4YmZlY2U4.jpg',
                        'N2MyYTc3OWFj.jpg',
                        'NDc1MWY3OGM2.jpg',
                        'M2MwYmIyMzY4.jpg',
                        'NDc2M2NhOTc3.jpg',
                        'MzkyNmRjZDFm.jpg',
                        'ZDY5ZmU5Njg2.jpg'
                    ];
                    if (i < friendsImages.length) {
                        imageName = friendsImages[i];
                    }
                }
                
                let imageMaterial;
                
                if (imageName) {
                    try {
                        const imagePath = `${basePath}${imageName}`;
                        console.log(`Trying to load image: ${imagePath}`);
                        
                        const texture = await new Promise((resolve, reject) => {
                            textureLoader.load(
                                imagePath,
                                (texture) => {
                                    texture.minFilter = THREE.LinearFilter;
                                    texture.magFilter = THREE.LinearFilter;
                                    console.log(`Successfully loaded texture: ${imagePath}`);
                                    resolve(texture);
                                },
                                (progress) => {
                                    // Log progress for debugging
                                    if (progress.lengthComputable) {
                                        const percentComplete = (progress.loaded / progress.total) * 100;
                                        console.log(`Loading ${imagePath}: ${Math.round(percentComplete)}%`);
                                    }
                                },
                                (error) => {
                                    console.warn(`Failed to load texture ${imagePath}:`, error);
                                    reject(error);
                                }
                            );
                        });
                        
                        // Create material with loaded texture
                        imageMaterial = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.7,
                            metalness: 0.2
                        });
                    } catch (error) {
                        // Fallback to colored rectangle
                        console.warn(`Using fallback for ${imageName}:`, error);
                        imageMaterial = new THREE.MeshStandardMaterial({
                            color: color,
                            roughness: 0.7,
                            metalness: 0.2
                        });
                    }
                } else {
                    // Fallback to colored rectangle if no image name
                    imageMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                }
                
                const photo = new THREE.Mesh(fallbackGeometry, imageMaterial);
                photo.position.z = 0.02;
                imageGroup.add(photo);
                imageGroup.position.x = (col - 1) * (imageWidth + imageSpacing);
                imageGroup.position.y = center.y + 1.2 + row * (imageHeight + imageSpacing);
                wallGroup.add(imageGroup);
                
                // Add subtle spotlight for each image
                const spotlight = new THREE.SpotLight(0xfff2e6, 1.5, 4.0, Math.PI/6, 0.5, 1.0);
                spotlight.position.set(
                    imageGroup.position.x,
                    imageGroup.position.y + imageHeight/2 + 0.3,
                    0.8
                );
                spotlight.target = imageGroup;
                wallGroup.add(spotlight);
                wallGroup.add(spotlight.target);
                
                // Add info button only to the first image of each wall
                if (i === 0) {
                    addInfoInteractionToArtPoster(imageGroup, imageGroup.position.clone().applyMatrix4(wallGroup.matrixWorld), interiorGroup, posterTitle);
                }
            }
            
            // Position and add the wall group
            wallGroup.position.copy(wallPosition);
            wallGroup.rotation.y = wallRotation;
            interiorGroup.add(wallGroup);
            console.log(`Gallery wall for ${posterTitle} created successfully`);
        } catch (error) {
            console.error(`Failed to create gallery wall for ${posterTitle}:`, error);
        }
    };

    // --- Wall Definitions (robust to door orientation) ---
    try {
        console.log("Setting up gallery walls...");
        const wallOffset = 0.2;
        const doorDir = new THREE.Vector3().subVectors(doorPosition, center).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        const rightVec = new THREE.Vector3().crossVectors(up, doorDir).normalize();

        // Back wall (Friends)
        const backWallPos = new THREE.Vector3().copy(center).addScaledVector(doorDir, -(size.z/2 - wallOffset));
        const backWallRot = Math.atan2(doorDir.x, doorDir.z);
        await createGalleryWall(backWallPos, backWallRot, 'Friends');

        // Left wall (Circle of Confusion)
        const leftWallPos = new THREE.Vector3().copy(center).addScaledVector(rightVec, -(size.x/2 - wallOffset));
        const leftWallRot = Math.atan2(rightVec.x, rightVec.z);
        await createGalleryWall(leftWallPos, leftWallRot, 'Circle of Confusion');

        // Right wall (Dissolve)
        const rightWallPos = new THREE.Vector3().copy(center).addScaledVector(rightVec, (size.x/2 - wallOffset));
        const rightWallRot = Math.atan2(-rightVec.x, -rightVec.z);
        await createGalleryWall(rightWallPos, rightWallRot, 'Dissolve');
        
        console.log("All gallery walls created successfully");
    } catch (error) {
        console.error("Failed to create gallery walls:", error);
    }

    console.log('Created sophisticated art gallery interior with robust wall placement and empty door wall.');
}

  /** Loads and places the MDR model */
  async _createMdrInterior(interiorGroup, center, size, doorPosition) { // Added doorPosition
      console.log(`Creating MDR interior at ${center.x}, ${center.z}`);
        try {
          const loader = new GLTFLoader();
          const gltf = await loader.loadAsync("/severance_tv_show_office.glb"); // Path relative to public/
          const model = gltf.scene;

          // --- Material Override & Collision Setup --- (Simplified)
          const wallMaterial = this.materialSystem.getMaterial("wall");
          const floorMaterial = this.materialSystem.getMaterial("floor");
          const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
          const trimMaterial = this.materialSystem.getMaterial("trim"); // Example for desks

          model.traverse((child) => {
            if (child.isMesh) {
              // Simplified material assignment - NEEDS ADJUSTMENT BASED ON MODEL
              if (child.name.toLowerCase().includes("wall")) {
                const wallWorldPos = new THREE.Vector3();
                child.getWorldPosition(wallWorldPos);
                const distanceToDoor = wallWorldPos.distanceTo(doorPosition);
                const entranceWallThreshold = 1.5; // How close to door pos to be considered entrance wall

                if (distanceToDoor < entranceWallThreshold) {
                  console.log(`[MDR Interior] Skipping collidable wall near door: ${child.name}, dist: ${distanceToDoor.toFixed(2)}`);
                  // Optionally make the entrance wall invisible or remove it if needed
                  // child.visible = false;
                } else {
                  child.material = wallMaterial; // Apply material
                  this._addCollidableWall(child); // Add *other* model walls to collision
                }
              } else if (child.name.toLowerCase().includes("floor")) {
                 child.material = floorMaterial;
              } else if (child.name.toLowerCase().includes("ceiling")) {
                 child.material = ceilingMaterial;
              } else if (child.name.toLowerCase().includes("desk")) {
                 child.material = trimMaterial;
                 // Potentially add desks as collidable obstacles too
                 // this._addCollidableWall(child); // If desks should block movement
              } else {
                 // Apply a default or keep original if needed
              }
              child.castShadow = false;
              child.receiveShadow = false;
            }
          });

          // --- Scaling & Positioning --- (Copied from original, needs verification)
          const modelBox = new THREE.Box3().setFromObject(model);
          const modelSize = modelBox.getSize(new THREE.Vector3());
          const desiredSize = size.clone().multiplyScalar(0.9); // Fit within 90% of bounds
          const scaleFactor = Math.min(desiredSize.x / modelSize.x, desiredSize.y / modelSize.y, desiredSize.z / modelSize.z);

          console.log(`MDR Scaling: DeptSize=${size.x.toFixed(2)},${size.z.toFixed(2)} ModelSize=${modelSize.x.toFixed(2)},${modelSize.z.toFixed(2)} ScaleFactor=${scaleFactor.toFixed(2)}`);
          model.scale.set(scaleFactor, scaleFactor, scaleFactor);

          // Re-center model within bounds AFTER scaling
          // Note: Positioning might need adjustment based on model's origin
          model.position.copy(center); // Start at the section center
          const scaledModelBox = new THREE.Box3().setFromObject(model); // Recalculate bounds after scaling
          const scaledModelCenterOffset = scaledModelBox.getCenter(new THREE.Vector3()).sub(model.position); // How far is the model's geom center from its origin
          model.position.sub(scaledModelCenterOffset); // Adjust position to align geometric center with the section center
          model.position.y = center.y; // Ensure floor alignment (assuming model origin is at its base)

          interiorGroup.add(model);
          console.log(`Loaded and processed MDR model: severance_tv_show_office.glb`);
        } catch (error) {
          console.error("Error loading or processing MDR model:", error);
          // Fallback to placeholder if model loading fails
          this._createPlaceholderInterior(interiorGroup, center, size, doorPosition);
      }
  }


  /**
   * Create department interior elements based on department type - REPURPOSED
   * Dispatches to specific interior creation methods based on sectionType.
   * @param {string} sectionName - The portfolio section name (used for naming the group)
   * @param {THREE.Vector3} center - The calculated center of the section bounds
   * @param {THREE.Vector3} size - The calculated size of the section bounds
   * @param {string} sectionType - Identifier for the type of interior to create (e.g., 'DESIGN', 'MDR')
   * @private
   */
  async createPortfolioSectionInteriors(sectionName, center, size, sectionType, doorPosition) {
    console.log(`Creating interior elements for ${sectionName} (Type: ${sectionType}) at center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`);

    const interiorGroup = new THREE.Group();
    interiorGroup.name = `interior_${sectionName}`; // Use sectionName
    // interiorGroup.position.copy(center); // REVERTED: Set the group's world position to the section's center

    // --- DEBUG: Log the doorPosition if available ---
    if (doorPosition) {
      console.log(`[Interior Debug] Door position for ${sectionName}: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);
    } else {
      console.warn(`[Interior Debug] No door position provided for ${sectionName}, using center instead.`);
      doorPosition = center.clone();
    }

    // --- Create Bounding Walls --- (Common for most types, except maybe MDR if model includes walls)
    const wallMaterial = this.materialSystem.getMaterial("corridorWall");
    if (sectionType !== 'MDR') { // Only add procedural walls if not using MDR model's walls
        // Create walls but with a CLEAR DOORWAY
        this._createSectionWalls(center, size, wallMaterial, interiorGroup, doorPosition);
    } // MDR method needs to handle its own walls via _addCollidableWall

    // --- Common Floor --- (Always add a floor plane)
    const floorMaterial = this.materialSystem.getMaterial("floor");
    
    const floorGeom = new THREE.PlaneGeometry(size.x, size.z);
    const floor = new THREE.Mesh(floorGeom, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.copy(center);
    floor.position.y = center.y; // Place floor at the base Y
    interiorGroup.add(floor);

    // --- Common Ceiling --- (Always add a ceiling plane)
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const ceilingGeom = new THREE.PlaneGeometry(size.x, size.z);
    const ceiling = new THREE.Mesh(ceilingGeom, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.copy(center);
    ceiling.position.y = center.y + size.y; // Place ceiling at the top Y
    interiorGroup.add(ceiling);
    
    // Add ceiling to the ceilingMeshes array for indoor rain occlusion detection
    this.ceilingMeshes.push(ceiling);

    // --- FIX: Create a VERY bright entryway light right inside the door ---
    // Create light direction from door to center
    const doorToCenterDir = new THREE.Vector3()
      .subVectors(center, doorPosition)
      .normalize();
    
    // Place MULTIPLE bright lights inside the door
    // First light: Right at the entrance
    const entryLightPos = new THREE.Vector3()
      .copy(doorPosition)
      .add(doorToCenterDir.clone().multiplyScalar(0.5)); // 0.5 unit inside the door
    
    entryLightPos.y = center.y + 1.8; // Head height
    
    // Create an extremely bright light with a useful falloff
    const entryLight = new THREE.PointLight(0xffffff, 8.0, 12.0, 1.0); // Increased intensity from 5.0 to 8.0
    entryLight.position.copy(entryLightPos);
    interiorGroup.add(entryLight);
    
    // Second light: Further inside to illuminate deeper
    const innerLightPos = new THREE.Vector3()
      .copy(doorPosition)
      .add(doorToCenterDir.clone().multiplyScalar(3.0)); // 3 units inside
    
    innerLightPos.y = center.y + 2.0; // Slightly higher
    
    // Create a second bright light with wider radius
    const innerLight = new THREE.PointLight(0xffffff, 4.0, 15.0, 1.0);
    innerLight.position.copy(innerLightPos);
    interiorGroup.add(innerLight);
    
    console.log(`[Interior Debug] Added bright entry lights at entry (${entryLightPos.x.toFixed(2)}, ${entryLightPos.y.toFixed(2)}, ${entryLightPos.z.toFixed(2)}) and inside (${innerLightPos.x.toFixed(2)}, ${innerLightPos.y.toFixed(2)}, ${innerLightPos.z.toFixed(2)})`);
    
    // --- FIX: Create a bright colored entry marker ---
    // Choose a color based on section type
    const sectionColors = {
      'DESIGN': 0x4285f4, // Blue
      'DEV': 0x34a853,    // Green
      'FILM': 0xfbbc05,   // Yellow/gold
      'ART': 0xea4335,    // Red
      'MDR': 0xffffff     // White
    };
    
    const markerColor = sectionColors[sectionType] || 0xffffff;
    
    // Create a visible floor marker at the entrance
    const markerGeometry = new THREE.CircleGeometry(1.0, 32);
    const markerMaterial = new THREE.MeshStandardMaterial({
      color: markerColor,
      emissive: markerColor,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.7,
      roughness: 0.3
    });
    
    const entryMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    entryMarker.rotation.x = -Math.PI / 2; // Flat on floor
    
    // Position marker right at the entrance
    const markerPos = doorPosition.clone();
    markerPos.y = center.y + 0.01; // Just above floor
    entryMarker.position.copy(markerPos);
    
    // interiorGroup.add(entryMarker); // <<< REMOVED - Don't add the floor marker
    // console.log(`[Interior Debug] Added entry marker at (${markerPos.x.toFixed(2)}, ${markerPos.y.toFixed(2)}, ${markerPos.z.toFixed(2)})`);

    // --- Dispatch to specific interior creation method --- //
    try {
      console.log(`[Interior Debug] Creating ${sectionType} interior with doorPosition passed`);
      // <<< ADD LOG FOR sectionType BEFORE SWITCH >>>
      console.log(`[CPSI DEBUG] sectionType before switch: '${sectionType}'`);

      switch (sectionType) {
          case 'DESIGN':
              this._createDesignInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'DEV':
              this._createDevInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'FILM':
              // <<< ADD LOG INSIDE CASE 'FILM' >>>
              console.log("[CPSI DEBUG] Inside case 'FILM'. About to call _createFilmInterior.");
              console.log('[DEBUG] Calling _createFilmInterior', {interiorGroup, center, size, doorPosition});
              this._createFilmInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'ART':
              await this._createArtInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'MDR':
              await this._createMdrInterior(interiorGroup, center, size, doorPosition);
              break;
          default:
              console.warn(`Unknown portfolio section type: ${sectionType}. Creating placeholder.`);
              this._createPlaceholderInterior(interiorGroup, center, size, doorPosition);
          break;
      }
    } catch (error) {
      console.error(`[Interior Error] Failed to create interior for ${sectionName}: ${error.message}`);
      console.log(error.stack);
      // Ensure there's something visible even if creation fails
      this._createEmergencyBackupInterior(interiorGroup, center, doorPosition);
    }

    this.scene.add(interiorGroup);
    console.log(`Finished creating interior for ${sectionName} at world position: (${interiorGroup.position.x.toFixed(2)}, ${interiorGroup.position.y.toFixed(2)}, ${interiorGroup.position.z.toFixed(2)})`);
  }

  // --- FIX: Add emergency backup interior if all else fails ---
  _createEmergencyBackupInterior(interiorGroup, center, doorPosition) {
    console.log(`[EMERGENCY] Creating backup interior visible objects`);
    
    // Create fallback direction if doorPosition is not available
    let doorDir = new THREE.Vector3(1, 0, 0);
    if (doorPosition) {
      doorDir.subVectors(center, doorPosition).normalize();
    }
    
    // Create bright lights along path from door to center
    for (let i = 0; i < 5; i++) {
      const lightPos = doorPosition ? doorPosition.clone().add(doorDir.clone().multiplyScalar(i * 2)) : 
                                      center.clone().add(new THREE.Vector3(i-2, 0, i-2));
      lightPos.y = center.y + 1.5;
      
      const emergencyLight = new THREE.PointLight(0xffffff, 2.0, 5.0, 1.0); // Renamed from 'light' to 'emergencyLight'
      emergencyLight.position.copy(lightPos);
      interiorGroup.add(emergencyLight);
      
      // Add visible light bulb
      const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const bulbMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
      bulb.position.copy(lightPos);
      interiorGroup.add(bulb);
    }
    
    // Create bright colored cubes - REMOVED
    /*
    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
    for (let i = 0; i < 5; i++) {
      const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const cubeMaterial = new THREE.MeshBasicMaterial({ color: colors[i] });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      
      // Position cubes in a line from door to center
      const cubePos = doorPosition ? doorPosition.clone().add(doorDir.clone().multiplyScalar(i * 1.5 + 1)) :
                                    new THREE.Vector3(center.x + i - 2, center.y + 1, center.z + i - 2);
      cube.position.copy(cubePos);
      interiorGroup.add(cube);
    }
    */
  }
  
  /**
   * Updated placeholder interior with doorPosition parameter
   */
  _createPlaceholderInterior(interiorGroup, center, size, doorPosition) {
    // Create a general interior light
    const placeholderLight = new THREE.PointLight(0xffffff, 3.0, 0, 1); // Renamed from interiorLight to placeholderLight
    placeholderLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(placeholderLight);
    
    // If we have a doorPosition, add a special entry area light
    if (doorPosition) {
      // Direction from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Place a bright light near the entry
      const entryLightPos = new THREE.Vector3()
        .copy(doorPosition)
        .add(doorToCenter.clone().multiplyScalar(1.5)); // 1.5 units inside from door
      
      entryLightPos.y = center.y + 1.8; // Head height
      
      // Create a bright entry light
      const entryLight = new THREE.PointLight(0xffffff, 3.0, 6.0, 1.0);
      entryLight.position.copy(entryLightPos);
      interiorGroup.add(entryLight);
      
      console.log(`[Placeholder] Added entry light at (${entryLightPos.x.toFixed(2)}, ${entryLightPos.y.toFixed(2)}, ${entryLightPos.z.toFixed(2)})`);
    }
    
    // Add some ceiling lights
    const ceilingLightCount = 4;
    for (let i = 0; i < ceilingLightCount; i++) {
      const lightX = center.x + (Math.random() - 0.5) * size.x * 0.8;
      const lightZ = center.z + (Math.random() - 0.5) * size.z * 0.8;
      
      // Create ceiling light fixture
      const lightFixture = new THREE.Group();
      
      // Light housing
      const housingGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const housingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc, 
        roughness: 0.5,
        metalness: 0.8 
      });
      const housing = new THREE.Mesh(housingGeometry, housingMaterial);
      housing.position.y = -0.05;
      lightFixture.add(housing);
      
      // Light lens
      const lensGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.02, 16);
      const lensMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.1
      });
      const lens = new THREE.Mesh(lensGeometry, lensMaterial);
      lens.position.y = -0.09;
      lightFixture.add(lens);
      
      // Position the fixture
      lightFixture.position.set(lightX, center.y + size.y - 0.05, lightZ);
      interiorGroup.add(lightFixture);
      
      // Add the actual light source below the fixture
      const light = new THREE.PointLight(0xffffee, 1.5, size.y * 2.5, 1); // Increased range
      light.position.set(lightX, center.y + size.y - 0.2, lightZ);
      interiorGroup.add(light);
    }
    
    // Create furniture
    /*
    const placeholderGeometry = new THREE.BoxGeometry(size.x * 0.8, size.y * 0.75, size.z * 0.8);
    const placeholderMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.8,
        wireframe: false // Change to solid rather than wireframe
    });
    const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    // Position placeholder centered within the section bounds
    placeholderMesh.position.set(center.x, center.y + size.y * 0.375, center.z);
    interiorGroup.add(placeholderMesh);
    */
    
    console.log(`Added placeholder interior with lighting for ${interiorGroup.name}`);
  }

  /**
   * Creates a simple security console for the security department - KEEPING AS EXAMPLE
   * @param {THREE.Vector3} position - Position for the console
   * @param {THREE.Group} parentGroup - Parent group to add to
   * @private
   */
  createSecurityConsole(position, parentGroup) {
    const group = new THREE.Group();
    group.position.copy(position);

    // Console desk
    const deskGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.0);
    const deskMaterial = this.materialSystem.getMaterial("trim");
    const desk = new THREE.Mesh(deskGeometry, deskMaterial);
    desk.position.y = 0.4;
    group.add(desk);

    // Monitors
    const monitorGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.05);
    const monitorMaterial = new THREE.MeshStandardMaterial({
      color: 0x222222,
      emissive: 0x333335,
      emissiveIntensity: 0.5,
    });

    // Create multiple monitors
    for (let i = -1; i <= 1; i++) {
      const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
      monitor.position.set(i * 0.7, 0.9, -0.3);
      monitor.rotation.x = -Math.PI / 12;
      group.add(monitor);

      // Screen
      const screenGeometry = new THREE.PlaneGeometry(0.55, 0.35);
      const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        emissive: 0x0066ff,
        emissiveIntensity: 0.2,
        roughness: 0.3,
        metalness: 0.8,
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.03;
      monitor.add(screen);
    }

    parentGroup.add(group);
    return group;
  }

  /**
   * Builds a new corridor layout based on the CORRIDOR_MAP configuration
   * @private
   */
  async buildNewCorridorLayout() {
    console.log("Building corridor layout from CORRIDOR_MAP...");

    // Get the corridor system (needed for bounds update)
    const corridorSystem = this.systems.get("corridor");
    if (!corridorSystem) {
      console.error("Corridor system not found");
      return;
    }

    // Ensure corridor system is initialized (might still be needed for helper functions)
    if (!corridorSystem.initialized) {
      console.warn("Corridor system not initialized, initializing now...");
      await corridorSystem.initialize(this.container);
    }

    // Create the corridor network based *only* on the map
    this.createCorridorNetwork(); // This now builds the entire structure

    // Create elevator vestibule at the entrance (node 'ELV' at [0,0])
    const elevatorNode = CORRIDOR_MAP.nodes.find(n => n.id === 'ELV');
    const elevatorPos = elevatorNode
        ? new THREE.Vector3(elevatorNode.pos[0] * SEGMENT_LENGTH, 0, -elevatorNode.pos[1] * SEGMENT_LENGTH)
        : new THREE.Vector3(0, 0, 0); // Fallback to origin
    this.createElevatorVestibule(elevatorPos);

    // VALIDATION STEP: Check for and fix potential wall inconsistencies
    this._validateAndFixCorridorWalls();

    // Update corridor bounds and navigation (if the system handles this)
    if (corridorSystem.updateCorridorBounds) {
        corridorSystem.updateCorridorBounds();
    } else {
        console.warn("CorridorSystem does not have updateCorridorBounds method.");
    }

    // Register all generated corridor walls for collision (BoxGeometry meshes)
    for (const segment of this.corridorSegments.values()) {
      segment.traverse((child) => {
        if (child.isMesh && child.geometry instanceof THREE.BoxGeometry) {
          this._addCollidableWall(child);
        }
      });
    }
    console.log("Completed building corridor layout from map.");
  }

  /**
   * Validates corridor walls and fixes inconsistencies
   * @private
   */
  _validateAndFixCorridorWalls() {
    console.log("Validating corridor walls...");
    let wallsRemoved = 0;

    // Restore original check for Performance_Art door
    const checkPerformanceArtDoor = () => {
      if (window.performanceArtDoorPosition) {
        const doorPosition = window.performanceArtDoorPosition;
        console.log(`Precisely checking for walls blocking Performance_Art doorway at (${doorPosition.x.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);
        for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
          const wall = this.wallMeshes[i];
          if (!wall || !wall.position) continue;
          const wallWorldPos = new THREE.Vector3();
          wall.getWorldPosition(wallWorldPos);
          const isInDoorwayOpening = Math.abs(wallWorldPos.x - doorPosition.x) < DOORWAY_WIDTH / 2 &&
                                     Math.abs(wallWorldPos.z - doorPosition.z) < 1.0;
          if (isInDoorwayOpening && wallWorldPos.distanceTo(doorPosition) < 2.0) {
            console.log(`Removing wall directly blocking Performance_Art doorway at (${wallWorldPos.x.toFixed(2)}, ${wallWorldPos.z.toFixed(2)})`);
            if (wall.parent) wall.parent.remove(wall);
            this.wallMeshes.splice(i, 1);
            wallsRemoved++;
          }
        }
      }
    };

    // First, run the special Performance_Art door check
    checkPerformanceArtDoor();

    // Restore original check for general junction/doorway blockages
    for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
      const wall = this.wallMeshes[i];
      if (!wall || !wall.parent) continue;
      const atJunctionConnection = this._isAtJunctionConnection(wall.parent, wall);
      const wallPosition = new THREE.Vector3();
      wall.getWorldPosition(wallPosition);
      const isBlockingDoor = this._isBlockingDoorway(wallPosition);
      if (atJunctionConnection || isBlockingDoor) {
        if (wall.parent) wall.parent.remove(wall);
        this.wallMeshes.splice(i, 1);
        wallsRemoved++;
      }
    }
    
    // Additionally remove any walls still standing in the Security/Testing branch corridor at C6
    // Branch corridor runs at the C6 Z position
    const branchZ = -(-30) * SEGMENT_LENGTH; // C6 map pos [0,-30]
    for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
      const wall = this.wallMeshes[i];
      const worldPos = new THREE.Vector3();
      wall.getWorldPosition(worldPos);
      // If wall lies near branch corridor Z and within side range
      if (Math.abs(worldPos.z - branchZ) < SEGMENT_LENGTH / 2) {
        console.log(`[Env Collision] Removing branch corridor wall at (${worldPos.x.toFixed(2)}, ${worldPos.z.toFixed(2)})`);
        if (wall.parent) wall.parent.remove(wall);
        this.wallMeshes.splice(i, 1);
        wallsRemoved++;
      }
    }
    console.log(`Validation complete. Removed ${wallsRemoved} problematic walls.`);
  }

  /**
   * Checks if a wall is positioned at a junction connection point
   * @private
   */
  _isAtJunctionConnection(parentGroup, wall) {
    if (!parentGroup || !parentGroup.userData) return false;
    
    // For junction parents
    if (parentGroup.name && parentGroup.name.startsWith('junction_')) {
      const nodeId = parentGroup.name.split('_')[1];
      if (!nodeId) return false;
      
      // Find all edges connected to this junction
      const connectedEdges = CORRIDOR_MAP.edges.filter(
        edge => edge.from === nodeId || edge.to === nodeId
      );
      
      if (connectedEdges.length > 0) {
        // The wall might be blocking a corridor connection
        // A more sophisticated check would compare wall orientation to edge direction
        return true;
      }
    }
    
    return false;
  }

  /**
   * Checks if a wall is blocking a doorway
   * @private
   */
  _isBlockingDoorway(wallPosition) {
    if (!window.doorLocations) return false;
    for (const door of window.doorLocations) {
      if (!door.position) continue;
      // Remove: const doorwayWidth = DOORWAY_WIDTH; and const doorwayWidth = 1.8;
      // Use DOORWAY_WIDTH directly below
      if (door.name === "Performance_Art") {
        const distance = wallPosition.distanceTo(door.position);
        const isDirectlyBlockingEntry = Math.abs(wallPosition.x - door.position.x) < DOORWAY_WIDTH/2 && 
                                      Math.abs(wallPosition.z - door.position.z) < 1.0;
        if (distance < 2.0 && isDirectlyBlockingEntry) {
          console.log(`Wall at ${wallPosition.x.toFixed(2)}, ${wallPosition.z.toFixed(2)} is directly blocking ${door.name} doorway - removing`);
          return true;
        }
        return false;
      } else if (door.name === "Film_Cinema") {
        const distance = wallPosition.distanceTo(door.position);
        const isDirectlyBlockingEntry = Math.abs(wallPosition.x - door.position.x) < DOORWAY_WIDTH/2 && 
                                      Math.abs(wallPosition.z - door.position.z) < 1.0;
        if (distance < 2.0 && isDirectlyBlockingEntry) {
          console.log(`Wall at ${wallPosition.x.toFixed(2)}, ${wallPosition.z.toFixed(2)} is directly blocking ${door.name} doorway - removing`);
          return true;
        }
        return false;
      } else {
        const distance = wallPosition.distanceTo(door.position);
        if (distance < door.radius + 0.8) {
          return true;
        }
      }
    }
    return false;
  }

  // --- Added from LumonEnvironment ---

  /**
   * Create wayfinding elements (like colored floor strips) to help navigate.
   * This is an optional feature, potentially enabled via config.
   */
  async createWayfinding() {
    // Check if wayfinding should be enabled (e.g., via options)
    if (!this.options.enableWayfinding) {
      console.log("Wayfinding disabled.");
      return;
    }

    console.log("Creating wayfinding elements...");

    // Define department colors for wayfinding strips
    const deptColors = {
      MDR: 0x4285f4, // Blue
      O_AND_D: 0xea4335, // Red (Optics & Design)
      WELLNESS: 0x34a853, // Green
      BREAK_ROOM: 0x666666, // Gray
      PERPETUITY: 0xfbbc05, // Yellow
      TESTING: 0x9c27b0, // Purple
      SECURITY: 0x000000, // Black
      HUB: 0xffffff, // White (Optional)
    };

    // Define wayfinding paths (example paths, adjust based on final layout)
    // These assume connections radiating from a central point (0,0,0) or junction 'J1'
    const hubPosition = new THREE.Vector3(0, 0.01, 0); // Assuming origin

    const paths = [
      { to: "MDR", color: deptColors.MDR, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 2) },
      { to: "O_AND_D", color: deptColors.O_AND_D, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 2) },
      { to: "WELLNESS", color: deptColors.WELLNESS, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 4) },
      { to: "BREAK_ROOM", color: deptColors.BREAK_ROOM, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 4) },
      { to: "PERPETUITY", color: deptColors.PERPETUITY, targetPos: new THREE.Vector3(0, 0.01, -SEGMENT_LENGTH * 9) },
      { to: "TESTING", color: deptColors.TESTING, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 3, 0.01, -SEGMENT_LENGTH * 9) },
      { to: "SECURITY", color: deptColors.SECURITY, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 3, 0.01, -SEGMENT_LENGTH * 9) },
    ];

    // Create strips for each defined path
    paths.forEach(path => {
      // Find the nearest junction to the target department door
      // This provides a more logical endpoint for the wayfinding strip
      const nearestJunctionPos = this.findNearestJunction(path.targetPos);
      if (nearestJunctionPos) {
        this.createWayfindingStrip(hubPosition, nearestJunctionPos, path.color);
      } else {
        // Fallback: draw directly to the department door position if no junction found
        this.createWayfindingStrip(hubPosition, path.targetPos, path.color);
      }
    });
  }

  /**
   * Create a colored strip on the floor for wayfinding.
   * @param {THREE.Vector3} start - Start position (slightly above floor)
   * @param {THREE.Vector3} end - End position (slightly above floor)
   * @param {number} color - Strip color
   * @private
   */
  createWayfindingStrip(start, end, color) {
    // Calculate direction and length
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    if (length < 0.1) return; // Avoid creating zero-length strips
    direction.normalize();

    // Create strip geometry
    const stripWidth = 0.1; // Width of the wayfinding line
    const stripGeometry = new THREE.PlaneGeometry(stripWidth, length);
    const stripMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.7,
      side: THREE.DoubleSide,
    });

    // Create and position the strip
    const strip = new THREE.Mesh(stripGeometry, stripMaterial);

    // Position at midpoint between start and end
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    strip.position.copy(midpoint);
    strip.position.y = 0.015; // Ensure slightly above floor to avoid z-fighting

    // Rotate to align with direction
    strip.rotation.x = -Math.PI / 2; // Flat on floor

    // Calculate angle in XZ plane (for wayfinding direction)
    const angle = Math.atan2(direction.x, direction.z);
    strip.rotation.z = -angle; // Rotate around Y-axis (which is now Z after X rotation)

    this.scene.add(strip);
    const stripId = `strip_${start.x}_${start.z}_${end.x}_${end.z}`;
    this.wayfinding.set(stripId, strip);
    this.registerDisposable(stripGeometry);
    this.registerDisposable(stripMaterial);
  }

  /**
   * Returns an array of meshes that the player can collide with.
   * @returns {THREE.Mesh[]} List of collidable wall meshes.
   */
  getCollidableWalls() {
    // Filter out any potentially null or undefined entries just in case
    const validWalls = this.wallMeshes.filter(mesh => mesh instanceof THREE.Mesh);
    console.log(`[Env] getCollidableWalls called. Returning ${validWalls.length} initial wall meshes.`); // DEBUG - Updated log

    // Add closed door panels to the collidable list
    for (const [doorName, doorState] of this.doorStates) {
      // Check if the door is considered closed (angle close to 0)
      if (Math.abs(doorState.currentAngle) < 0.1) { 
        // Find the corresponding door data in the main doors map
        const doorData = this.doors.get(doorName);
        if (doorData && doorData.doorPanel instanceof THREE.Mesh) {
          validWalls.push(doorData.doorPanel);
          console.log(`[Env Collision] Added closed door panel to collidables: ${doorName}`);
        }
      }
    }

    if (validWalls.length === 0) {
      console.warn("[Env] getCollidableWalls returning 0 meshes. Collision will not work.");
    }
    return validWalls; // Use the filtered array
  }

  /**
   * Returns an array of meshes that the player can interact with.
   * Currently, this includes the main panel of each portfolio door.
   * @returns {THREE.Mesh[]} List of interactable door panel meshes.
   */
  getInteractableObjects() {
      const interactables = [];
      // Always include the invisible interaction meshes for doors
      if (this._doorInteractionMeshes) {
        for (const mesh of this._doorInteractionMeshes.values()) {
          interactables.push(mesh);
        }
      }
      // Optionally, still include door panels, groups, and frames for legacy/other interactions
      for (const [name, doorData] of this.doors) {
          if (doorData && doorData.doorPanel instanceof THREE.Mesh) {
              doorData.doorPanel.userData.doorName = name;
              doorData.doorPanel.userData.name = name;
              doorData.doorPanel.name = name;
              doorData.doorPanel.userData.interactable = true;
              interactables.push(doorData.doorPanel);
              if (doorData.doorGroup) {
                  doorData.doorGroup.userData.doorName = name;
                  doorData.doorGroup.userData.isParentObject = true;
                  interactables.push(doorData.doorGroup);
              }
              if (doorData.frame) {
                  doorData.frame.userData.doorName = name;
                  doorData.frame.userData.isFrameObject = true;
                  interactables.push(doorData.frame);
              }
          }
      }
      // === Add dev terminal and E button as interactables ===
      if (this._devTerminalInteractable) {
        for (const obj of this._devTerminalInteractable) {
          if (obj.mesh) {
            obj.mesh.userData.interactable = true;
            obj.mesh.userData.isDevTerminal = true;
            interactables.push(obj.mesh);
          }
          if (obj.eButton) {
            obj.eButton.userData.interactable = true;
            obj.eButton.userData.isDevTerminalEButton = true;
            interactables.push(obj.eButton);
              }
          }
      }
      // Add film posters (watch interactables)
      if (this._customWatchInteractables) {
        for (const obj of this._customWatchInteractables) {
          if (obj) {
            interactables.push(obj);
            console.log('[DEBUG] getInteractableObjects: found custom watch interactable', obj.userData.filmTitle, obj.position);
          }
        }
      }
      
      // Add art posters (art info interactables)
      if (this._artPosterInteractables) {
        for (const obj of this._artPosterInteractables) {
          if (obj) {
            interactables.push(obj);
            console.log('[DEBUG] getInteractableObjects: found art poster interactable', obj.userData.posterTitle, obj.position);
          }
        }
      }
      
      // Add node info interactables
      if (this._nodeInfoInteractables) {
        for (const obj of this._nodeInfoInteractables) {
          if (obj) {
            interactables.push(obj);
            console.log('[DEBUG] getInteractableObjects: found node info interactable', obj.userData.nodeType, obj.position);
          }
        }
      }
      
      console.log(`[Env Interaction] getInteractableObjects returning ${interactables.length} meshes.`);
      return interactables;
  }

  // Add new method for door animation update
  updateDoorAnimations(deltaTime) {
    if (!this.camera) return;

    // Update each door's state based on player proximity
    for (const [doorName, doorState] of this.doorStates) {
      // Skip if current angle already matches target angle
      if (Math.abs(doorState.currentAngle - doorState.targetAngle) < 0.01) {
        doorState.currentAngle = doorState.targetAngle;
        // Animation is done
        doorState.isAnimating = false;
        continue;
      }
      // Animation is in progress
      doorState.isAnimating = true;
      // Calculate angle difference and step
      const angleDiff = doorState.targetAngle - doorState.currentAngle;
      const step = Math.sign(angleDiff) * this.DOOR_ANIMATION_SPEED * deltaTime;
      // Apply easing to make animation more natural
      const easedStep = step * (1 - Math.pow(1 - Math.abs(angleDiff / this.DOOR_MAX_ANGLE), 3));
      // Update angle with easing and clamping
      doorState.currentAngle += easedStep;
      // Prevent overshoot
      if (Math.abs(doorState.targetAngle - doorState.currentAngle) < Math.abs(easedStep)) {
        doorState.currentAngle = doorState.targetAngle;
      }
      // Apply rotation to pivot
      doorState.pivot.rotation.y = doorState.currentAngle;
    }
  }

  /**
   * Toggles the open/closed state of a specific door by setting its target angle.
   * Called by interaction logic (e.g., UnifiedMovementController).
   * @param {string} doorName The name of the door to toggle (matching keys in this.doorStates and doorData.doorPanel.userData.doorName)
   */
  toggleDoorState(doorName) {
    console.log(`[Door Toggle] Attempting to toggle door: ${doorName}`);
    let doorState = this.doorStates.get(doorName);
    // If not found directly, search case-insensitively
    if (!doorState) {
        console.log(`[Door Toggle] Direct lookup failed, trying case-insensitive match`);
        for (const [key, state] of this.doorStates.entries()) {
            if (key.toLowerCase() === doorName.toLowerCase()) {
                doorName = key; // Use the correct case
                doorState = state;
                console.log(`[Door Toggle] Found match with key: ${key}`);
                break;
            }
        }
    }
    if (!doorState) {
        console.warn(`[Door Toggle] Door state not found for: ${doorName}`);
        console.log(`[Door Toggle] Available doors: ${Array.from(this.doorStates.keys()).join(', ')}`);
        return;
    }
    // Prevent toggling if the door is currently animating
    if (doorState.isAnimating) {
      console.log(`[Door Toggle] Door '${doorName}' is currently animating. Ignoring toggle request.`);
      return;
    }
    // Toggle the door's open/closed state
    doorState.isOpen = !doorState.isOpen;
    // Set the target angle based on the door's state
    if (doorState.isOpen) {
        doorState.targetAngle = this.DOOR_MAX_ANGLE * doorState.openDirection;
    } else {
        doorState.targetAngle = 0;
    }
    // Mark as animating (will be cleared in updateDoorAnimations)
    doorState.isAnimating = true;
    console.log(`[Door Toggle] Door '${doorName}' ${doorState.isOpen ? 'opening' : 'closing'} to angle ${doorState.targetAngle}`);
  }

  // Add method to update post-processing effects
  updatePostProcessing(deltaTime) {
    if (this.postProcessingPasses) {
      // Subtle animation of chromatic aberration
      if (this.postProcessingPasses.chromaticAberration) {
        const offset = Math.sin(deltaTime * 2) * 0.0005 + this.postProcessingConfig.chromaticAberration.offset;
        this.postProcessingPasses.chromaticAberration.uniforms.offset.value = offset;
      }

      // Subtle bloom pulse
      if (this.postProcessingPasses.bloom) {
        const strength = Math.sin(deltaTime) * 0.1 + this.postProcessingConfig.bloom.strength;
        this.postProcessingPasses.bloom.strength = strength;
      }
    }
  }

  // Add a new method to create doorframe walls around doors
  createDoorFrameWalls() {
    console.log("Creating door frame walls...");
    
    if (!window.doorLocations) return;
    
    // Retrieve door configs to get rotation information
    const doorConfigs = this.portfolioSectionsConfig;

    for (const doorLocation of window.doorLocations) {
      if (!doorLocation.position || !doorLocation.name) continue;
      
      // Find the corresponding config for rotation
      const config = Object.values(doorConfigs).find(c => c.name === doorLocation.name);
      if (!config) {
          console.warn(`Config not found for door: ${doorLocation.name}`);
          continue;
      }

      const doorPos = doorLocation.position;
      const doorWidth = 1.2; // Standard door width
      const doorHeight = 2.5; // Standard door height
      const wallThickness = 0.1;
      
      // Identify if this is a problem door
      const needsExtraExtension = ["Interaction_Design", "Development"].includes(doorLocation.name);
      
      // Increase frame dimensions - especially height and vertical extension
      const frameWidth = 1.0; // Width of the side frame pieces
      const frameDepth = 0.4; // Depth of the frame
      const topFrameHeight = 0.3; // Increased height of the top frame piece
      
      // Extend the side walls significantly higher above the door for problem doors
      const extensionFactor = needsExtraExtension ? 1.5 : 1.0;
      // Make the side pieces much taller for problem doors
      const sideWallHeight = needsExtraExtension ? doorHeight * 1.8 : doorHeight;
      // Add extra height to the side walls to extend above the door
      const sideWallYOffset = needsExtraExtension ? doorHeight * 0.4 : 0;

      // Create wall material
      const wallMaterial = this.materialSystem.getMaterial("wall").clone();
      if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
        wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
        wallMaterial.needsUpdate = true;
      } else if (wallMaterial.color) {
        wallMaterial.color.setHex(0xffffff);
      }
      
      // Make the wall material transparent to allow seeing through when doors are open
      wallMaterial.transparent = true;
      wallMaterial.opacity = 1.0;
      wallMaterial.depthWrite = true;
      wallMaterial.side = THREE.DoubleSide;
      wallMaterial.needsUpdate = true;
      
      const doorFrameGroup = new THREE.Group();
      doorFrameGroup.name = `doorframe_${doorLocation.name}`;
      
      // Get door's rotation from the config, ensuring it's normalized
      const doorRotation = (config.rotation + Math.PI * 2) % (Math.PI * 2); // Normalize rotation

      // Create frame pieces using BoxGeometry - making side pieces taller
      const leftWallGeom = new THREE.BoxGeometry(frameWidth, sideWallHeight, frameDepth * extensionFactor);
      const rightWallGeom = new THREE.BoxGeometry(frameWidth, sideWallHeight, frameDepth * extensionFactor);
      // Make top piece wider to better connect with side pieces
      const topWallGeom = new THREE.BoxGeometry(doorWidth + frameWidth * 3, topFrameHeight, frameDepth * extensionFactor);
      
      const leftWall = new THREE.Mesh(leftWallGeom, wallMaterial.clone());
      const rightWall = new THREE.Mesh(rightWallGeom, wallMaterial.clone());
      const topWall = new THREE.Mesh(topWallGeom, wallMaterial.clone());

      // Position frame pieces relative to the door center, then apply door rotation
      // Adjust center offset to extend deeper into the wall
      const centerOffset = new THREE.Vector3(0, 0, -frameDepth * extensionFactor / 2);

      // Position left wall relative to center - added Y offset to make it taller
      const leftOffset = new THREE.Vector3(-doorWidth / 2 - frameWidth / 2, doorHeight / 2 + sideWallYOffset, 0);
      leftWall.position.copy(centerOffset).add(leftOffset);
      
      // Position right wall relative to center - added Y offset to make it taller
      const rightOffset = new THREE.Vector3(doorWidth / 2 + frameWidth / 2, doorHeight / 2 + sideWallYOffset, 0);
      rightWall.position.copy(centerOffset).add(rightOffset);

      // Position top wall relative to center - make it higher for problem doors
      const topWallY = needsExtraExtension ? doorHeight + topFrameHeight : doorHeight + topFrameHeight / 2;
      const topOffset = new THREE.Vector3(0, topWallY, 0);
      topWall.position.copy(centerOffset).add(topOffset);

      // Add pieces to the group BEFORE rotating the group
      doorFrameGroup.add(leftWall);
      doorFrameGroup.add(rightWall);
      doorFrameGroup.add(topWall);

      // For problem doors, create additional extension walls to ensure complete coverage
      if (needsExtraExtension) {
        console.log(`Adding extra wall extensions for ${doorLocation.name} door frame`);
        
        // Extended wall height (much taller than door)
        const extendedHeight = doorHeight * 1.5;
        
        // Create extension walls on both sides that extend further into the corridor and higher up
        const extensionDepth = 0.6; // Deep extension into wall
        const extensionWidth = 0.5; // Wider than frame for better coverage
        
        // Create left and right extension walls that go deeper into the corridor wall and extend higher
        const leftExtGeom = new THREE.BoxGeometry(extensionWidth, extendedHeight, extensionDepth);
        const rightExtGeom = new THREE.BoxGeometry(extensionWidth, extendedHeight, extensionDepth);
        
        const leftExt = new THREE.Mesh(leftExtGeom, wallMaterial.clone());
        const rightExt = new THREE.Mesh(rightExtGeom, wallMaterial.clone());
        
        // Position these extensions further back (deeper into the wall) and higher up
        const deeperOffset = new THREE.Vector3(0, 0, -extensionDepth/2 - frameDepth/2);
        
        // Position left extension - adding extra height
        const leftExtOffset = new THREE.Vector3(-doorWidth / 2 - extensionWidth / 2, doorHeight / 2 + extendedHeight * 0.15, 0);
        leftExt.position.copy(deeperOffset).add(leftExtOffset);
        
        // Position right extension - adding extra height
        const rightExtOffset = new THREE.Vector3(doorWidth / 2 + extensionWidth / 2, doorHeight / 2 + extendedHeight * 0.15, 0);
        rightExt.position.copy(deeperOffset).add(rightExtOffset);
        
        // Add the extensions to the door frame group
        doorFrameGroup.add(leftExt);
        doorFrameGroup.add(rightExt);
        
        // Add them to collidable walls
        this._addCollidableWall(leftExt);
        this._addCollidableWall(rightExt);
        
        // Add horizontal extension above the door to connect the side pieces
        const topExtGeom = new THREE.BoxGeometry(doorWidth + extensionWidth * 2, 0.4, extensionDepth);
        const topExt = new THREE.Mesh(topExtGeom, wallMaterial.clone());
        
        // Position it above the door, connecting the left and right extensions
        topExt.position.copy(deeperOffset).add(new THREE.Vector3(0, doorHeight + 0.8, 0));
        
        doorFrameGroup.add(topExt);
        this._addCollidableWall(topExt);
      }

      // Position and rotate the entire frame group
      doorFrameGroup.position.copy(doorPos);
      doorFrameGroup.rotation.y = doorRotation;

      // Link this door frame group to the door state for visibility toggling
      const doorObj = this.doors.get(doorLocation.name);
      if (doorObj && doorObj.doorPanel) {
        // Store reference to frame group in door panel's userData
        doorObj.doorPanel.userData.doorFrameWalls = doorFrameGroup;
      }

      // Add to scene and collidable walls list
      this.scene.add(doorFrameGroup);
      this._addCollidableWall(leftWall);
      this._addCollidableWall(rightWall);
      this._addCollidableWall(topWall);
      
      console.log(`Created doorframe for ${doorLocation.name} at position (${doorPos.x.toFixed(2)}, ${doorPos.y.toFixed(2)}, ${doorPos.z.toFixed(2)}) with rotation ${doorRotation.toFixed(2)}`);
    }
  }

  /**
   * Update weather effects
   * @private
   */
  updateWeather(deltaTime) {
    const currentTime = Date.now();
    const rainSystem = this.systems.get("rain");
    if (!rainSystem) return;

    // Check if enough time has passed since last weather change
    if (currentTime - this.weatherState.lastWeatherChange > this.weatherState.minWeatherDuration) {
      // 5% chance to change weather state every update when enough time has passed
      if (Math.random() < 0.0005) { // Adjusted for deltaTime assuming ~60fps
        this.weatherState.isRaining = !this.weatherState.isRaining;
        this.weatherState.lastWeatherChange = currentTime;
      }
    }

    // Always enable/disable rain system based on isRaining
    if (this.weatherState.isRaining) {
      if (!rainSystem.enabled) rainSystem.enable();
      // Always update outdoors state for sound/visuals
      rainSystem.setOutdoors(this.isPlayerOutdoors());
      rainSystem.update(deltaTime);
    } else {
      if (rainSystem.enabled) rainSystem.disable();
    }
  }

  /**
   * Check if the player is in an outdoor area
   * @private
   * @returns {boolean} True if player is outdoors
   */
  isPlayerOutdoors() {
    if (!this.camera) return false;
    // Raycast upward to detect nearby ceilings
    const origin = this.camera.position.clone();
    const upward = new THREE.Vector3(0, 1, 0);
    const maxDistance = 5.0; // Check up to 5 units above
    const raycaster = new THREE.Raycaster(origin, upward, 0, maxDistance);
    const hits = raycaster.intersectObjects(this.ceilingMeshes, true);
    if (hits.length > 0) {
      // Ceiling detected overhead: indoors
      return false;
    }
    // No ceiling overhead: outdoors
    return true;
  }

  updateInteractionButtons(camera) {
    // Skip if no watch interactables or no camera
    if (!this._customWatchInteractables || !this._customWatchInteractables.length || !camera) {
      return;
    }
    
    // Get current time for animations
    const time = performance.now() * 0.001; // Convert to seconds
    
    // Update each E button to face the camera
    for (const interactable of this._customWatchInteractables) {
      if (!interactable || !interactable.userData.eButtonMesh) continue;
      
      const eButton = interactable.userData.eButtonMesh;
      
      // Skip if not visible
      if (!eButton.visible) continue;
      
      // Simple billboard effect - make button face the camera
      eButton.lookAt(camera.position);
      
      // Add a pulsing animation to the button when visible
      // Scale between 0.9 and 1.1 of original size
      const pulseFactor = 0.1; // 10% size variation
      const pulseSpeed = 1.5; // Full cycle in 1.5 seconds
      const pulse = 1 + pulseFactor * Math.sin(time * pulseSpeed * Math.PI);
      
      // Apply pulse to scale
      eButton.scale.set(pulse, pulse, 1);
      
      // Apply a small hover effect
      const hoverOffset = Math.sin(time * 2) * 0.03; // Subtle float up/down
      
      // Get original position or set it if not already stored
      if (!eButton.userData.originalY) {
        eButton.userData.originalY = eButton.position.y;
      }
      
      // Apply hover effect to y position
      eButton.position.y = eButton.userData.originalY + hoverOffset;
    }
    
    // --- Terminal E button proximity logic ---
    if (this._devTerminalInteractable && camera) {
      const playerPos = camera.position;
      for (const obj of this._devTerminalInteractable) {
        if (!obj.eButton || !obj.interactionMesh) continue;
        
        // Calculate distance to terminal interaction volume
        const interactionPos = new THREE.Vector3();
        obj.interactionMesh.getWorldPosition(interactionPos);
        
        const distanceToPlayer = playerPos.distanceTo(interactionPos);
        const proximityThreshold = 3.0; // Show E button when within 3 units
        
        // Debug log for E button state
        console.log('[Dev Terminal] E button debug:', {
          visible: obj.eButton.visible,
          position: obj.eButton.position,
          distanceToPlayer,
          interactionPos
        });
        // Show/hide E button based on proximity
        if (distanceToPlayer < proximityThreshold) {
          if (!obj.eButton.visible) {
            obj.eButton.visible = true;
            console.log('[Dev Terminal] Player in proximity, showing E button');
          }
          
          // Make E button face the camera (billboard effect)
          obj.eButton.lookAt(camera.position);
          
          // Add pulse animation
          const pulseFactor = 0.1;
          const pulseSpeed = 1.5;
          const pulse = 1 + pulseFactor * Math.sin(time * pulseSpeed * Math.PI);
          
          // Store original scale if not already set
          if (!obj.eButton.userData.originalScale) {
            obj.eButton.userData.originalScale = { 
              x: obj.eButton.scale.x,
              y: obj.eButton.scale.y,
              z: obj.eButton.scale.z
            };
          }
          
          // Apply pulse to scale
          const origScale = obj.eButton.userData.originalScale;
          obj.eButton.scale.set(
            origScale.x * pulse,
            origScale.y * pulse,
            origScale.z
          );
          
          // Add hover animation
          const hoverOffset = Math.sin(time * 2) * 0.03;
          
          // Store original Y position if not already set
          if (!obj.eButton.userData.originalY) {
            obj.eButton.userData.originalY = obj.eButton.position.y;
          }
          
          // Apply hover effect
          obj.eButton.position.y = obj.eButton.userData.originalY + hoverOffset;
        } else if (obj.eButton.visible) {
          obj.eButton.visible = false;
          console.log('[Dev Terminal] Player moved away, hiding E button');
        }
      }
    }
  }

  /**
   * Finds the nearest point on the main corridor wall to the given door position.
   * Returns { point: THREE.Vector3, segment: THREE.Group } or null if not found.
   */
  _findNearestCorridorWallPoint(doorPos) {
    let minDist = Infinity;
    let bestPoint = null;
    let bestSegment = null;
    // Only consider main corridor segments
    for (const [id, segment] of this.corridorSegments) {
      if (!id.startsWith('C')) continue; // Only main corridor segments
      const start = segment.userData.startPoint;
      const end = segment.userData.endPoint;
      // Project doorPos onto segment line (XZ only)
      const segVec = new THREE.Vector3().subVectors(end, start);
      const segLen = segVec.length();
      if (segLen === 0) continue;
      const segDir = segVec.clone().normalize();
      const doorVec = new THREE.Vector3().subVectors(doorPos, start);
      const t = Math.max(0, Math.min(1, segDir.dot(doorVec) / segLen));
      const proj = start.clone().add(segDir.clone().multiplyScalar(segLen * t));
      // Find perpendicular direction (in XZ)
      const perp = new THREE.Vector3(-segDir.z, 0, segDir.x).normalize();
      // Offset to the wall (assume right wall for now, can be improved)
      const wallPoint = proj.clone().add(perp.clone().multiplyScalar(CORRIDOR_WIDTH / 2));
      const dist = wallPoint.distanceTo(doorPos);
      if (dist < minDist) {
        minDist = dist;
        bestPoint = wallPoint;
        bestSegment = segment;
      }
      // Also check left wall
      const wallPointLeft = proj.clone().add(perp.clone().multiplyScalar(-CORRIDOR_WIDTH / 2));
      const distLeft = wallPointLeft.distanceTo(doorPos);
      if (distLeft < minDist) {
        minDist = distLeft;
        bestPoint = wallPointLeft;
        bestSegment = segment;
      }
    }
    if (bestPoint) {
      return { point: bestPoint, segment: bestSegment };
    }
    return null;
  }

  /**
   * Creates a tunnel from the main corridor wall to the door.
   * @param {THREE.Vector3} corridorPoint - Start point on the corridor wall
   * @param {THREE.Vector3} doorPos - End point at the door
   * @param {number} width - Tunnel width
   * @param {number} height - Tunnel height
   */
  _createCorridorToDoorTunnel(corridorPoint, doorPos, width, height) {
    const depth = corridorPoint.distanceTo(doorPos);
    if (depth < 0.05) return;
    const wallThickness = 0.12;
    const ceilingHeight = height;
    // Widen tunnel to fit both corridor and room wall, plus a small overlap to prevent leaks
    const vestibuleWidth = Math.max(width, CORRIDOR_WIDTH) + 0.15;
    const dir = new THREE.Vector3().subVectors(doorPos, corridorPoint).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(dir, up).normalize();
    const wallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }

    // Calculate the four corners of the tunnel
    const leftOffset = right.clone().multiplyScalar(-(vestibuleWidth/2 - wallThickness/2));
    const rightOffset = right.clone().multiplyScalar((vestibuleWidth/2 - wallThickness/2));
    const corridorLeft = corridorPoint.clone().add(leftOffset);
    const corridorRight = corridorPoint.clone().add(rightOffset);
    const doorLeft = doorPos.clone().add(leftOffset);
    const doorRight = doorPos.clone().add(rightOffset);

    // Ceiling (spans the rectangle defined by the four corners)
    const ceilingCenter = corridorPoint.clone().add(doorPos).multiplyScalar(0.5);
    ceilingCenter.y = corridorPoint.y + ceilingHeight - wallThickness/2;
    const ceilingLength = depth;
    const ceilingWidth = vestibuleWidth;
    const ceilingGeom = new THREE.BoxGeometry(ceilingWidth, wallThickness, ceilingLength);
    const ceiling = new THREE.Mesh(ceilingGeom, wallMaterial.clone());
    ceiling.position.copy(ceilingCenter);
    // Align ceiling with tunnel direction
    const tunnelQuat = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      dir
    );
    ceiling.setRotationFromQuaternion(tunnelQuat);
    // Set wallScale uniform for ceiling
    if (ceiling.material.uniforms && ceiling.material.uniforms.wallScale) {
        ceiling.material.uniforms.wallScale.value.set(ceilingWidth, wallThickness);
    }
    this.scene.add(ceiling);
    this._addCollidableWall(ceiling);
    this.ceilingMeshes.push(ceiling);
    this.tunnelWallMeshes.push(ceiling); // Track for uniform updates

    // --- Add tunnel floor with chevron pattern ---
    const floorMaterial = this.materialSystem.getMaterial('floor');
    const floorGeom = new THREE.BoxGeometry(ceilingWidth, wallThickness, ceilingLength);
    const floor = new THREE.Mesh(floorGeom, floorMaterial);
    const floorCenter = corridorPoint.clone().add(doorPos).multiplyScalar(0.5);
    floorCenter.y = corridorPoint.y + wallThickness/2; // At ground level
    floor.position.copy(floorCenter);
    floor.setRotationFromQuaternion(tunnelQuat);
    this.scene.add(floor);
    // Optionally add to collidables if needed

    // Side walls (left and right)
    const wallLength = depth;
    const wallGeom = new THREE.BoxGeometry(wallThickness, height, wallLength);

    // Left wall
    const leftWallCenter = corridorLeft.clone().add(doorLeft).multiplyScalar(0.5);
    leftWallCenter.y = corridorPoint.y + height/2;
    const leftWall = new THREE.Mesh(wallGeom, wallMaterial.clone());
    leftWall.position.copy(leftWallCenter);
    leftWall.setRotationFromQuaternion(tunnelQuat);
    // Set wallScale uniform for left wall
    if (leftWall.material.uniforms && leftWall.material.uniforms.wallScale) {
        leftWall.material.uniforms.wallScale.value.set(wallThickness, height);
    }
    this.scene.add(leftWall);
    this._addCollidableWall(leftWall);
    this.tunnelWallMeshes.push(leftWall); // Track for uniform updates

    // Right wall
    const rightWallCenter = corridorRight.clone().add(doorRight).multiplyScalar(0.5);
    rightWallCenter.y = corridorPoint.y + height/2;
    const rightWall = new THREE.Mesh(wallGeom, wallMaterial.clone());
    rightWall.position.copy(rightWallCenter);
    rightWall.setRotationFromQuaternion(tunnelQuat);
    // Set wallScale uniform for right wall
    if (rightWall.material.uniforms && rightWall.material.uniforms.wallScale) {
        rightWall.material.uniforms.wallScale.value.set(wallThickness, height);
    }
    this.scene.add(rightWall);
    this._addCollidableWall(rightWall);
    this.tunnelWallMeshes.push(rightWall); // Track for uniform updates

    // Log
    console.log(`[Corridor Tunnel] Created tunnel from corridor to door (rectangular prism) with width ${ceilingWidth}, depth ${ceilingLength}`);
  }

  /**
   * Load shader file content
   * @param {string} path - Path to the shader file
   * @returns {Promise<string>} - Promise resolving to shader code
   */
  async _loadShaderFile(path) {
    try {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Failed to load shader at ${path}: ${response.status} ${response.statusText}`);
      }
      return await response.text();
    } catch (error) {
      console.error(`Error loading shader file ${path}:`, error);
      throw error;
    }
  }
}

// Helper to create a glowing lamp bulb shader material
function createLampLightShaderMaterial() {
  // Simple glowing emissive shader
  return new THREE.ShaderMaterial({
    uniforms: {
      glowColor: { value: new THREE.Color(0xffffcc) },
      intensity: { value: 1.5 },
    },
    vertexShader: `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      uniform float intensity;
      varying vec3 vNormal;
      void main() {
        float glow = pow(0.6 + 0.4 * abs(vNormal.y), 2.0) * intensity;
        gl_FragColor = vec4(glowColor * glow, 1.0);
      }
    `,
    transparent: false,
    side: THREE.FrontSide,
  });
}

// === Kruger Text Utility ===
function createKrugerTextTexture(text, { width = 1024, height = 256, bgColor = '#fff', fgColor = '#e10600', font = 'bold 96px Helvetica Neue, Arial, sans-serif', align = 'center', vAlign = 'middle' } = {}) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  // Background
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, width, height);
  // Text
  ctx.font = font;
  ctx.fillStyle = fgColor;
  ctx.textAlign = align;
  ctx.textBaseline = vAlign;
  // Auto-wrap: split text if too long
  const words = text.split(' ');
  let line = '', lines = [], maxWidth = width * 0.9;
  for (let w of words) {
    const test = line + w + ' ';
    if (ctx.measureText(test).width > maxWidth) {
      lines.push(line);
      line = w + ' ';
    } else {
      line = test;
    }
  }
  lines.push(line);
  const lineHeight = 100;
  const yStart = height/2 - (lines.length-1)*lineHeight/2;
  lines.forEach((l, i) => ctx.fillText(l.trim(), width/2, yStart + i*lineHeight));
  return new THREE.CanvasTexture(canvas);
}

// === Placeholder async MCP fetch ===
async function fetchMCPContent(key) {
  // Simulate async fetch; in real use, replace with MCP server call
  const data = {
    'dev_slogans': [
      'YOU COMPILE > YOU FAIL',
      'YOUR CODE IS A MIRROR',
      'DEBUGGING IS SELF-REFLECTION',
      'ERRORS ARE INSTRUCTIONS',
      'YOUR IDENTITY = YOUR OUTPUT',
      'STACK OVERFLOWED',
      'WHO OWNS YOUR CODE?',
      'YOU ARE THE BUG',
    ],
    'cv_keywords': [
      'Full-Stack Alchemist',
      'Data Witch',
      'API Whisperer',
      'DevOps Druid',
      'TypeScript Tamer',
      'CI/CD Sorcerer',
      'Cloud Conjurer',
      'Security Sentinel',
    ],
    'terminal_cv': 'NAME: {{PLACEHOLDER}}\nSKILLS: {{PLACEHOLDER}}\nEXPERIENCE: {{PLACEHOLDER}}',
    'terminal_bio': 'BIO: {{PLACEHOLDER}}',
    'terminal_contact': 'PGP: {{PLACEHOLDER}}',
  };
  return data[key] || ['{{PLACEHOLDER}}'];
}

// Helper function to get image paths for a given poster title
const getArtPosterImagePaths = (title) => {
  // Path that matches the known directory structure
  const correctBasePath = `/assets/Images/performance/solo performances/${title.toLowerCase()}/`; 
  const urls = [];
  let count = 0;

  function pushUrl(url) {
    // Ensure spaces are encoded, and no double encoding if '+' was already for space
    let cleanUrl = url.replace(/\+/g, ' '); // Convert any existing '+' to space first
    cleanUrl = cleanUrl.replace(/ /g, '%20'); // Then encode all spaces to %20
    urls.push(cleanUrl);
    console.log(`[getArtPosterImagePaths] Pushed URL: ${cleanUrl}`); // Log generated URL
  }

  if (title === 'Circle of Confusion') {
    count = 6; 
    const baseFileName = 'photo_2025-05-01_17-25-22';
    for (let i = 0; i < count; i++) {
      if (i === 0) {
        pushUrl(`${correctBasePath}${baseFileName}.jpg`);
      } else {
        pushUrl(`${correctBasePath}${baseFileName} (${i + 1}).jpg`);
      }
    }
  } else if (title === 'Dissolve') {
    count = 14; // Reduce to 14 images based on error messages
    const baseFileName = 'سی پرفورمنس ،سی هنرمند، سی روز 3'; // Changed to use spaces instead of plus signs
    pushUrl(`${correctBasePath}${baseFileName}.jpg`); 
    for (let i = 1; i < count; i++) { 
      pushUrl(`${correctBasePath}${baseFileName} (${i}).jpg`);
    }
  } else if (title === 'Friends') {
    const friendsImages = [
      'photo_2025-05-01_17-29-01.jpg', 'M2RjNjJmMjZk.jpg', 'NzIwYjJkZmQ1.jpg',
      'ZTBjZDc1NzQ4.jpg', 'ZTgyOGRjYjRj.jpg', 'MGE1ZjJiODcw.jpg',
      'YmQ4YmZlY2U4.jpg', 'N2MyYTc3OWFj.jpg', 'NDc1MWY3OGM2.jpg',
      'M2MwYmIyMzY4.jpg', 'NDc2M2NhOTc3.jpg', 'MzkyNmRjZDFm.jpg',
      'ZDY5ZmU5Njg2.jpg'
    ];
    friendsImages.forEach(imgName => {
      pushUrl(`${correctBasePath}${imgName}`);
    });
  }
  
  console.log(`[getArtPosterImagePaths] Generated ${urls.length} image URLs for ${title}`);
  return urls;
};
