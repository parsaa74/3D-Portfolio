import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; // Added GLTFLoader import
import { TextureLoader } from "three"; // Add TextureLoader import
import { BaseEnvironment } from "./BaseEnvironment";
import { MapSystem } from "../../../systems/map/MapSystem";
import { SeveranceMaterials } from "../materials/SeveranceMaterials";
import { UnifiedMovementController } from "../../../systems/movement/UnifiedMovementController";
import { RainSystem } from "../../../systems/environment/RainSystem"; // Add RainSystem import
import {
  CorridorSystem,
  CORRIDOR_WIDTH,
  SEGMENT_LENGTH,
  CORRIDOR_HEIGHT,
  CORRIDOR_TRIM_HEIGHT,
} from "../../../systems/corridorSystem";
import { CORRIDOR_MAP } from "../../../systems/map/SeveranceCorridorMap.js";


const DOORWAY_WIDTH = 1.8; // Widened from 1.2 for a more spacious doorframe


export class SeveranceEnvironment extends BaseEnvironment {
  constructor(options = {}) {
    super({
      ...options,
      usePostProcessing: true, // Enable post-processing for visual effects
      usePerformanceMonitoring: true, // Monitor performance for optimization
    });

    // Add post-processing configuration
    this.postProcessingConfig = {
      bloom: {
        enabled: true,
        strength: 0.5,
        radius: 0.4,
        threshold: 0.8
      },
      chromaticAberration: {
        enabled: true,
        offset: 0.001
      }
    };

    // Initialize game state
    this.gameState = {
      isPlaying: false,
      currentLocation: "entrance",
      playerHealth: 100,
      inventory: [],
      visitedLocations: new Set(["entrance"]),
      objectives: new Map(),
      settings: {
        mouseSensitivity: 0.002,
        volume: 0.8,
        fov: 75,
        headBobEnabled: true,
        headBobIntensity: 0.08,
        headBobSpeed: 1.8
      }
    };

    // Weather state
    this.weatherState = {
      isRaining: false,
      lastWeatherChange: Date.now(),
      minWeatherDuration: 120000, // Minimum 2 minutes between weather changes
    };

    // Store references to doors and interactive objects
    this.doors = new Map();
    this.interactiveObjects = new Map();

    // Environment state
    this.emergencyLighting = false;
    this.lightFlickerIntensity = 0;

    // Corridor segments
    this.corridorSegments = new Map();
    // Store references to all indoor ceiling meshes for rain occlusion
    this.ceilingMeshes = [];

    // Collidable walls
    this.wallMeshes = []; // Added to store wall meshes for collision

    // Initialize materials system
    this.materialSystem = new SeveranceMaterials(this.renderer);

    // Initialize asset collections
    this.assets = {
      lights: new Map(),
      models: new Map(),
      sounds: new Map(),
      materials: new Map(), // Added from LumonEnvironment for consistency
    };

    // Wayfinding elements (from LumonEnvironment)
    this.wayfinding = new Map();
    this.clock = new THREE.Clock(); // Added from LumonEnvironment

    // Door locations for interaction detection
    window.doorLocations = [];

    // Add door animation properties
    this.doorStates = new Map();
    this.DOOR_INTERACTION_DISTANCE = 2.5; // Distance at which doors start opening
    this.DOOR_ANIMATION_SPEED = 1.5; // Speed of door opening/closing
    this.DOOR_MAX_ANGLE = Math.PI / 2; // 90 degrees open
    this.DOOR_OPEN_DIRECTION = 1; // 1 for opening to the right, -1 for opening to the left

    // Trackable objects
    this.doorStates = new Map(); // Track door state for animation
    this.doors = new Map(); // Store references to door objects
    
    // Add model loaders
    this.gltfLoader = new GLTFLoader();
    this.doorModels = {
        doorFrame: null,
        doorPivot: null,
        cardReader: null
    };
  }

  /**
   * Initialize environment systems
   * @protected
   * @override
   */
  async initializeSystems() {
    await super.initializeSystems();

    // Initialize material system first
    await this.materialSystem.initialize(this.renderer);

    // Initialize core gameplay systems (corridor must be set before setupEnvironment)
    this.systems.set(
      "corridor",
      new CorridorSystem(this.scene, this.materialSystem)
    );

    // Set up the environment before creating other systems
    await this.setupEnvironment();

    // Load door models before creating any doors
    await this.loadDoorModels();

    // Initialize movement controller
    if (!window.activeMovementController) {
      console.log("Initializing UnifiedMovementController");
      this.movementController = new UnifiedMovementController(this.camera, this);
      window.activeMovementController = this.movementController;
    } else {
      console.log("Using existing UnifiedMovementController");
      this.movementController = window.activeMovementController;
    }

    // Initialize rain system - do not pass audioListener
    this.systems.set(
      "rain",
      new RainSystem(this.scene, this.camera)
    );

    // Initialize each system
    for (const [name, system] of this.systems) {
      if (system.initialize) {
        await system.initialize(this.container);
      }
    }

    // Set up portfolio sections using the new method
    this.setupPortfolioSections();

    // Build the new, simplified corridor layout
    await this.buildNewCorridorLayout();

    // Provide ceiling meshes to rain system for occlusion
    const rainSystem = this.systems.get("rain");
    if (rainSystem) {
        rainSystem.setCeilings(this.ceilingMeshes);
    }

    // Optionally create wayfinding elements if needed
    await this.createWayfinding();

    // Initialize post-processing effects
    if (this.composer) {
      const { EffectComposer } = await import('three/examples/jsm/postprocessing/EffectComposer.js');
      const { RenderPass } = await import('three/examples/jsm/postprocessing/RenderPass.js');
      const { UnrealBloomPass } = await import('three/examples/jsm/postprocessing/UnrealBloomPass.js');
      const { ShaderPass } = await import('three/examples/jsm/postprocessing/ShaderPass.js');

      // Custom chromatic aberration shader
      const chromaticAberrationShader = {
        uniforms: {
          "tDiffuse": { value: null },
          "offset": { value: this.postProcessingConfig.chromaticAberration.offset }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float offset;
          varying vec2 vUv;
          void main() {
            vec4 cr = texture2D(tDiffuse, vUv + vec2(offset, 0));
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - vec2(offset, 0));
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
          }
        `
      };

      // Add bloom effect
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        this.postProcessingConfig.bloom.strength,
        this.postProcessingConfig.bloom.radius,
        this.postProcessingConfig.bloom.threshold
      );

      // Add chromatic abberation
      const chromaticAberrationPass = new ShaderPass(chromaticAberrationShader);

      // Add passes to composer
      this.composer.addPass(bloomPass);
      this.composer.addPass(chromaticAberrationPass);

      // Store passes for later adjustment
      this.postProcessingPasses = {
        bloom: bloomPass,
        chromaticAberration: chromaticAberrationPass
      };
    }

    // Initialize rain system
    this.systems.set(
      "rain",
      new RainSystem(this.scene, this.camera)
    );
    // Force enable the rain system for testing/initial state
    this.systems.get("rain").enable();

    console.log("✓ Environment systems initialized."); // Example log

    // ---> SET isPlaying TO TRUE HERE <---
    this.gameState.isPlaying = true;
    window.playerCanMove = true; // Also ensure playerCanMove is true here
    console.log(`[GAME STATE] Set isPlaying=${this.gameState.isPlaying}, playerCanMove=${window.playerCanMove}`);
  }

  // Add new method to load door models
  async loadDoorModels() {
    try {
        console.log("[Door Models] Starting to load door models...");
        
        // Load door frame model
        console.log("[Door Models] Loading door frame model...");
        const doorFrameResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/door frame.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Frame loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading door frame:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.doorFrame = doorFrameResult.scene;
        console.log("[Door Models] Door frame loaded successfully");
        
        // Load door pivot model
        console.log("[Door Models] Loading door pivot model...");
        const doorPivotResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/door pivot.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Pivot loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading door pivot:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.doorPivot = doorPivotResult.scene;
        console.log("[Door Models] Door pivot loaded successfully");
        
        // Load card reader model
        console.log("[Door Models] Loading card reader model...");
        const cardReaderResult = await new Promise((resolve, reject) => {
            this.gltfLoader.load(
                'assets/models/card reader.glb',
                resolve,
                (progress) => {
                    console.log(`[Door Models] Card reader loading progress: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error("[Door Models] Error loading card reader:", error);
                    reject(error);
                }
            );
        });
        this.doorModels.cardReader = cardReaderResult.scene;
        console.log("[Door Models] Card reader loaded successfully");
        
        // Verify all models loaded correctly
        if (!this.doorModels.doorFrame || !this.doorModels.doorPivot) {
            throw new Error("Required door models failed to load");
        }
        
        console.log("[Door Models] All door models loaded successfully");
        return true;
    } catch (error) {
        console.error("[Door Models] Critical error loading door models:", error);
        console.error("[Door Models] Stack trace:", error.stack);
        // Don't throw here - let the application continue with fallback behavior
        return false;
    }
  }

  /**
   * Set up the initial environment
   * @private
   */
  async setupEnvironment() {
    console.log("Setting up Severance environment...");

    // Remove default background and fog, will use a skybox instead
    // this.scene.background = new THREE.Color(0xffffff);
    // this.scene.fog = new THREE.Fog(0xffffff, 20, 40);

    // Initialize materials first
    await this.materialSystem.initialize();

    // Set initial camera position to start at the elevator entrance
    // Position further into the hallway to avoid any walls
    this.camera.position.set(
      0,
      this.options.cameraHeight,
      SEGMENT_LENGTH * 1.5
    );
    this.camera.rotation.set(0, Math.PI, 0); // Looking toward the end of the corridor (-Z direction)

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambientLight);
    this.assets.lights.set("ambient", ambientLight);

    // Set up lighting with shader-based fluorescent lights
    await this.setupLighting();

    // Update all materials with environment map if needed
    if (this.environmentMap) {
      this.materialSystem.updateEnvironmentMap(this.environmentMap);
    }

    // Remove global floor plane - the skybox bottom will serve as the ground
    // {
    //   const floorGeometry = new THREE.PlaneGeometry(200, 200);
    //   let floorMaterial = this.materialSystem.getMaterial("outsideGround");
    //   if (this.isPlayerOutdoors && typeof this.isPlayerOutdoors === 'function' && !this.isPlayerOutdoors()) {
    //     floorMaterial = this.materialSystem.getMaterial("floor");
    //   }
    //   this.globalFloor = new THREE.Mesh(floorGeometry, floorMaterial);
    //   this.globalFloor.rotation.x = -Math.PI / 2;
    //   this.globalFloor.receiveShadow = true;
    //   this.scene.add(this.globalFloor);
    // }

    // Build the corridor layout using the improved method that handles all 
    // corridor systems and connections properly
    await this.buildNewCorridorLayout();
    
    // Create a skysphere using the sky material (distinct from ground)
    const skyMaterial = this.materialSystem.getMaterial("sky");
    if (skyMaterial) {
        const sphereRadius = 250; // Large radius
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 60, 40);
        // Flip geometry normals to face inward
        sphereGeometry.scale(-1, 1, 1);

        const sphereMaterial = skyMaterial.clone(); // Clone to avoid side effects
        sphereMaterial.side = THREE.DoubleSide; // Use DoubleSide for inverted sphere
        sphereMaterial.needsUpdate = true;

        const skysphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        // Position sphere centered around the origin (or player start)
        skysphere.position.set(0, 0, 0);
        this.scene.add(skysphere);
        console.log("Added skysphere using distinct sky material.");
    } else {
        console.warn("Sky material not found for skysphere, using fallback color background.");
        this.scene.background = new THREE.Color(0x808080); // Fallback gray
    }

    // Add a large ground plane at y=0 using the outsideGround material
    const groundMaterial = this.materialSystem.getMaterial("outsideGround");
    if (groundMaterial) {
        const groundSize = 400; // Large enough to cover visible area
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2; // Make it horizontal
        groundMesh.position.y = 0; // Place at ground level
        groundMesh.receiveShadow = true;
        this.scene.add(groundMesh);
        this.globalFloor = groundMesh;
        console.log("Added distinct outside ground plane.");
    } else {
        console.warn("Outside ground material not found, ground plane not added.");
    }

    console.log("Environment setup complete");
  }

  /**
   * Initialize the rendering materials with custom shaders for the Severance aesthetic
   * @private
   */
  async initializeMaterials() {
    // Get the custom wall material from the material system instead of creating a new one
    try {
      this.wallMaterial = this.materialSystem.getMaterial("wall");
      console.log(
        "Successfully got wall material from material system:",
        this.wallMaterial.type
      );
    } catch (error) {
      console.warn(
        "Could not get 'wall' material from material system, creating fallback",
        error
      );

      // Fallback implementation - this shouldn't normally happen
      try {
        this.wallMaterial = new THREE.ShaderMaterial({
          uniforms: {
            wallColor: { value: new THREE.Color(0x888888) }, // Mid-grey for concrete base
            wallRoughness: { value: 0.8 }, // Higher roughness for concrete
            time: { value: 0.0 },
          },
          // Use material system to load vertex shader instead of inline definition
          // This ensures we're following the project organization guidelines
          vertexShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/common/vertex.glsl"
          ),
          fragmentShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/wall.glsl"
          ),
          side: THREE.DoubleSide,
        });

        console.log("Created fallback ShaderMaterial for walls");
      } catch (shaderError) {
        console.error(
          "Failed to create shader material fallback, using basic material",
          shaderError
        );

        // Ultra fallback - basic material if all else fails
        this.wallMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.75,
          side: THREE.DoubleSide,
        });

        console.log("Created basic MeshStandardMaterial for walls");
      }
    }

    // Make sure the wall material's side is set correctly
    if (this.wallMaterial) {
      this.wallMaterial.side = THREE.DoubleSide;
    }

    // Initialize corridor lighting shader material - using Severance's clinical lighting
    // Get lighting material from material system if available
    try {
      this.corridorLightingMaterial = this.materialSystem.getMaterial("light");
      console.log("Successfully got light material from material system");
    } catch (error) {
      console.warn(
        "Could not get 'light' shader material, creating fallback",
        error
      );

      try {
        this.corridorLightingMaterial = new THREE.ShaderMaterial({
          uniforms: {
            lightColor: { value: new THREE.Color(0xf0f7ff) }, // Subtle cool light
            intensity: { value: 0.8 }, // Brighter intensity for clinical look
            time: { value: 0.0 },
          },
          // Use material system to load vertex shader instead of inline definition
          vertexShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/common/vertex.glsl"
          ),
          fragmentShader: await this.materialSystem._loadShaderFile(
            "/src/shaders/corridor.glsl"
          ),
          transparent: true,
          blending: THREE.AdditiveBlending,
        });

        console.log("Created fallback ShaderMaterial for corridor lighting");
      } catch (shaderError) {
        console.error(
          "Failed to create shader material for lighting, using basic material",
          shaderError
        );

        // Ultra fallback for lighting
        this.corridorLightingMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.2,
          blending: THREE.AdditiveBlending,
        });

        console.log("Created basic MeshBasicMaterial for corridor lighting");
      }
    }
  }

  /**
   * Creates a corridor network based on the Severance show layout
   * @private
   */
  createCorridorNetwork() {
    if (!this.corridorSegments || !this.scene) {
      console.error('Required properties not initialized');
      return;
    }

    // Clean up any old corridor or junction meshes
    this.corridorSegments.clear();
    if (this.scene.userData.junctionPositions) {
      this.scene.userData.junctionPositions.length = 0;
    }
    
    // Remove existing corridor elements
    const toRemove = [];
    this.scene.traverse((child) => {
      if (child.name && (child.name.startsWith('junction_') || child.name.startsWith('corridor_'))) {
        toRemove.push(child);
      }
    });
    toRemove.forEach(child => this.scene.remove(child));

    console.log("Creating Severance corridor network from CORRIDOR_MAP...");

    // Only allow main corridor nodes
    const mainCorridorNodeIds = new Set(['ELV', 'C1', 'C2', 'C3', 'C4', 'C5']);

    // Generate junctions for main corridor only
    for (const node of CORRIDOR_MAP.nodes) {
      if (!mainCorridorNodeIds.has(node.id)) {
        continue;
      }
      const worldX = node.pos[0] * SEGMENT_LENGTH;
      const worldZ = -node.pos[1] * SEGMENT_LENGTH;
      const position = new THREE.Vector3(worldX, 0, worldZ);
      this.createCorridorJunction(position, `junction_${node.id}`);
    }

    // Generate corridor segments for main corridor only
    for (const edge of CORRIDOR_MAP.edges) {
      if (!mainCorridorNodeIds.has(edge.from) || !mainCorridorNodeIds.has(edge.to)) {
        continue;
      }
      const fromNode = CORRIDOR_MAP.nodes.find((n) => n.id === edge.from);
      const toNode = CORRIDOR_MAP.nodes.find((n) => n.id === edge.to);
      if (!fromNode || !toNode) continue;
      const start = new THREE.Vector3(
        fromNode.pos[0] * SEGMENT_LENGTH,
        0,
        -fromNode.pos[1] * SEGMENT_LENGTH
      );
      const end = new THREE.Vector3(
        toNode.pos[0] * SEGMENT_LENGTH,
        0,
        -toNode.pos[1] * SEGMENT_LENGTH
      );
      const segmentId = `${edge.from}_${edge.to}`;
      this.createCorridorSegment(start, end, segmentId);
    }
  }

  /**
   * Adds a mesh to the list of collidable walls.
   * @param {THREE.Mesh} mesh The wall mesh to add.
   * @private
   */
  _addCollidableWall(mesh) {
    if (mesh instanceof THREE.Mesh) {
        this.wallMeshes.push(mesh);
        // Detailed logging for added walls
        const wallName = mesh.name || 'Unnamed Wall';
        const worldPos = new THREE.Vector3();
        mesh.getWorldPosition(worldPos);
        console.log(`[Env Collision] Added collidable wall: ${wallName} at world pos (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})`);
    } else {
        console.warn("Attempted to add non-Mesh object to collidable walls:", mesh);
    }
  }


  /**
   * Creates the floor for a corridor segment.
   * @param {number} length Length of the segment.
   * @param {THREE.Material} floorMaterial Material for the floor.
   * @returns {THREE.Mesh} The floor mesh.
   * @private
   */
  _createSegmentFloor(length, floorMaterial) {
    const floorGeometry = new THREE.PlaneGeometry(CORRIDOR_WIDTH, length);
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0; // Floor level
    // floor.position.z = length / 2; // Position set in createCorridorSegment
    return floor;
  }

  /**
   * Creates the ceiling for a corridor segment.
   * @param {number} length Length of the segment.
   * @param {THREE.Material} ceilingMaterial Material for the ceiling.
   * @returns {THREE.Mesh} The ceiling mesh.
   * @private
   */
  _createSegmentCeiling(length, ceilingMaterial) {
    const ceilingGeometry = new THREE.PlaneGeometry(CORRIDOR_WIDTH, length);
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = CORRIDOR_HEIGHT; // Position at ceiling height
    // ceiling.position.z = length / 2; // Position set in createCorridorSegment
    return ceiling;
  }

  /**
   * Creates the walls for a corridor segment.
   * @param {number} length Length of the segment geometry.
   * @param {THREE.Material} wallMaterial Material for the walls.
   * @param {THREE.Group} segmentGroup The group to add walls to.
   * @param {number} centerZ The adjusted center Z position for the geometry.
   * @private
   */
  _createSegmentWalls(length, wallMaterial, segmentGroup, centerZ) {
    const wallThickness = 0.1;
    const wallGeometry = new THREE.BoxGeometry(length, CORRIDOR_HEIGHT, wallThickness);

    // Use Tim Rodenbröker-inspired corridor wall material
    const segmentWallMaterial = this.materialSystem.getMaterial('corridorWall').clone();

    // Check for doorways near this segment
    const doorways = this.getDoorwaysForSegment(segmentGroup.position, length, segmentGroup); // Pass segmentGroup

    // Create left wall segments (with gaps for doors)
    this.createWallWithDoorways(
      -CORRIDOR_WIDTH / 2 - wallThickness / 2,
      centerZ,
      length,
      wallGeometry,
      segmentWallMaterial,
      segmentGroup,
      doorways.left,
      Math.PI / 2
    );

    // Create right wall segments (with gaps for doors)
    this.createWallWithDoorways(
      CORRIDOR_WIDTH / 2 + wallThickness / 2,
      centerZ,
      length,
      wallGeometry,
      segmentWallMaterial,
      segmentGroup,
      doorways.right,
      -Math.PI / 2
    );
  }

  // New helper method to create wall segments with doorways
  createWallWithDoorways(xPos, zPos, length, wallGeometry, material, parentGroup, doorways, rotation) {
    if (!doorways || doorways.length === 0) {
      // No doorways, create single wall
      const wall = new THREE.Mesh(
        wallGeometry,
        material
      );
      wall.position.set(xPos, CORRIDOR_HEIGHT / 2, zPos);
      wall.rotation.y = rotation;
      parentGroup.add(wall);
      this._addCollidableWall(wall);
      return;
    }

    console.log(`Creating wall with ${doorways.length} doorways at x:${xPos.toFixed(2)}, z:${zPos.toFixed(2)}, rotation:${rotation.toFixed(2)}`);

    // Sort doorways by position
    doorways.sort((a, b) => a.position.z - b.position.z);

    // Add small gap buffer to prevent z-fighting and tiny wall segments
    const minSegmentSize = 0.2;
    let currentZ = -length / 2;

    // Create wall segments between doorways
    doorways.forEach((doorway, index) => {
      const doorStart = doorway.position.z - doorway.width / 2;
      const doorEnd = doorway.position.z + doorway.width / 2;

      console.log(`Door ${index} spans local z: ${doorStart.toFixed(2)} to ${doorEnd.toFixed(2)}`);

      // Create wall segment before door if needed and if segment would be large enough
      if (doorStart > currentZ + minSegmentSize) {
        const segmentLength = doorStart - currentZ;
        const wallGeom = new THREE.BoxGeometry(segmentLength, CORRIDOR_HEIGHT, 0.1);
        const wallSegment = new THREE.Mesh(wallGeom, material);
        
        // Position the wall segment correctly
        wallSegment.position.set(
          xPos,
          CORRIDOR_HEIGHT / 2,
          currentZ + segmentLength / 2
        );
        wallSegment.rotation.y = rotation;
        
        parentGroup.add(wallSegment);
        this._addCollidableWall(wallSegment);
        console.log(`Created wall segment before door ${index}, length: ${segmentLength.toFixed(2)}`);
      } else {
        console.log(`Skipping small wall segment before door ${index}, would be ${(doorStart - currentZ).toFixed(2)} units`);
      }

      currentZ = doorEnd;
    });

    // Create final wall segment after last door if needed
    if (currentZ < length / 2 - minSegmentSize) {
      const segmentLength = length / 2 - currentZ;
      const wallGeom = new THREE.BoxGeometry(segmentLength, CORRIDOR_HEIGHT, 0.1);
      const wallSegment = new THREE.Mesh(wallGeom, material);
      wallSegment.position.set(
        xPos,
        CORRIDOR_HEIGHT / 2,
        currentZ + segmentLength / 2
      );
      wallSegment.rotation.y = rotation;
      parentGroup.add(wallSegment);
      this._addCollidableWall(wallSegment);
      console.log(`Created final wall segment, length: ${segmentLength.toFixed(2)}`);
    } else {
      console.log(`Skipping small final wall segment, would be ${(length/2 - currentZ).toFixed(2)} units`);
    }
  }

  // New helper method to find doorways for a corridor segment
  getDoorwaysForSegment(segmentPosition, length, segmentGroup) {
    const doorways = {
      left: [],
      right: []
    };

    // Check all doors
    for (const [name, doorState] of this.doorStates) {
      const doorInfo = window.doorLocations.find(d => d.name === name);
      if (!doorInfo) continue;

      // Calculate door position relative to segment
      // --- Transform world door position to segment's local space ---
      const localDoorPos = new THREE.Vector3();
      segmentGroup.worldToLocal(localDoorPos.copy(doorInfo.position)); // Use segmentGroup passed to _createSegmentWalls
      
      // Extended doorway check - ensure we're within segment length
      const halfLength = length / 2;
      if (Math.abs(localDoorPos.z) > halfLength) {
        // Door is outside this segment's Z range
        continue;
      }

      // Check if door is near this wall segment
      const doorwayWidth = DOORWAY_WIDTH; // Increased from 1.5 for wider doorways
      const doorwayInfo = {
        position: localDoorPos, // Use local position for Z calculation
        width: doorwayWidth
      };

      // Increased detection threshold for wall alignment
      const detectionThreshold = 1.2; // Increased further from 0.8

      // Determine which wall this door belongs to based on LOCAL X
      if (Math.abs(localDoorPos.x - CORRIDOR_WIDTH/2) < detectionThreshold) {
        doorways.right.push(doorwayInfo);
        console.log(`Doorway detected for segment ${segmentGroup.name || 'unnamed'}: ${name} on RIGHT wall at local Z: ${localDoorPos.z.toFixed(2)}`);
      } else if (Math.abs(localDoorPos.x + CORRIDOR_WIDTH/2) < detectionThreshold) {
        doorways.left.push(doorwayInfo);
        console.log(`Doorway detected for segment ${segmentGroup.name || 'unnamed'}: ${name} on LEFT wall at local Z: ${localDoorPos.z.toFixed(2)}`);
      }
    }

    console.log(`Segment ${segmentGroup.name || 'unnamed'} has ${doorways.left.length} left doorways and ${doorways.right.length} right doorways`);
    return doorways;
  }

  /**
   * Creates the baseboard trim for a corridor segment.
   * @param {number} length Length of the segment geometry.
   * @param {THREE.Material} trimMaterial Material for the trim.
   * @param {THREE.Group} segmentGroup The group to add trim to.
   * @param {number} centerZ The adjusted center Z position for the geometry.
   * @private
   */
  _createSegmentTrim(length, trimMaterial, segmentGroup, centerZ) {
    const trimHeight = CORRIDOR_TRIM_HEIGHT;
    const trimDepth = 0.05; // Small depth for the trim
    // Geometry length matches the effective segment length
    const baseboardGeometry = new THREE.BoxGeometry(length, trimHeight, trimDepth);

    // Left baseboard
    const leftBaseboard = new THREE.Mesh(baseboardGeometry, trimMaterial);
    leftBaseboard.position.set(
      -CORRIDOR_WIDTH / 2 + trimDepth / 2, // Offset slightly inward
      trimHeight / 2, // Position at floor level
      centerZ // Use adjusted center Z
    );
    leftBaseboard.rotation.y = Math.PI / 2; // Align with wall
    segmentGroup.add(leftBaseboard);

    // Right baseboard
    const rightBaseboard = new THREE.Mesh(baseboardGeometry, trimMaterial);
    rightBaseboard.position.set(
      CORRIDOR_WIDTH / 2 - trimDepth / 2, // Offset slightly inward
      trimHeight / 2,
      centerZ // Use adjusted center Z
    );
    rightBaseboard.rotation.y = -Math.PI / 2; // Align with wall
    segmentGroup.add(rightBaseboard);
  }

  /**
   * Creates a corridor segment between two points
   * @param {THREE.Vector3} start Start position
   * @param {THREE.Vector3} end End position
   * @param {string} id Segment identifier
   * @private
   */
  createCorridorSegment(start, end, id) {
    console.log(`Creating corridor segment ${id}`);

    // Create container for the segment
    const segment = new THREE.Group();
    segment.name = `corridor_${id}`;

    // Store start and end points in userData for corridor connectivity
    segment.userData = {
      startPoint: start.clone(),
      endPoint: end.clone(),
      id: id,
    };

    // Calculate segment length and direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    direction.normalize();

    // Calculate segment orientation
    const horizontalDir = new THREE.Vector3(
      direction.x,
      0,
      direction.z
    ).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      horizontalDir
    );

    // Apply rotation to the segment
    segment.quaternion.copy(quaternion);
    segment.position.copy(start);

    // --- Geometry Adjustment for Junctions ---
    const junctionOffset = CORRIDOR_WIDTH / 2; // Reduced from CORRIDOR_WIDTH/1.5 to align with junction size
    const isStartJunction = this._isNearJunction(start);
    const isEndJunction = this._isNearJunction(end);

    let adjustedStart = 0;
    let adjustedEnd = 0;

    if (isStartJunction) {
        adjustedStart = junctionOffset;
        console.log(`Segment ${id}: Adjusting start by ${adjustedStart} units (junction detected)`);
    }
    if (isEndJunction) {
        adjustedEnd = junctionOffset;
        console.log(`Segment ${id}: Adjusting end by ${adjustedEnd} units (junction detected)`);
    }

    const effectiveLength = length - adjustedStart - adjustedEnd;
    // Calculate the Z position for the center of the *shortened* geometry
    // It starts at adjustedStart and extends for effectiveLength
    const geometryCenterZ = adjustedStart + effectiveLength / 2;

    // Ensure effectiveLength is positive before creating geometry
    if (effectiveLength <= 0) {
        console.warn(`Segment ${id} has zero or negative effective length after junction adjustment. Skipping geometry.`);
        // Add segment to scene and store reference (even if empty, for consistency)
        this.scene.add(segment);
        this.corridorSegments.set(id, segment);
        return segment; // Return early
    }

    // Get materials from the system
    const wallMaterial = this.materialSystem.getMaterial("wall");
    const floorMaterial = this.materialSystem.getMaterial("floor"); // Always use corridor floor
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const trimMaterial = this.materialSystem.getMaterial("trim");

    // Create and add components using helper methods, passing adjusted values
    const floor = this._createSegmentFloor(effectiveLength, floorMaterial);
    floor.position.z = geometryCenterZ; // Adjust position
    segment.add(floor);

    const ceiling = this._createSegmentCeiling(effectiveLength, ceilingMaterial);
    ceiling.position.z = geometryCenterZ; // Adjust position
    segment.add(ceiling);
    // Record corridor ceiling for indoors detection
    this.ceilingMeshes.push(ceiling);

    // Skip walls for key corridor segments we've unblocked:
    // - C5 -> C6 (starting main corridor)
    // - C6 -> C7 (main corridor beyond C6)
    // - C6 -> Perpetuity (MP)
    // - C6 -> Security wing and C6 -> Testing wing (crossing corridor)
    const skipWallSegmentIds = new Set([
      'C5_C6', 'C6_C7', 'C6_PERP1',
      'C6_J_SEC', 'C6_J_TEST',
      'J_SEC_SEC1', 'J_TEST_TEST1'
    ]);
    if (!skipWallSegmentIds.has(id)) {
      this._createSegmentWalls(effectiveLength, wallMaterial, segment, geometryCenterZ);
    }
    this._createSegmentTrim(effectiveLength, trimMaterial, segment, geometryCenterZ);

    // Add segment to scene and store reference
    this.scene.add(segment);
    this.corridorSegments.set(id, segment);

    return segment;
  }

  /**
   * Checks if a given position is close to any known junction point.
   * @param {THREE.Vector3} position The position to check.
   * @param {number} threshold Optional distance squared threshold.
   * @returns {boolean} True if the position is near a junction, false otherwise.
   * @private
   */
  _isNearJunction(position, threshold = 1.0) { // Increased from 0.1 to 1.0 for better junction detection
    if (!this.scene.userData.junctionPositions) {
      return false;
    }
    for (const junctionPos of this.scene.userData.junctionPositions) {
      if (position.distanceToSquared(junctionPos) < threshold) {
        return true;
      }
    }
    return false;
  }

  /**
   * Creates the floor for a corridor junction.
   * @param {number} junctionSize Size of the junction area.
   * @param {THREE.Material} floorMaterial Material for the floor.
   * @returns {THREE.Mesh} The floor mesh.
   * @private
   */
   _createJunctionFloor(junctionSize, floorMaterial) {
    const floorGeometry = new THREE.PlaneGeometry(junctionSize, junctionSize);
    // Always use corridor floor for junctions
    const mat = this.materialSystem.getMaterial("floor");
    const floor = new THREE.Mesh(floorGeometry, mat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0.01; // Slight offset to prevent z-fighting
    return floor;
   }

   /**
    * Creates the ceiling for a corridor junction.
    * @param {number} junctionSize Size of the junction area.
    * @param {THREE.Material} ceilingMaterial Material for the ceiling.
    * @returns {THREE.Mesh} The ceiling mesh.
    * @private
    */
   _createJunctionCeiling(junctionSize, ceilingMaterial) {
    const ceilingGeometry = new THREE.PlaneGeometry(junctionSize, junctionSize);
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = CORRIDOR_HEIGHT;
    return ceiling;
   }

   /**
    * Creates the ceiling light fixture for a corridor junction.
    * @param {number} junctionSize Size of the junction area.
    * @param {THREE.Material} lightMaterial Material for the light fixture.
    * @returns {THREE.Mesh} The light fixture mesh.
    * @private
    */
   _createJunctionLightFixture(junctionSize, lightMaterial) {
    const lightGeometry = new THREE.CircleGeometry(junctionSize / 4, 16);
    const lightFixture = new THREE.Mesh(lightGeometry, lightMaterial);
    lightFixture.rotation.x = Math.PI / 2;
    lightFixture.position.y = CORRIDOR_HEIGHT - 0.05;
    return lightFixture;
   }

   /**
    * Creates the floor marking for a corridor junction.
    * @param {string} id Identifier for the junction (used to generate text).
    * @returns {THREE.Mesh} The floor marking mesh.
    * @private
    */
   _createJunctionMarking(id) {
    // Extract the node ID and add a prefix based on type
    const nodeId = id.split("_")[1];
    let markingText = nodeId;
    
    // Add prefixes based on junction type
    if (nodeId.startsWith('C')) {
        markingText = 'MC' + nodeId.substring(1); // Main Corridor
    } else if (nodeId.startsWith('J_')) {
        markingText = 'JC' + nodeId.substring(2); // Junction Connector
    } else if (nodeId === 'ELV') {
        markingText = 'EL1'; // Elevator
    } else {
        markingText = 'RM' + nodeId.substring(0, 2); // Room/Area
    }
    
    const markingPosition = new THREE.Vector3(0, 0.01, 0);
    const markingScale = 0.4;
    return this.createFloorMarking(markingText, markingPosition, markingScale);
  }

  /**
   * Creates a corridor junction/intersection for visual interest at corridor connections
   * @param {THREE.Vector3} position Position of the junction
   * @param {string} id Identifier for the junction
   * @private
   */
  createCorridorJunction(position, id) {
    console.log(`Creating corridor junction ${id}`);

    const junction = new THREE.Group();
    junction.name = `junction_${id}`;
    junction.position.copy(position);

    // Store junction data for corridor connection checks
    junction.userData = {
      id: id,
      position: position.clone(),
      isJunction: true,
      radius: CORRIDOR_WIDTH * 1.8,
    };

    // Create a larger floor area for the junction
    const junctionSize = CORRIDOR_WIDTH * 1.0;
    const floorMaterial = this.materialSystem.getMaterial("floor");
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const lightMaterial = this.materialSystem.getMaterial("light");

    // Create and add components using helper methods
    const floor = this._createJunctionFloor(junctionSize, floorMaterial);
    junction.add(floor);

    const ceiling = this._createJunctionCeiling(junctionSize, ceilingMaterial);
    junction.add(ceiling);
    // Record junction ceiling for indoors detection
    this.ceilingMeshes.push(ceiling);

    const lightFixture = this._createJunctionLightFixture(junctionSize, lightMaterial);
    junction.add(lightFixture);

    // --- IMPROVED: Junction Wall System ---
    const junctionWallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    if (junctionWallMaterial.uniforms && junctionWallMaterial.uniforms.wallColor) {
      junctionWallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      junctionWallMaterial.needsUpdate = true;
    } else if (junctionWallMaterial.color) {
      junctionWallMaterial.color.setHex(0xffffff);
    }

    const wallThickness = 0.1;
    const wallHeight = CORRIDOR_HEIGHT;
    const halfSize = junctionSize / 2;
    
    // Determine which directions have corridor or room connections
    const nodeId = id.split("_")[1];
    const connections = {
      north: false,
      south: false,
      east: false,
      west: false
    };
    
    for (const edge of CORRIDOR_MAP.edges) {
      if (edge.from === nodeId || edge.to === nodeId) {
        const otherNodeId = edge.from === nodeId ? edge.to : edge.from;
        const otherNode = CORRIDOR_MAP.nodes.find(n => n.id === otherNodeId);
        const thisNode = CORRIDOR_MAP.nodes.find(n => n.id === nodeId);
        if (otherNode && thisNode) {
          const dx = otherNode.pos[0] - thisNode.pos[0];
          const dz = otherNode.pos[1] - thisNode.pos[1];
          if (Math.abs(dx) > Math.abs(dz)) {
            if (dx > 0) connections.east = true;
            else connections.west = true;
          } else {
            if (dz > 0) connections.south = true;
            else connections.north = true;
          }
        }
      }
    }
    
    // Also check for direct room connections (room nodes adjacent to this junction)
    const roomNodeIds = new Set(['MDR1', 'OD1', 'WELL1', 'BREAK1']);
    for (const roomNodeId of roomNodeIds) {
      const roomNode = CORRIDOR_MAP.nodes.find(n => n.id === roomNodeId);
      const thisNode = CORRIDOR_MAP.nodes.find(n => n.id === nodeId);
      if (roomNode && thisNode) {
        const dx = roomNode.pos[0] - thisNode.pos[0];
        const dz = roomNode.pos[1] - thisNode.pos[1];
        if (Math.abs(dx) > Math.abs(dz)) {
          if (dx > 0) connections.east = true;
          else if (dx < 0) connections.west = true;
        } else {
          if (dz > 0) connections.south = true;
          else if (dz < 0) connections.north = true;
        }
      }
    }

    console.log(`Junction ${nodeId} connections (corridor/room):`, connections);
    
    const wallLength = junctionSize;

    // Helper to create a full side wall
    const createSideWall = (posX, posZ, rotationY, dirName) => {
        const geom = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
        const wall = new THREE.Mesh(geom, junctionWallMaterial.clone());
        wall.position.set(posX, wallHeight / 2, posZ);
        wall.rotation.y = rotationY;
        junction.add(wall);
        this._addCollidableWall(wall);
        console.log(`Created wall for junction ${nodeId} at (${posX.toFixed(2)}, ${posZ.toFixed(2)}), rotation ${rotationY.toFixed(2)} [${dirName}]`);
    };

    // Only add walls where there is truly no corridor or room connection
    if (!connections.north) {
        // Special case: open MC5 (C5) to outside by skipping north wall
        if (nodeId === "C5") {
            console.log("Skipping north wall for MC5 (C5) to allow exit to outside.");
        } else {
            createSideWall(0, halfSize, Math.PI, 'north'); // North Wall (facing South)
        }
    }
    if (!connections.south) {
        createSideWall(0, -halfSize, 0, 'south');    // South Wall (facing North)
    }
    if (!connections.east) {
        createSideWall(halfSize, 0, -Math.PI / 2, 'east'); // East Wall (facing West)
    }
    if (!connections.west) {
        createSideWall(-halfSize, 0, Math.PI / 2, 'west');  // West Wall (facing East)
    }

    // Store junction position for corridor connectivity
    if (!this.scene.userData.junctionPositions) {
      this.scene.userData.junctionPositions = [];
    }
    this.scene.userData.junctionPositions.push(position.clone());

    this.scene.add(junction);
    return junction;
  }

  /**
   * Creates an elevator vestibule at the entrance of the corridor network
   * @param {THREE.Vector3} position Position of the elevator vestibule
   * @private
   */
  createElevatorVestibule(position) {
    console.log("Creating Elevator Vestibule at:", position);

    const vestibule = new THREE.Group();
    vestibule.name = "elevator_vestibule";
    vestibule.position.copy(position);

    const hallWidth = CORRIDOR_WIDTH * 1.5; // Make the hall slightly wider than corridor
    const hallDepth = SEGMENT_LENGTH * 0.5; // Depth of the hall area
    const hallHeight = CORRIDOR_HEIGHT;

    // --- Create Hall Geometry ---
    let wallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    const wallThickness = 0.1; // Define wall thickness
    // Clone, ensure DoubleSide, and force color via NEW uniform value if possible
    wallMaterial = wallMaterial.clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }

    // Back Wall (opposite elevator)
    const backWallGeometry = new THREE.BoxGeometry(hallWidth, hallHeight, wallThickness);
    const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
    backWall.position.y = hallHeight / 2;
    backWall.position.z = -hallDepth - wallThickness / 2; // Position at the back of the vestibule
    vestibule.add(backWall);
    this._addCollidableWall(backWall); // Add vestibule back wall

    // Add baseboard trim
    const trimGeometry = new THREE.BoxGeometry(
        hallWidth, // Use hallWidth
        CORRIDOR_TRIM_HEIGHT,
        0.05
    );
    const trimMaterial = this.materialSystem.getMaterial("trim");

    const trim = new THREE.Mesh(trimGeometry, trimMaterial);
    trim.position.set(0, CORRIDOR_TRIM_HEIGHT / 2, -0.025);

    // Add ceiling light
    const lightGeometry = new THREE.PlaneGeometry(hallWidth * 0.5, 0.4);
    const lightMaterial = this.materialSystem.getMaterial("light");

    const light = new THREE.Mesh(lightGeometry, lightMaterial);
    light.position.set(0, hallHeight - 0.05, -hallDepth / 2);
    light.rotation.x = Math.PI / 2;
    vestibule.add(light);

    // Add ceiling
    const ceilingGeometry = new THREE.PlaneGeometry(hallWidth, hallDepth);
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.set(0, hallHeight, -hallDepth / 2);
    vestibule.add(ceiling);
    
    // Add ceiling to ceilingMeshes for indoor detection
    this.ceilingMeshes.push(ceiling);

    // Create side walls using BoxGeometry
    const sideWallGeometry = new THREE.BoxGeometry(hallDepth, hallHeight, wallThickness);
    // Left vestibule wall
    const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
    leftWall.position.x = -hallWidth / 2 - wallThickness / 2;
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.y = hallHeight / 2;
    leftWall.position.z = -hallDepth / 2;
    vestibule.add(leftWall);
    this._addCollidableWall(leftWall);
    // Right vestibule wall
    const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
    rightWall.position.x = hallWidth / 2 + wallThickness / 2;
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.y = hallHeight / 2;
    rightWall.position.z = -hallDepth / 2;
    vestibule.add(rightWall);
    this._addCollidableWall(rightWall);

    this.scene.add(vestibule);
    return vestibule;
  }

  /**
   * Creates a wall-mounted detail (sign, artwork etc.)
   * @param {THREE.Vector3} position Position of the detail
   * @returns {THREE.Group} The wall detail object
   * @private
   */
  createWallMountedDetail(position) {
    const detail = new THREE.Group();
    detail.position.copy(position);

    // Choose detail type randomly - now only 2 options (was 3)
    const detailType = Math.floor(Math.random() * 2);

    if (detailType === 0) {
      // Framed artwork/certificate
      const frameGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.04);
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.5,
        metalness: 0.2,
      });

      const frame = new THREE.Mesh(frameGeometry, frameMaterial);
      detail.add(frame);

      // Add artwork/certificate inside frame
      const artGeometry = new THREE.PlaneGeometry(0.45, 0.65);
      const artMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9,
        metalness: 0.0,
      });

      const art = new THREE.Mesh(artGeometry, artMaterial);
      art.position.z = 0.021;
      detail.add(art);
    } else {
      // Small sign
      const signGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.02);
      const signMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.3,
        metalness: 0.7,
      });

      const sign = new THREE.Mesh(signGeometry, signMaterial);
      detail.add(sign);
    }

    return detail;
  }

  /**
   * Creates a floor marking (number or text)
   * @param {string|number} text Text or number to display
   * @param {THREE.Vector3} position Position of the marking
   * @param {number} scale Scale of the marking (default: 0.2)
   * @returns {THREE.Mesh} The floor marking mesh
   * @private
   */
  createFloorMarking(text, position, scale = 0.2) {
    const canvas = document.createElement("canvas");
    canvas.width = 128;
    canvas.height = 128;
    const context = canvas.getContext("2d");

    // Draw the text on canvas
    context.fillStyle = "#ffffff";
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = "#333333";
    context.font = "bold 80px Arial";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillText(text.toString(), canvas.width / 2, canvas.height / 2);

    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);

    // Create marking plane - use MeshLambertMaterial instead of MeshBasicMaterial
    // as it works better for floor markings without needing emissive properties
    const markingGeometry = new THREE.PlaneGeometry(scale, scale);
    const markingMaterial = new THREE.MeshLambertMaterial({
      map: texture,
      transparent: true,
      depthWrite: false,
    });

    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
    marking.position.copy(position);
    marking.rotation.x = -Math.PI / 2;

    return marking;
  }

  /**
   * Create a department door with frame and sign (non-blocking)
   * @param {Object} sectionConfig - Configuration for the portfolio section
   * @private
   */
  async createPortfolioSectionDoor(sectionConfig) {
    console.log(`[Door Creation] Creating portfolio section door for ${sectionConfig.name}...`);

    // Check if door models were loaded successfully
    if (!this.doorModels.doorFrame || !this.doorModels.doorPivot) {
        console.error(`[Door Creation] Door models not loaded for ${sectionConfig.name}. Skipping door creation.`);
        return null;
    }

    const doorGroup = new THREE.Group();
    doorGroup.name = `door_${sectionConfig.name}`;
    
    let doorFrameModel, doorPivotModel, cardReaderModel, doorPanelMesh, doorPivotContainer;

    // --- Door Frame --- 
    console.log(`[Door Creation] Using GLB frame model for ${sectionConfig.name}`);
    doorFrameModel = this.doorModels.doorFrame.clone();
    doorFrameModel.position.y = 0; // GLB origin at base
    doorGroup.add(doorFrameModel);
    
    // --- Door Pivot and Panel --- 
    console.log(`[Door Creation] Using GLB pivot/panel model for ${sectionConfig.name}`);
    doorPivotModel = this.doorModels.doorPivot.clone();
    doorPivotContainer = doorPivotModel; // Now doorPivotContainer is properly declared
    
    // Find the actual door panel mesh within the loaded model
    doorPivotModel.traverse(child => {
        if (child.isMesh && !doorPanelMesh) {
            doorPanelMesh = child;
            console.log(`[Door Creation] Found door panel mesh in GLB: ${child.name || 'Unnamed'}`);
        }
    });

    if (!doorPanelMesh) {
        console.error(`[Door Creation] Could not find mesh inside door pivot model for ${sectionConfig.name}!`);
        return null;
    }

    // Apply material to the door panel mesh
    let doorMaterial = this.materialSystem.getMaterial("door").clone();
    doorMaterial.transparent = true;
    doorMaterial.opacity = 1.0;
    doorMaterial.depthWrite = true;
    doorMaterial.side = THREE.DoubleSide;
    
    // Apply interior color tint if specified
    if (doorMaterial instanceof THREE.MeshStandardMaterial && sectionConfig.interiorColor) {
        const baseColor = doorMaterial.color.clone();
        const interiorColor = new THREE.Color(sectionConfig.interiorColor);
        doorMaterial.color.lerp(interiorColor, 0.2);
    }
    
    doorPanelMesh.material = doorMaterial;
    doorPanelMesh.userData.originalMaterial = doorMaterial;
    doorPanelMesh.userData.doorFrame = doorFrameModel;
    
    // --- Hinge Pivot Setup ---
    // Create a new Group to act as the actual pivot point (hinge)
    const hingePivot = new THREE.Group();
    // Position the hinge at the edge of the doorframe (where the physical hinges would be)
    hingePivot.position.x = -DOORWAY_WIDTH / 2; 
    // The door width value for positioning
    const doorWidth = DOORWAY_WIDTH;
    // Position door pivot model so it aligns with the frame while still rotating around the hinge
    doorPivotModel.position.x = doorWidth / 2; 
    // Add the door model container to the hinge
    hingePivot.add(doorPivotModel);
    // --- End Hinge Pivot Setup ---

    // Add the hinge pivot (which now contains the door model) to the main door group
    doorGroup.add(hingePivot); // Changed from doorPivotContainer
    console.log(`[Door Creation] Added HINGE container for ${sectionConfig.name} at local pos:`, hingePivot.position); // Log hinge position
    
    // Initialize door state - PIVOT IS NOW THE HINGE GROUP
    this.doorStates.set(sectionConfig.name, {
        isOpen: false,
        currentAngle: 0,
        targetAngle: 0,
        pivot: hingePivot, // Use the new hinge group as the pivot
        openDirection: this.DOOR_OPEN_DIRECTION
    });
    
    // Link state to the hinge pivot for potential future reference
    hingePivot.userData.doorState = this.doorStates.get(sectionConfig.name); 

    // --- Card Reader --- 
    if (this.doorModels.cardReader) {
        console.log(`[Door Creation] Using GLB card reader model for ${sectionConfig.name}`);
        cardReaderModel = this.doorModels.cardReader.clone();
        cardReaderModel.position.set(DOORWAY_WIDTH/2 + 0.15, 2.5/2, 0.1);
        doorGroup.add(cardReaderModel);
    }

    // Add indicator light
    const indicatorGeometry = new THREE.CircleGeometry(0.02, 8);
    const indicatorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x00ff00, 
        emissive: 0x00ff00, 
        emissiveIntensity: 0.5, 
        roughness: 0.3, 
        metalness: 0.2 
    });
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
    indicator.position.copy(cardReaderModel ? cardReaderModel.position : new THREE.Vector3(DOORWAY_WIDTH/2 + 0.15, 2.5/2, 0.1));
    indicator.position.y += 0.06;
    indicator.position.z += 0.03;
    doorGroup.add(indicator);

    // --- Sign --- 
    const signGeometry = new THREE.PlaneGeometry(DOORWAY_WIDTH - 0.2, 0.3);
    const canvas = document.createElement("canvas");
    canvas.width = 512;
    canvas.height = 128;
    const context = canvas.getContext("2d");
    context.fillStyle = "#000000";
    context.fillRect(0, 0, canvas.width, canvas.height);
    const mainText = sectionConfig.floorMarking || sectionConfig.name.toUpperCase().substring(0, 4);
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.font = "bold 72px Arial";
    context.fillStyle = "#FFFFFF";
    context.fillText(mainText, canvas.width/2, canvas.height/2 - 10);
    context.font = "bold 24px Arial";
    context.fillStyle = "#FFFFFF";
    context.fillText(sectionConfig.description || sectionConfig.name.replace("_", " "), canvas.width/2, canvas.height/2 + 35);
    const textTexture = new THREE.CanvasTexture(canvas);
    textTexture.anisotropy = 1;
    textTexture.needsUpdate = true;
    const signMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
    const sign = new THREE.Mesh(signGeometry, signMaterial);
    sign.position.y = 2.5 + 0.5;
    sign.position.z = 0.15;
    doorGroup.add(sign);
    const signLight = new THREE.PointLight(0xffffff, 2.0, 1.5);
    signLight.position.copy(sign.position);
    signLight.position.z += 0.2;
    doorGroup.add(signLight);

    // --- Add invisible interaction mesh in the doorway ---
    const interactionGeometry = new THREE.BoxGeometry(DOORWAY_WIDTH, 2.5, 0.3); // Doorway size
    const interactionMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const interactionMesh = new THREE.Mesh(interactionGeometry, interactionMaterial);
    interactionMesh.position.set(0, 2.5/2, 0); // Centered in the doorway
    interactionMesh.userData.doorName = sectionConfig.name;
    interactionMesh.userData.interactable = true;
    interactionMesh.name = sectionConfig.name + '_interaction';
    doorGroup.add(interactionMesh);
    // Store reference for getInteractableObjects
    if (!this._doorInteractionMeshes) this._doorInteractionMeshes = new Map();
    this._doorInteractionMeshes.set(sectionConfig.name, interactionMesh);

    // Set final position and rotation
    doorGroup.position.copy(sectionConfig.position);
    doorGroup.rotation.y = sectionConfig.rotation;
    this.scene.add(doorGroup);

    // Store references
    this.doors.set(sectionConfig.name, {
        doorGroup,
        frame: doorFrameModel,
        doorPanel: doorPanelMesh,
        doorPivot: hingePivot, // Store reference to the hinge pivot
        sign,
        cardReader: cardReaderModel,
        openDirection: this.DOOR_OPEN_DIRECTION,
    });

    // Add interactable object reference
    if (window.doorLocations) {
        doorPanelMesh.userData.interactable = true;
        doorPanelMesh.userData.doorName = sectionConfig.name;
        
        window.doorLocations.push({
            name: sectionConfig.name,
            position: sectionConfig.position.clone(),
            radius: 1.5,
            description: sectionConfig.description || sectionConfig.name.replace("_", " "),
            openDirection: this.DOOR_OPEN_DIRECTION,
            mesh: doorPanelMesh
        });
    }

    console.log(`[Door Creation] Successfully created door for ${sectionConfig.name}`);
    return doorGroup;
  }

  /**
   * Set up department locations and access points - REMOVED/TO BE REPLACED
   * @private
   */
  /*
  setupDepartments() {
      // ... Entire function content removed ...
  }
  */ // KEEPING THE FUNCTION SIGNATURE AS A REMINDER TO ADD PORTFOLIO SETUP LATER

  // --- Portfolio Section Configuration ---
  portfolioSectionsConfig = {
      DESIGN: {
        nodeId: "MDR1",
        name: "Interaction_Design",
        description: "UX/UI & Interaction Projects",
        rotation: -Math.PI / 2, // Changed from Math.PI / 2 to face corridor
        size: new THREE.Vector3(12, 4, 12),
        interiorColor: 0x4285f4,
        material: "default",
        floorMarking: "DESIGN",
        interiorType: "DESIGN",
        doorOffset: new THREE.Vector3(0, 0, 0) // Changed from (0,0,-1.5)
      },
      DEV: {
        nodeId: "OD1",
        name: "Development",
        description: "Code & Software Projects",
        rotation: Math.PI / 2,
        size: new THREE.Vector3(15, 4, 10),
        interiorColor: 0x34a853,
        material: "default",
        floorMarking: "CODE",
        interiorType: "DEV",
        doorOffset: new THREE.Vector3(0, 0, 0)
      },
      FILM: {
        nodeId: "WELL1",
        name: "Film_Cinema",
        description: "Filmmaking & Cinematography",
        rotation: -Math.PI / 2, // Keep facing -X (towards corridor)
        size: new THREE.Vector3(10, 4, 15),
        interiorColor: 0xfbbc05,
        material: "default",
        floorMarking: "FILM",
        interiorType: "FILM",
        doorOffset: new THREE.Vector3(-0.5, 0, 0) // Slight offset towards corridor for better connection
      },
      ART: {
        nodeId: "BREAK1",
        name: "Performance_Art",
        description: "Performance Pieces & Documentation",
        rotation: Math.PI / 2,
        size: new THREE.Vector3(10, 4, 10),
        interiorColor: 0xea4335,
        material: "default",
        floorMarking: "ART",
        interiorType: "ART",
        doorOffset: new THREE.Vector3(0, 0, 0) // Match Film_Cinema door position
      },
  };

  /**
   * Calculates the appropriate door position offset from an anchor node.
   * @param {THREE.Vector3} position Anchor node position.
   * @param {number} rotation Intended door rotation.
   * @returns {THREE.Vector3} Calculated door position.
   * @private
   */
  _calculateDoorPosition(position, rotation, config) {
    const doorPosition = position.clone();
    const doorOffsetDistance = CORRIDOR_WIDTH / 2 + 0.1; // Place slightly outside corridor

    // Apply any custom door offset if specified in the config
    if (config && config.doorOffset) {
      doorPosition.add(config.doorOffset);
    }

    // Determine offset based on rotation (simplified logic)
    if (Math.abs(rotation) < 0.1) { // Rotation 0 (Facing +Z)
      doorPosition.z += doorOffsetDistance;
    } else if (Math.abs(rotation - Math.PI) < 0.1) { // Rotation PI (Facing -Z)
      doorPosition.z -= doorOffsetDistance;
    } else if (Math.abs(rotation - Math.PI / 2) < 0.1) { // Rotation PI/2 (Facing +X)
      doorPosition.x += doorOffsetDistance;
    } else if (Math.abs(rotation + Math.PI / 2) < 0.1) { // Rotation -PI/2 (Facing -X)
      doorPosition.x -= doorOffsetDistance;
    }
    return doorPosition;
  }

  /**
   * Helper to get world position from map node ID.
   * @param {string} nodeId The ID of the node in CORRIDOR_MAP.
   * @returns {THREE.Vector3 | null} The world position or null if not found.
   * @private
   */
  _getNodeWorldPosition(nodeId) {
      const node = CORRIDOR_MAP.nodes.find((n) => n.id === nodeId);
      if (!node) {
        console.error(`Node ${nodeId} not found in CORRIDOR_MAP`);
        return null;
      }
      return new THREE.Vector3(
        node.pos[0] * SEGMENT_LENGTH,
        0,
        -node.pos[1] * SEGMENT_LENGTH // Negative Z extends away from elevator
      );
  }


  /**
   * Sets up the portfolio sections, defining their locations and properties.
   * This replaces the old setupDepartments method.
   * @private
   */
  setupPortfolioSections() {
    console.log("Setting up Portfolio Sections...");

    // Create geometry and doors for each section defined in config
    for (const config of Object.values(this.portfolioSectionsConfig)) {
      const anchorPosition = this._getNodeWorldPosition(config.nodeId);
      if (!anchorPosition) {
        console.warn(`Skipping section ${config.name} due to missing node position for ${config.nodeId}.`);
        continue;
      }

      console.log(`Setting up portfolio section: ${config.name} at node ${config.nodeId}`);

      // Define bounds (assuming anchorPosition is the center for now)
      const halfSize = config.size.clone().multiplyScalar(0.5);
      const bounds = new THREE.Box3(
        anchorPosition.clone().sub(halfSize),
        anchorPosition.clone().add(halfSize)
      );
      bounds.min.y = 0;
      bounds.max.y = config.size.y;

      const sectionData = {
        ...config,
        position: anchorPosition,
        bounds: bounds,
      };

      // Add section to map system if available
      const mapSystem = this.systems.get("map");
      if (mapSystem && mapSystem.defineZone) {
        mapSystem.defineZone(sectionData.name, sectionData.bounds, config.interiorColor || '#ffffff');
      }

      // --- Door positioning using junction-based approach for all doors ---
      let doorPosition;
      
      // Get the junction related to this section
      const junctionMapping = {
        "Interaction_Design": "J_MDR",
        "Development": "J_OD",
        "Film_Cinema": "J_WELL",
        "Performance_Art": "J_BREAK"
      };
      
      const junctionNodeId = junctionMapping[config.name];
      if (junctionNodeId) {
        console.log(`[Door Positioning] Calculating ${config.name} door position based on ${junctionNodeId}.`);
        const junctionPosition = this._getNodeWorldPosition(junctionNodeId);
        
        if (junctionPosition) {
          // Position door near the junction, facing the corridor
          doorPosition = junctionPosition.clone();
          
          // Apply appropriate offset based on the door's rotation
          if (Math.abs(config.rotation - Math.PI / 2) < 0.1) { // Facing +X
            doorPosition.x += CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation + Math.PI / 2) < 0.1) { // Facing -X
            doorPosition.x -= CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation) < 0.1) { // Facing +Z
            doorPosition.z += CORRIDOR_WIDTH / 2;
          } else if (Math.abs(config.rotation - Math.PI) < 0.1) { // Facing -Z
            doorPosition.z -= CORRIDOR_WIDTH / 2;
          }
          
          console.log(`[Door Positioning] Calculated ${config.name} door position: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)}) based on ${junctionNodeId}.`);
          
          // Add a small outward offset for all doors calculated this way
          // This helps prevent clipping with potentially misaligned corridor ends
          const outwardOffset = 0.1; // Offset distance - Using a slightly larger offset for better visibility
          if (Math.abs(config.rotation - Math.PI / 2) < 0.1) { // Facing +X
            doorPosition.x += outwardOffset;
          } else if (Math.abs(config.rotation + Math.PI / 2) < 0.1) { // Facing -X
            doorPosition.x -= outwardOffset;
          } else if (Math.abs(config.rotation) < 0.1) { // Facing +Z
            doorPosition.z += outwardOffset;
          } else if (Math.abs(config.rotation - Math.PI) < 0.1) { // Facing -Z
            doorPosition.z -= outwardOffset;
          }
          console.log(`[Door Positioning] Applied outward offset (${outwardOffset}), new pos: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);

        } else {
          console.warn(`[Door Positioning] Could not find junction ${junctionNodeId} for ${config.name} door placement. Falling back.`);
          // Fallback to original calculation if junction not found
          doorPosition = this._calculateDoorPosition(anchorPosition, config.rotation, config);
        }
      } else {
        // Default calculation for doors without junction mapping
        doorPosition = this._calculateDoorPosition(anchorPosition, config.rotation, config);
      }
      // --------------------------------------------------

      this.createPortfolioSectionDoor({ ...sectionData, position: doorPosition });

      // Create interior space
      // Pass the calculated doorPosition to interior creation for wall checking
      this.createPortfolioSectionInteriors(sectionData.name, anchorPosition, sectionData.size, sectionData.interiorType, doorPosition);

      // --- Create tunnel from main corridor to door ---
      // Find the nearest corridor wall point to the door
      const nearestCorridorWall = this._findNearestCorridorWallPoint(doorPosition);
      if (nearestCorridorWall) {
        // Use the same width and height as the door/vestibule
        this._createCorridorToDoorTunnel(nearestCorridorWall.point, doorPosition, 1.2, CORRIDOR_HEIGHT);
      }

      // --- Create vestibule wall connecting door to room doorway ---
      // Find the doorway position (project door position onto room wall plane)
      // Use the same logic as in _createSectionWalls to find the wall and doorway center
      const doorwayWidth = 1.2;
      const wallHeight = config.size.y;
      // Find which wall is closest to the door
      const halfSizeX = config.size.x / 2;
      const halfSizeZ = config.size.z / 2;
      const wallPositions = [
        { name: 'back',  position: new THREE.Vector3(anchorPosition.x, anchorPosition.y + wallHeight / 2, anchorPosition.z + halfSizeZ), length: config.size.x, axis: 'x', rotationY: 0 },
        { name: 'front', position: new THREE.Vector3(anchorPosition.x, anchorPosition.y + wallHeight / 2, anchorPosition.z - halfSizeZ), length: config.size.x, axis: 'x', rotationY: Math.PI },
        { name: 'left',  position: new THREE.Vector3(anchorPosition.x - halfSizeX, anchorPosition.y + wallHeight / 2, anchorPosition.z), length: config.size.z, axis: 'z', rotationY: Math.PI / 2 },
        { name: 'right', position: new THREE.Vector3(anchorPosition.x + halfSizeX, anchorPosition.y + wallHeight / 2, anchorPosition.z), length: config.size.z, axis: 'z', rotationY: -Math.PI / 2 }
      ];
      let minDist = Infinity;
      let doorWall = null;
      wallPositions.forEach((wallData) => {
        const dist = wallData.position.distanceTo(doorPosition);
        if (dist < minDist) {
          minDist = dist;
          doorWall = wallData;
        }
      });
      // Project door position onto wall axis to get doorway center
      let doorwayCenter = doorWall.position.clone();
      if (doorWall.axis === 'x') {
        doorwayCenter.x = doorPosition.x;
      } else {
        doorwayCenter.z = doorPosition.z;
      }
      // The vestibule wall runs from doorPosition to doorwayCenter
      this._createDoorVestibuleWall(doorPosition, doorwayCenter, doorwayWidth, wallHeight, doorWall.rotationY);

      // Add floor markings at the anchor node position
      // const markingPosition = anchorPosition.clone();
      // markingPosition.y = 0.015;
      // const floorMarking = this.createFloorMarking(
      //   sectionData.floorMarking || sectionData.name.substring(0, 3),
      //   markingPosition,
      //   0.8
      // );
      // this.scene.add(floorMarking);
    }

    console.log("Portfolio Sections setup completed");
    
    // Add door frames after sections are created
    this.createDoorFrameWalls();
  }

  /**
   * Creates a vestibule wall connecting the corridor door to the room's doorway.
   * @param {THREE.Vector3} doorPos - Position of the door (corridor side)
   * @param {THREE.Vector3} doorwayPos - Position of the doorway (room wall)
   * @param {number} width - Width of the doorway/vestibule
   * @param {number} height - Height of the wall
   * @param {number} rotationY - Y rotation of the wall
   */
  _createDoorVestibuleWall(doorPos, doorwayPos, width, height, rotationY) {
    const depth = doorPos.distanceTo(doorwayPos);
    if (depth < 0.05) return; // No need if already touching
    const wallThickness = 0.12; // Thickness for side walls and ceiling
    // Clamp the tunnel height to a maximum of 2.5 (door height)
    const ceilingHeight = height; // Place ceiling at top of wall
    // Widen tunnel to fit both corridor and room wall, plus a small overlap to prevent leaks
    const vestibuleWidth = Math.max(width, CORRIDOR_WIDTH) + 0.15;
    // Calculate direction vector from door to doorway
    const dir = new THREE.Vector3().subVectors(doorwayPos, doorPos).normalize();
    // Midpoint for center reference
    const mid = new THREE.Vector3().addVectors(doorPos, doorwayPos).multiplyScalar(0.5);
    // Find right vector (perpendicular to dir, in XZ plane)
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(dir, up).normalize();
    // --- Ceiling ---
    const ceilingGeom = new THREE.BoxGeometry(vestibuleWidth, wallThickness, depth);
    const wallMaterial = this.materialSystem.getMaterial("wall").clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }
    const ceiling = new THREE.Mesh(ceilingGeom, wallMaterial.clone());
    // Place ceiling at top
    ceiling.position.copy(mid);
    ceiling.position.y = doorPos.y + ceilingHeight - wallThickness/2;
    // Orient ceiling to connect the two points
    ceiling.lookAt(doorwayPos.x, ceiling.position.y, doorwayPos.z);
    ceiling.rotation.y = rotationY;
    this.scene.add(ceiling);
    this._addCollidableWall(ceiling);
    // Add ceiling to ceilingMeshes for rain/snow occlusion
    this.ceilingMeshes.push(ceiling);
    // --- Side Walls ---
    const sideGeom = new THREE.BoxGeometry(wallThickness, ceilingHeight, depth);
    // Left wall
    const leftWall = new THREE.Mesh(sideGeom, wallMaterial.clone());
    leftWall.position.copy(mid);
    leftWall.position.add(right.clone().multiplyScalar(-(vestibuleWidth/2 - wallThickness/2)));
    leftWall.position.y = doorPos.y + ceilingHeight/2;
    leftWall.lookAt(doorwayPos.x, leftWall.position.y, doorwayPos.z);
    leftWall.rotation.y = rotationY;
    this.scene.add(leftWall);
    this._addCollidableWall(leftWall);
    // Right wall
    const rightWallMesh = new THREE.Mesh(sideGeom, wallMaterial.clone());
    rightWallMesh.position.copy(mid);
    rightWallMesh.position.add(right.clone().multiplyScalar((vestibuleWidth/2 - wallThickness/2)));
    rightWallMesh.position.y = doorPos.y + ceilingHeight/2;
    rightWallMesh.lookAt(doorwayPos.x, rightWallMesh.position.y, doorwayPos.z);
    rightWallMesh.rotation.y = rotationY;
    this.scene.add(rightWallMesh);
    this._addCollidableWall(rightWallMesh);
    // Log
    console.log(`[Vestibule] Created tunnel (ceiling + wider sides) from door to room at (${mid.x.toFixed(2)}, ${mid.y.toFixed(2)}, ${mid.z.toFixed(2)})`);
  }

  /**
   * Find the nearest junction to a position
   * @param {THREE.Vector3} position The position to check
   * @returns {THREE.Vector3|null} The nearest junction position or null
   * @private
   */
  findNearestJunction(position) {
    let nearestJunction = null;
    let nearestDistance = Infinity;

    // Find all junctions in the scene
    const junctions = this.scene.children.filter(
      (child) => child.name && child.name.startsWith("junction_")
    );

    // Find the nearest junction
    junctions.forEach((junction) => {
      const distance = position.distanceTo(junction.position);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearestJunction = junction.position;
      }
    });

    return nearestJunction ? nearestJunction.clone() : null;
  }

  /**
   * Set up the lighting system to match Severance's clinical aesthetic
   * @private
   */
  async setupLighting() {
    console.log("[Environment] Setting up lighting...");

    // Create ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambientLight);
    
    // Create directional light for subtle shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(50, 50, 50);
    this.scene.add(directionalLight);
    
    // Add the global point light
    const globalLight = new THREE.PointLight(0xffffff, 0.5);
    globalLight.position.set(0, 20, 0);
    this.scene.add(globalLight);
    
    // Add special bright doorway lights with no falloff to ensure interior visibility
    if (window.doorLocations) {
      for (const doorLocation of window.doorLocations) {
        if (!doorLocation.position) continue;
        
        // Create super bright light at doorway
        const doorwayLight = new THREE.PointLight(0xffffff, 5.0, 0); // No distance falloff
        doorwayLight.position.copy(doorLocation.position);
        doorwayLight.position.y += 1.8; // Head height
        
        this.scene.add(doorwayLight);
        console.log(`[Lighting] Added super bright light at doorway: ${doorLocation.name}`);
      }
    }

    // Set up corridor lighting
    this._setupCorridorLighting();

    console.log("[Environment] Lighting setup complete.");
  }

  /**
   * Set up corridor lighting
   * @private
   */
  _setupCorridorLighting() {
    // Create fluorescent panel lights - the iconic ceiling fixtures from the show
    const lightMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xf7faff, // Slightly bluish tint for the Severance look
      emissiveIntensity: 0.9,
      roughness: 0.2,
      metalness: 0.1,
    });
    
    // Store lights for flickering effects
    this.assets.lights.set("fluorescents", new THREE.Group());

    // Add subtle directional light for minimal shadowing
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
    directionalLight.position.set(0, 1, 0);
    directionalLight.castShadow = false;
    this.scene.add(directionalLight);
    
    console.log("[Environment] Corridor lighting set up");
  }

  /**
   * Update the environment state
   * @override
   */
  update(deltaTime) {
    // Ensure deltaTime is always a valid positive number
    if (typeof deltaTime !== "number" || !isFinite(deltaTime) || deltaTime <= 0) {
      deltaTime = this.clock.getDelta();
    }
    super.update(deltaTime);
    
    // Update post-processing effects
    this.updatePostProcessing(deltaTime);
    
    // Update door animations with debug logging
    console.log(`[Door Animation] Updating animations for ${this.doorStates.size} doors`);
    this.updateDoorAnimations(deltaTime);

    // Get player position for systems that need it
    const playerPosition = this.camera ? this.camera.position.clone() : null;

    // Update all systems
    for (const [name, system] of this.systems) {
      if (system.update) {
        system.update(deltaTime);
      }
    }

    // Update lighting effects
    this.updateLighting(deltaTime);

    // Update art room animations if they exist
    if (this._artRoomAnimations) {
      for (const animation of this._artRoomAnimations) {
        animation(deltaTime);
      }
    }
    
    // --- Tim Rodenbroeker Style: Update animated objects ---
    if (this._animatedObjects && this._animatedObjects.size > 0) {
      const time = this.clock ? this.clock.getElapsedTime() : performance.now() * 0.001;
      
      this._animatedObjects.forEach((data, id) => {
        const obj = data.object;
        if (!obj) return;
        
        // Animate accent light spheres
        if (id.startsWith('sphere_')) {
          // Simple bobbing motion
          obj.position.y = data.startY + Math.sin(time * data.speed + data.phase) * data.amplitude;
        }
        
        // Animate node particles
        if (id.startsWith('node_')) {
          // Orbital motion around center
          const angle = time * data.speed + data.phase;
          obj.position.x = data.centerX * Math.cos(angle);
          obj.position.z = data.centerZ * Math.sin(angle);
          
          // Vertical motion
          obj.position.y = Math.sin(angle * data.verticalFrequency) * data.verticalAmplitude;
        }
      });
    }
    
    // --- Update terminal screen with generative pattern ---
    if (this._terminalCanvas && this._terminalTexture) {
      const now = performance.now();
      if (!this._terminalLastUpdate || now - this._terminalLastUpdate > this._terminalUpdateInterval) {
        // Get the context and update the pattern
        const ctx = this._terminalCanvas.getContext('2d');
        
        // Clear the canvas instead of filling with black
        ctx.clearRect(0, 0, this._terminalCanvas.width, this._terminalCanvas.height);
        ctx.font = '16px monospace';
        ctx.fillStyle = '#33ff33'; // Bright green text
        ctx.textAlign = 'left';
        
        // Keep only the code-like text overlay
        const time = this.clock ? this.clock.getElapsedTime() * 0.5 : now * 0.0005;
        const timeOffset = Math.floor(time * 3) % 10;
        
        const codeLines = [
          `0${timeOffset} function initCreativeNodes() {`,
          `0${(timeOffset+1)%10}   const nodes = setupNodeNetwork();`,
          `0${(timeOffset+2)%10}   const connections = calculatePaths(nodes);`,
          `0${(timeOffset+3)%10}   renderNetwork(nodes, connections);`,
          `0${(timeOffset+4)%10}   runSimulation();`,
          `0${(timeOffset+5)%10} }`,
          '',
          `0${(timeOffset+6)%10} function updateNetwork(deltaTime) {`,
          `0${(timeOffset+7)%10}   nodes.forEach(node => {`,
          `0${(timeOffset+8)%10}     node.phase += node.speed * deltaTime;`,
          `0${(timeOffset+9)%10}     node.position.y = Math.sin(node.phase) * node.amplitude;`,
          `${timeOffset+10}   });`,
          `${timeOffset+11} }`,
          '',
          `${timeOffset+12} // Tim Rodenbroeker inspired generative art - Removed`,
          `${timeOffset+13} function createGenerativePattern() {`
        ];
        
        let y = 60;
        codeLines.forEach(line => {
          ctx.fillText(line, 40, y);
          y += 24;
        });
        
        // Update the texture
        this._terminalTexture.needsUpdate = true;
        this._terminalLastUpdate = now;
      }
    }

    // Manually update wall material time uniform if needed
    if (
      this.wallMaterial &&
      this.wallMaterial instanceof THREE.ShaderMaterial
    ) {
      if (this.wallMaterial.uniforms && this.wallMaterial.uniforms.time) {
        this.wallMaterial.uniforms.time.value += deltaTime;
      }

      // Ensure walls maintain clinical white appearance at all times
      if (this.wallMaterial.uniforms && this.wallMaterial.uniforms.wallColor) {
        // Keep the bright clinically white color
        this.wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      }
    }

    // Update materials (including time uniform)
    if (this.materialSystem && this.materialSystem.update) {
      // Get the player position
      let playerPos = this.camera && this.camera.position ? this.camera.position : new THREE.Vector3(0,0,0);
      if (this.movementController && this.movementController.position) {
        playerPos = this.movementController.position;
      }
      // Pass both deltaTime and player position
      this.materialSystem.update(deltaTime, playerPos);
    }

    // Update movement controller if it exists
    if (this.movementController) {
      this.movementController.update(deltaTime);
    }

    // Update weather state
    this.updateWeather(deltaTime);

    // Update interactive buttons to face camera
    this.updateInteractionButtons(this.camera);

    // Dynamically update global floor material if player moves between inside/outside
    if (this.globalFloor && this.isPlayerOutdoors && typeof this.isPlayerOutdoors === 'function') {
      const shouldBeOutside = this.isPlayerOutdoors();
      const desiredMaterial = shouldBeOutside
        ? this.materialSystem.getMaterial("outsideGround")
        : this.materialSystem.getMaterial("floor");
      if (this.globalFloor.material !== desiredMaterial) {
        this.globalFloor.material = desiredMaterial;
        this.globalFloor.material.needsUpdate = true;
      }
    }

    // Animate creative node networks in DEV/CODE room
    if (this._devNodeNetworks && Array.isArray(this._devNodeNetworks)) {
      const t = this.clock ? this.clock.getElapsedTime() : performance.now() * 0.001;
      for (const group of this._devNodeNetworks) {
        if (group.userData && typeof group.userData.animate === 'function') {
          group.userData.animate(t);
        }
      }
    }
  }

  /**
   * Update lighting effects
   * @private
   */
  updateLighting(deltaTime) {
    if (this.emergencyLighting) {
      this.lightFlickerIntensity = Math.random() * 0.4 + 0.6;
      const lights = this.assets.lights.get("fluorescents");
      if (lights) {
        lights.children.forEach((light) => {
          light.intensity = this.lightFlickerIntensity;
        });
      }
    }
  }

  /**
   * Set player position and rotation
   * @param {THREE.Vector3} position - New player position
   * @param {THREE.Euler} rotation - New player rotation
   */
  setPlayerPosition(position, rotation) {
    if (this.camera) {
      this.camera.position.copy(position);
      this.camera.rotation.copy(rotation);
    }
    // Also update the movement controller's internal state
    if (this.movementController) {
      this.movementController.position.copy(position);
      this.movementController.rotation.copy(rotation);
      // Optionally update global references if still needed
      window.playerPosition = this.movementController.position;
      window.playerRotation = this.movementController.rotation.y;
      window.cameraPitch = this.movementController.rotation.x;
    }
  }

  /**
   * Get the current player location
   * @returns {string} The current department or corridor name
   */
  getCurrentLocation() {
    if (!this.camera) return "Unknown";

    // Check if in any department - REMOVED departmentBounds check
    /*
    for (const [name, bounds] of this.departmentBounds) {
      if (bounds.containsPoint(this.camera.position)) {
        return name;
      }
    }
    */

    // TODO: Implement logic to detect which portfolio section the player is in,
    // potentially based on proximity to section entrances or defined zones.
    // For now, just return "CORRIDOR".

    // If not in a department, must be in a corridor
    return "CORRIDOR";
  }

  /**
   * Get current segment based on player position
   * @returns {Object} Segment information
   */
  getCurrentSegment() {
    // Get player position
    const position = this.camera.position;

    // Find closest corridor segment
    let closestSegment = null;
    let closestDistance = Infinity;

    for (const [id, segment] of this.corridorSegments) {
      // Calculate distance to segment
      const segmentWorldPos = new THREE.Vector3();
      segment.getWorldPosition(segmentWorldPos);
      const distance = position.distanceTo(segmentWorldPos);

      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = { id, segment };
      }
    }

    // Get department information - REMOVED departmentBounds check
    /*
    for (const [deptName, bounds] of this.departmentBounds) {
      if (bounds.containsPoint(position)) {
        return {
          department: deptName.toLowerCase(),
          position: position.clone(),
        };
      }
    }
    */

    // TODO: Adapt this to return portfolio section info later.
    // For now, it primarily returns corridor info based on segments.

    // Return corridor segment info if found
    if (closestSegment) {
      const segmentId = closestSegment.id;
      // Extract department from segment ID (e.g., "mdr_hallway" -> "mdr")
      const department = segmentId.includes("_")
        ? segmentId.split("_")[0]
        : "corridor";

      return {
        department: department,
        position: position.clone(),
      };
    }

    return { department: "unknown", position: position.clone() };
  }

  /**
   * Toggle emergency lighting mode
   * @param {boolean} enabled - Whether to enable emergency lighting
   */
  setEmergencyLighting(enabled) {
    this.emergencyLighting = enabled;

    // Update all lights
    this.assets.lights.forEach((light) => {
      if (light instanceof THREE.Group) {
        light.children.forEach((child) => {
          if (child instanceof THREE.Light) {
            child.intensity = enabled ? 0.1 : 1.0;
          }
        });
      } else if (light instanceof THREE.Light) {
        light.intensity = enabled ? 0.1 : 1.0;
      }
    });
  }

  /**
   * Clean up resources
   * @override
   */
  dispose() {
    super.dispose();

    // Clean up systems
    for (const system of this.systems.values()) {
      if (system.dispose) {
        system.dispose();
      }
    }

    // Clear references
    this.systems.clear();
    this.doors.clear();
    this.interactiveObjects.clear();
    // REMOVED: this.departmentBounds.clear();
    this.corridorSegments.clear();
    this.wayfinding.clear(); // Clear wayfinding elements

    // Don't dispose movement controller here as it's managed by main.js

    // Clear global references
    window.doorLocations = [];
  }

  /**
   * Creates the interior walls for a standard rectangular portfolio section.
   * Adds the walls to the collidable mesh list.
   * @param {THREE.Vector3} center Center position of the section.
   * @param {THREE.Vector3} size Size of the section (x, y, z).
   * @param {THREE.Material} wallMaterial The material to use for the walls.
   * @param {THREE.Group} parentGroup The group to add the walls to.
   * @param {THREE.Vector3} doorPosition The position of the door for this section.
   * @private
   */
  _createSectionWalls(center, size, wallMaterial, parentGroup, doorPosition) {
      const halfSizeX = size.x / 2;
      const halfSizeZ = size.z / 2;
      const wallHeight = size.y;
      const doorwayWidth = DOORWAY_WIDTH; // Use the constant for consistency
      const sectionWallMaterial = wallMaterial.clone();
      if (sectionWallMaterial.uniforms && sectionWallMaterial.uniforms.wallColor) {
        sectionWallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
        sectionWallMaterial.needsUpdate = true;
      } else if (sectionWallMaterial.color) {
        sectionWallMaterial.color.setHex(0xffffff);
      }

      // Define potential wall positions and orientations
      const wallPositions = [
          { name: 'back',  position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z + halfSizeZ), length: size.x, axis: 'x', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: 0 },
          { name: 'front', position: new THREE.Vector3(center.x, center.y + wallHeight / 2, center.z - halfSizeZ), length: size.x, axis: 'x', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: Math.PI },
          { name: 'left',  position: new THREE.Vector3(center.x - halfSizeX, center.y + wallHeight / 2, center.z), length: size.z, axis: 'z', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: Math.PI / 2 },
          { name: 'right', position: new THREE.Vector3(center.x + halfSizeX, center.y + wallHeight / 2, center.z), length: size.z, axis: 'z', geometry: (len) => new THREE.BoxGeometry(len, wallHeight, 0.1), rotationY: -Math.PI / 2 }
      ];

      // Find the wall closest to the door
      let minDist = Infinity;
      let doorWallIdx = -1;
      wallPositions.forEach((wallData, idx) => {
        const dist = wallData.position.distanceTo(doorPosition);
        if (dist < minDist) {
          minDist = dist;
          doorWallIdx = idx;
        }
      });

      wallPositions.forEach((wallData, idx) => {
        if (idx === doorWallIdx) {
          // This is the wall with the doorway
          // Project door position onto wall axis
          let doorCoord, wallCenterCoord, halfLen;
          if (wallData.axis === 'x') {
            doorCoord = doorPosition.x;
            wallCenterCoord = wallData.position.x;
            halfLen = wallData.length / 2;
          } else {
            doorCoord = doorPosition.z;
            wallCenterCoord = wallData.position.z;
            halfLen = wallData.length / 2;
          }
          // Compute left and right segment lengths
          const leftLen = Math.max(0, (doorCoord - doorwayWidth/2) - (wallCenterCoord - halfLen));
          const rightLen = Math.max(0, (wallCenterCoord + halfLen) - (doorCoord + doorwayWidth/2));
          // Left segment
          if (leftLen > 0.05) {
            const leftGeom = wallData.geometry(leftLen);
            const leftMesh = new THREE.Mesh(leftGeom, sectionWallMaterial.clone());
            // Position left segment
            if (wallData.axis === 'x') {
              leftMesh.position.set(
                wallCenterCoord - halfLen + leftLen/2,
                wallData.position.y,
                wallData.position.z
              );
            } else {
              leftMesh.position.set(
                wallData.position.x,
                wallData.position.y,
                wallCenterCoord - halfLen + leftLen/2
              );
            }
            leftMesh.rotation.y = wallData.rotationY;
            parentGroup.add(leftMesh);
            this._addCollidableWall(leftMesh);
          }
          // Right segment
          if (rightLen > 0.05) {
            const rightGeom = wallData.geometry(rightLen);
            const rightMesh = new THREE.Mesh(rightGeom, sectionWallMaterial.clone());
            // Position right segment
            if (wallData.axis === 'x') {
              rightMesh.position.set(
                wallCenterCoord + halfLen - rightLen/2,
                wallData.position.y,
                wallData.position.z
              );
            } else {
              rightMesh.position.set(
                wallData.position.x,
                wallData.position.y,
                wallCenterCoord + halfLen - rightLen/2
              );
            }
            rightMesh.rotation.y = wallData.rotationY;
            parentGroup.add(rightMesh);
            this._addCollidableWall(rightMesh);
          }
          // Log
          console.log(`[Section Walls] Created doorway in wall '${wallData.name}' for section ${parentGroup.name}`);
        } else {
          // Normal wall
          const wall = new THREE.Mesh(wallData.geometry(wallData.length), sectionWallMaterial.clone());
              // Adjust position slightly based on thickness and rotation to align outer face
              const offset = new THREE.Vector3(0, 0, 0.05).applyAxisAngle(new THREE.Vector3(0, 1, 0), wallData.rotationY);
              wall.position.copy(wallData.position).add(offset);
              wall.rotation.y = wallData.rotationY;
              parentGroup.add(wall);
              this._addCollidableWall(wall);
              console.log(`[Section Walls] Created wall '${wallData.name}' for section ${parentGroup.name}`);
          }
      });
  }

  /**
   * Creates a basic placeholder interior for a section.
   * @param {THREE.Group} interiorGroup The group to add the placeholder to.
   * @param {THREE.Vector3} center Center position.
   * @param {THREE.Vector3} size Size of the section.
   * @param {THREE.Vector3} doorPosition Position of the door for lighting.
   * @private
   */
  _createPlaceholderInterior(interiorGroup, center, size, doorPosition) {
    // --- Add door entrance lighting if doorPosition is provided ---
    if (doorPosition) {
      // Create vector from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Create a special white light at the entryway
      const entryLight = new THREE.SpotLight(0xffffff, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0))); // Above the door
      
      // Point the spotlight into the room
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // FIX: Add more visible elements to interior
    
    // Create a general interior light
    const interiorLight = new THREE.PointLight(0xffffff, 1.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // Add some ceiling lights
    const ceilingLightCount = 4;
    for (let i = 0; i < ceilingLightCount; i++) {
      const lightX = center.x + (Math.random() - 0.5) * size.x * 0.8;
      const lightZ = center.z + (Math.random() - 0.5) * size.z * 0.8;
      
      // Create ceiling light fixture
      const lightFixture = new THREE.Group();
      
      // Light housing
      const housingGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const housingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc, 
        roughness: 0.5,
        metalness: 0.8 
      });
      const housing = new THREE.Mesh(housingGeometry, housingMaterial);
      housing.position.y = -0.05;
      lightFixture.add(housing);
      
      // Light lens
      const lensGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.02, 16);
      const lensMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.1
      });
      const lens = new THREE.Mesh(lensGeometry, lensMaterial);
      lens.position.y = -0.09;
      lightFixture.add(lens);
      
      // Position the fixture
      lightFixture.position.set(lightX, center.y + size.y - 0.05, lightZ);
      interiorGroup.add(lightFixture);
      
      // Add the actual light source below the fixture
      const light = new THREE.PointLight(0xffffee, 1.5, size.y * 1.5, 1);
      light.position.set(lightX, center.y + size.y - 0.2, lightZ);
      interiorGroup.add(light);
    }
    
    // Create furniture
    /*
    const placeholderGeometry = new THREE.BoxGeometry(size.x * 0.8, size.y * 0.75, size.z * 0.8);
    const placeholderMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.8,
        wireframe: false // Change to solid rather than wireframe
    });
    const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    // Position placeholder centered within the section bounds
    placeholderMesh.position.set(center.x, center.y + size.y * 0.375, center.z);
    interiorGroup.add(placeholderMesh);
    */
    
    console.log(`Added placeholder interior with lighting for ${interiorGroup.name}`);
  }

  // --- Specific Interior Creation Methods --- //

  /** Creates interior for Interaction Design section. */
  _createDesignInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating DESIGN interior (Tim Rodenbröker style) at ${center.x}, ${center.z}`);
    
    // Remove any old poster or mural meshes from previous renders
    const toRemove = [];
    interiorGroup.traverse(child => {
      if (child.isMesh && (
        (child.geometry && (child.geometry.type === 'PlaneGeometry' || child.geometry.type === 'BoxGeometry')) &&
        (child.material && (child.material.map instanceof THREE.CanvasTexture || child.material.color?.getHex() === 0x222222))
      )) {
        toRemove.push(child);
      }
    });
    toRemove.forEach(mesh => {
      if (mesh.parent) mesh.parent.remove(mesh);
    });
    
    // Entry and general lighting
    if (doorPosition) {
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      const entryLight = new THREE.SpotLight(0x4285f4, 4.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0)));
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    const interiorLight = new THREE.PointLight(0xffffff, 2.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // --- Professional Gallery Wall with Framed Posters ---
    // Helper to create a framed poster (canvas-based)
    /*
    function createFramedPoster(text, accentColor, width = 1.1, height = 1.6) {
      // Create canvas for poster art
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');
      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Accent geometric design
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = accentColor;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(canvas.width, 0);
      ctx.lineTo(canvas.width, canvas.height * 0.4);
      ctx.lineTo(0, canvas.height * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      // Main text
      ctx.font = 'bold 72px Arial';
      ctx.fillStyle = accentColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width/2, canvas.height/2 - 40);
      // Subtitle
      ctx.font = '32px Arial';
      ctx.fillStyle = '#222';
      ctx.fillText('Creative Coding', canvas.width/2, canvas.height/2 + 40);
      // Signature
      ctx.font = 'italic 24px Arial';
      ctx.fillStyle = '#888';
      ctx.fillText('Tim Rodenbröker', canvas.width/2, canvas.height - 50);
      // Texture
      const texture = new THREE.CanvasTexture(canvas);
      // Frame
      const frameDepth = 0.05;
      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, frameDepth),
        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.3 })
      );
      // Poster
      const poster = new THREE.Mesh(
        new THREE.PlaneGeometry(width * 0.92, height * 0.92),
        new THREE.MeshStandardMaterial({ map: texture, roughness: 0.5, metalness: 0.1 })
      );
      poster.position.z = frameDepth/2 + 0.001;
      // Group
      const group = new THREE.Group();
      group.add(frame);
      group.add(poster);
      return group;
    }
    */

    // Arrange 4 posters on the back wall (Z), spread along X, facing into the room
    /*
    const posterWallZ = center.z - size.z/2 + 0.08;
    const posterY = center.y + 1.3;
    const posterSpacing = 1.4;
    const accentColors = ['#4285f4', '#ea4335', '#fbbc05', '#34a853'];
    const posterTitles = ['Generative Grid', 'Type & Code', 'Color Systems', 'Motion Design'];
    for (let i = 0; i < 4; i++) {
      const poster = createFramedPoster(posterTitles[i], accentColors[i]);
      poster.position.set(center.x - posterSpacing * 1.5 + i * posterSpacing, posterY, posterWallZ);
      poster.rotation.y = 0;
      interiorGroup.add(poster);
      // Accent spotlight above each poster (slightly in front of the poster)
      const spot = new THREE.SpotLight(accentColors[i], 2.2, 5.0, Math.PI/8, 0.5, 1);
      spot.position.set(poster.position.x, poster.position.y + 1.1, poster.position.z + 0.1);
      spot.target.position.copy(poster.position);
      spot.target.updateMatrixWorld();
      interiorGroup.add(spot);
      interiorGroup.add(spot.target);
    }
    */

    // --- Geometric Mural on Left Wall ---
    // Use a large plane with a canvas texture
    /*
    const muralWidth = size.x * 0.7;
    const muralHeight = size.y * 0.7;
    const muralCanvas = document.createElement('canvas');
    muralCanvas.width = 1024;
    muralCanvas.height = 1024;
    const muralCtx = muralCanvas.getContext('2d');
    muralCtx.fillStyle = '#f4f4f4';
    muralCtx.fillRect(0, 0, muralCanvas.width, muralCanvas.height);
    // Draw geometric pattern (grid + circles)
    muralCtx.strokeStyle = '#4285f4';
    muralCtx.lineWidth = 6;
    for (let i = 1; i < 6; i++) {
      muralCtx.beginPath();
      muralCtx.moveTo(i * 170, 0);
      muralCtx.lineTo(i * 170, muralCanvas.height);
      muralCtx.stroke();
      muralCtx.beginPath();
      muralCtx.moveTo(0, i * 170);
      muralCtx.lineTo(muralCanvas.width, i * 170);
      muralCtx.stroke();
    }
    muralCtx.globalAlpha = 0.18;
    muralCtx.fillStyle = '#ea4335';
    muralCtx.beginPath();
    muralCtx.arc(300, 300, 180, 0, 2 * Math.PI);
    muralCtx.fill();
    muralCtx.globalAlpha = 0.12;
    muralCtx.fillStyle = '#fbbc05';
    muralCtx.beginPath();
    muralCtx.arc(700, 700, 140, 0, 2 * Math.PI);
    muralCtx.fill();
    const muralTexture = new THREE.CanvasTexture(muralCanvas);
    const mural = new THREE.Mesh(
      new THREE.PlaneGeometry(muralWidth, muralHeight),
      new THREE.MeshStandardMaterial({ map: muralTexture, roughness: 0.6, metalness: 0.1 })
    );
    mural.position.set(center.x - size.x/2 + 0.08, center.y + muralHeight/2 + 0.2, center.z);
    mural.rotation.y = Math.PI/2;
    interiorGroup.add(mural);
    // Add a soft white light to wash the mural
    const muralLight = new THREE.SpotLight(0xffffff, 1.2, 7.0, Math.PI/6, 0.7, 1);
    muralLight.position.set(mural.position.x + 0.2, mural.position.y + 1.2, mural.position.z);
    muralLight.target.position.copy(mural.position);
    muralLight.target.updateMatrixWorld();
    interiorGroup.add(muralLight);
    interiorGroup.add(muralLight.target);
    */

    // --- Minimal, Modern Central Table ---
    const tableGeometry = new THREE.BoxGeometry(2.2, 0.09, 1.1);
    const tableMaterial = new THREE.MeshStandardMaterial({ color: 0xf4f4f4, roughness: 0.25, metalness: 0.18 });
    const table = new THREE.Mesh(tableGeometry, tableMaterial);
    table.position.set(center.x, center.y + 0.7, center.z);
    interiorGroup.add(table);
    // Add a blue accent line on the table (as a thin box)
    const accentGeom = new THREE.BoxGeometry(2.0, 0.01, 0.07);
    const accentMat = new THREE.MeshStandardMaterial({ color: 0x4285f4, roughness: 0.2, metalness: 0.5 });
    const accent = new THREE.Mesh(accentGeom, accentMat);
    accent.position.set(center.x, table.position.y + 0.055, center.z);
    interiorGroup.add(accent);

    // --- Subtle Floor Logo/Marking near Entrance ---
    if (doorPosition) {
      const logoCanvas = document.createElement('canvas');
      logoCanvas.width = 256;
      logoCanvas.height = 256;
      const logoCtx = logoCanvas.getContext('2d');
      logoCtx.clearRect(0, 0, 256, 256);
      logoCtx.globalAlpha = 0.18;
      logoCtx.fillStyle = '#4285f4';
      logoCtx.beginPath();
      logoCtx.arc(128, 128, 110, 0, 2 * Math.PI);
      logoCtx.fill();
      logoCtx.globalAlpha = 1.0;
      logoCtx.font = 'bold 48px Arial';
      logoCtx.fillStyle = '#222';
      logoCtx.textAlign = 'center';
      logoCtx.textBaseline = 'middle';
      logoCtx.fillText('DESIGN', 128, 128);
      const logoTexture = new THREE.CanvasTexture(logoCanvas);
      const logoMat = new THREE.MeshStandardMaterial({ map: logoTexture, transparent: true, opacity: 0.7, roughness: 0.4 });
      const logoMesh = new THREE.Mesh(new THREE.CircleGeometry(0.9, 48), logoMat);
      logoMesh.position.copy(doorPosition.clone());
      logoMesh.position.y = center.y + 0.02;
      logoMesh.rotation.x = -Math.PI/2;
      interiorGroup.add(logoMesh);
    }
  }

  /** Creates interior for Development section. */
  async _createDevInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating DEV interior at ${center.x}, ${center.z}`);
    // --- Special lighting at door entrance ---
    if (doorPosition) {
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      const entryLight = new THREE.SpotLight(0x34a853, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0)));
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // General interior light - modified for more dramatic effect
    const interiorLight = new THREE.PointLight(0xffffff, 1.0, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
     
    const accentColors = [
      new THREE.Color(0x34a853), // Green
      new THREE.Color(0x4285f4), // Blue
      new THREE.Color(0xfbbc05), // Yellow
      new THREE.Color(0xea4335)  // Red
    ];
    
    // Keep only the blue accent light and sphere (index 1)
    const blueIndex = 1;
    const angle = (blueIndex / 4) * Math.PI * 2;
    const dist = size.x * 0.3;
    const x = center.x + Math.cos(angle) * dist;
    const z = center.z + Math.sin(angle) * dist;

    const accentLight = new THREE.PointLight(accentColors[blueIndex], 2.5, size.x * 0.6, 2);
    accentLight.position.set(x, center.y + 1.0, z);
    interiorGroup.add(accentLight);

    // --- Create Kruger Slogans on Walls (keep this from original) ---
    (async () => {
      const slogans = await fetchMCPContent('dev_slogans');
      const wallColor = '#fff';
      const krugerColor = '#e10600';
      // Back wall (Z+)
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size.x, size.y),
        new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[0], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
      );
      backWall.position.set(center.x, center.y + size.y/2, center.z + size.z/2 - 0.05);
      backWall.rotation.y = Math.PI;
      interiorGroup.add(backWall);
      // Front wall (Z-)
      const frontWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size.x, size.y),
        new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[1], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
      );
      frontWall.position.set(center.x, center.y + size.y/2, center.z - size.z/2 + 0.05);
      frontWall.rotation.y = 0;
      interiorGroup.add(frontWall);
      // Left wall (X-)
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size.z, size.y),
        new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[2], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
      );
      leftWall.position.set(center.x - size.x/2 + 0.05, center.y + size.y/2, center.z);
      leftWall.rotation.y = Math.PI/2;
      interiorGroup.add(leftWall);
      // Right wall (X+)
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size.z, size.y),
        new THREE.MeshBasicMaterial({ map: createKrugerTextTexture(slogans[3], { width: 2048, height: 512, bgColor: wallColor, fgColor: krugerColor }), side: THREE.DoubleSide })
      );
      rightWall.position.set(center.x + size.x/2 - 0.05, center.y + size.y/2, center.z);
      rightWall.rotation.y = -Math.PI/2;
      interiorGroup.add(rightWall);
    })();
    
    // --- Tim Rodenbroeker Style: Create Generative Art Floor ---
    // Floor removed to match Severance aesthetic
    
    // Store reference to floor shader for animation updates
    this._codeRoomFloorShader = null;
    
    // --- Tim Rodenbroeker Style: Create Generative Art Nodes ---
    const createGenerativeNode = (position, nodeType) => {
      const nodeGroup = new THREE.Group();
      nodeGroup.position.copy(position);
      
      // Base parameters
      const nodeRadius = 0.2;
      let nodeColor, emissiveColor, particleCount;
      
      switch (nodeType) {
        case 'flow':
          nodeColor = new THREE.Color(0x4285f4); // Blue
          emissiveColor = new THREE.Color(0x4285f4);
          particleCount = 24;
          break;
        case 'data':
          nodeColor = new THREE.Color(0xfbbc05); // Yellow
          emissiveColor = new THREE.Color(0xfbbc05);
          particleCount = 18;
          break;
        case 'compute':
          nodeColor = new THREE.Color(0xea4335); // Red
          emissiveColor = new THREE.Color(0xea4335);
          particleCount = 12;
          break;
        default:
          nodeColor = new THREE.Color(0x34a853); // Green
          emissiveColor = new THREE.Color(0x34a853);
          particleCount = 6;
      }
      
      // Create core sphere
      const coreGeom = new THREE.SphereGeometry(nodeRadius, 16, 16);
      const coreMat = new THREE.MeshStandardMaterial({
        color: nodeColor,
        emissive: emissiveColor,
        emissiveIntensity: 0.7,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });
      
      const core = new THREE.Mesh(coreGeom, coreMat);
      nodeGroup.add(core);
      
      // Add orbiting particles
      const particleGeom = new THREE.SphereGeometry(nodeRadius * 0.15, 8, 8);
      const particleMat = new THREE.MeshStandardMaterial({
        color: nodeColor,
        emissive: emissiveColor,
        emissiveIntensity: 0.9,
        roughness: 0.1,
        metalness: 0.9
      });
      
      const orbitRadii = [nodeRadius * 2, nodeRadius * 3, nodeRadius * 4];
      
      for (let i = 0; i < particleCount; i++) {
        const particle = new THREE.Mesh(particleGeom, particleMat);
        
        // Determine which orbit
        const orbitIndex = Math.floor(i / (particleCount / orbitRadii.length));
        const orbitRadius = orbitRadii[Math.min(orbitIndex, orbitRadii.length - 1)];
        
        // Position in the orbit
        const angle = (i % (particleCount / orbitRadii.length)) / (particleCount / orbitRadii.length) * Math.PI * 2;
        const x = Math.cos(angle) * orbitRadius;
        const z = Math.sin(angle) * orbitRadius;
        
        // Add some height variation based on angle
        const y = Math.sin(angle * 2) * (orbitRadius * 0.5);
        
        particle.position.set(x, y, z);
        nodeGroup.add(particle);
        
        // Add to animated objects
        const particleId = `node_${nodeType}_particle_${i}`;
        particle.name = particleId;
        
        this._animatedObjects = this._animatedObjects || new Map();
        this._animatedObjects.set(particleId, {
          object: particle,
          centerX: particle.position.x,
          centerZ: particle.position.z,
          radius: orbitRadius,
          speed: 0.6 + (Math.random() * 0.4), // Variable speed
          phase: i * (Math.PI * 2 / particleCount),
          verticalAmplitude: orbitRadius * 0.25,
          verticalFrequency: 1.5 + Math.random()
        });
      }
      
      // Add light
      const nodeLight = new THREE.PointLight(nodeColor, 1.0, nodeRadius * 10, 2);
      nodeGroup.add(nodeLight);
      
      return nodeGroup;
    };
    
    // Create only the blue node (type: 'flow')
    const nodes = [
      { type: 'flow', position: new THREE.Vector3(center.x - size.x * 0.3, center.y + 1.2, center.z - size.z * 0.2) }
    ];
    
    nodes.forEach(node => {
      const nodeGroup = createGenerativeNode(node.position, node.type);
      interiorGroup.add(nodeGroup);
    });
    
    // --- Create Interactive Terminal (modified from original) ---
    const terminalWidth = 4.0;
    const terminalHeight = 4.0;
    
    // Create a dynamic canvas for the terminal
    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    
    // Make the background transparent
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Add generative art pattern (Tim Rodenbroeker style)
    const drawGenerativePattern = (time) => {
      // Clear with dark background
      ctx.fillStyle = '#1e2229';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid of circles/dots
      const gridSize = 40;
      const circleRadius = 4;
      const colors = ['#4285f4', '#34a853', '#fbbc05', '#ea4335'];
      
      for (let x = gridSize/2; x < canvas.width; x += gridSize) {
        for (let y = gridSize/2; y < canvas.height; y += gridSize) {
          // Calculate distance from center
          const dx = x - canvas.width/2;
          const dy = y - canvas.height/2;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const maxDist = Math.sqrt(canvas.width*canvas.width + canvas.height*canvas.height) / 2;
          
          // Size based on distance from center
          const sizeFactor = 1 - (dist / maxDist);
          const animFactor = 0.5 + 0.5 * Math.sin(time + (dx + dy) * 0.01);
          const r = circleRadius * (1 + sizeFactor * 3 * animFactor);
          
          // Rotation angle based on position
          const angle = Math.atan2(dy, dx);
          
          // Color index based on position
          const colorIndex = Math.floor((angle / (Math.PI * 2) + 0.5 + time * 0.1) * colors.length) % colors.length;
          
          ctx.fillStyle = colors[colorIndex];
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Add connectivity lines between dots
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.2;
      
      const connectRadius = gridSize * 1.5;
      for (let x = gridSize/2; x < canvas.width; x += gridSize) {
        for (let y = gridSize/2; y < canvas.height; y += gridSize) {
          // Connect to nearby dots
          for (let nx = Math.max(gridSize/2, x - connectRadius); nx <= Math.min(canvas.width - gridSize/2, x + connectRadius); nx += gridSize) {
            for (let ny = Math.max(gridSize/2, y - connectRadius); ny <= Math.min(canvas.height - gridSize/2, y + connectRadius); ny += gridSize) {
              if (nx === x && ny === y) continue;
              
              const dx = nx - x;
              const dy = ny - y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if (dist <= connectRadius) {
                ctx.globalAlpha = 0.2 * (1 - dist/connectRadius);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(nx, ny);
                ctx.stroke();
              }
            }
          }
        }
      }
      ctx.globalAlpha = 1.0;
      
      // Add code-like text overlay
      ctx.font = '16px monospace';
      ctx.fillStyle = '#34a853';
      ctx.textAlign = 'left';
      
      const codeLines = [
        '01 function initCreativeNodes() {',
        '02   const nodes = setupNodeNetwork();',
        '03   const connections = calculatePaths(nodes);',
        '04   renderNetwork(nodes, connections);',
        '05   runSimulation();',
        '06 }',
        '',
        '07 function updateNetwork(deltaTime) {',
        '08   nodes.forEach(node => {',
        '09     node.phase += node.speed * deltaTime;',
        '10     node.position.y = Math.sin(node.phase) * node.amplitude;',
        '11     node.process(deltaTime);',
        '12   });',
        '13 }',
        '',
        '14 // Tim Rodenbroeker inspired generative art',
        '15 function createGenerativePattern() {'
      ];
      
      let y = 60;
      codeLines.forEach(line => {
        ctx.fillText(line, 40, y);
        y += 24;
      });
    };
    
    // Initial draw
    drawGenerativePattern(performance.now() * 0.001);
    
    // Create terminal material with the canvas texture
    const screenTexture = new THREE.CanvasTexture(canvas);
    
    const terminalMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: screenTexture,
      emissive: 0xffffff,
      emissiveMap: screenTexture,
      emissiveIntensity: 0.7,
      metalness: 0.3,
      roughness: 0.4,
      transparent: true
    });
    
    // Rounded rectangle frame (same as original)
    const frameThickness = 0.08;
    const frameRadius = 0.12;
    // Use a rounded rectangle shape for the frame
    const shape = new THREE.Shape();
    const w = terminalWidth + frameThickness;
    const h = terminalHeight + frameThickness;
    shape.absarc(-w/2 + frameRadius, -h/2 + frameRadius, frameRadius, Math.PI, Math.PI/2, true);
    shape.absarc(w/2 - frameRadius, -h/2 + frameRadius, frameRadius, Math.PI/2, 0, true);
    shape.absarc(w/2 - frameRadius, h/2 - frameRadius, frameRadius, 0, -Math.PI/2, true);
    shape.absarc(-w/2 + frameRadius, h/2 - frameRadius, frameRadius, -Math.PI/2, -Math.PI, true);
    const extrudeSettings = { depth: 0.08, bevelEnabled: false };
    const frameGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x22262a,
      metalness: 0.7,
      roughness: 0.25,
      emissive: 0x0a0a1a,
      emissiveIntensity: 0.2
    });
    
    const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);
    frameMesh.position.set(center.x - size.x/2 + 0.055, center.y + 1.2, center.z);
    frameMesh.rotation.y = Math.PI/2;
    frameMesh.position.z -= 0.04; // Slightly behind the screen
    interiorGroup.add(frameMesh);
    
    // Create the terminal screen
    const terminal = new THREE.Mesh(
      new THREE.PlaneGeometry(terminalWidth, terminalHeight),
      terminalMaterial
    );
    terminal.position.set(center.x - size.x/2 + 0.14, center.y + 1.2, center.z);
    terminal.rotation.y = Math.PI/2;
    terminal.name = 'dev_terminal';
    interiorGroup.add(terminal);
    
    // Set up animation for the terminal screen
    this._terminalCanvas = canvas;
    this._terminalTexture = screenTexture;
    this._terminalLastUpdate = performance.now();
    this._terminalUpdateInterval = 500; // Update every 500ms for performance
    
    // Add floating E button in front of the screen, at the same height (unchanged)
    const eButtonCanvas = document.createElement('canvas');
    eButtonCanvas.width = 320;
    eButtonCanvas.height = 128;
    const eButtonCtx = eButtonCanvas.getContext('2d');
    eButtonCtx.clearRect(0, 0, 320, 128);
    // Draw blue-green circle
    eButtonCtx.fillStyle = '#5CDED3';
    eButtonCtx.beginPath();
    eButtonCtx.arc(64, 64, 56, 0, 2 * Math.PI);
    eButtonCtx.fill();
    // Draw black E
    eButtonCtx.font = 'bold 80px Arial';
    eButtonCtx.fillStyle = '#000';
    eButtonCtx.textAlign = 'center';
    eButtonCtx.textBaseline = 'middle';
    eButtonCtx.fillText('E', 64, 72);
    // Draw 'to interact' label to the right of the circle
    eButtonCtx.font = 'bold 36px Arial';
    eButtonCtx.fillStyle = '#fff'; // High contrast white
    eButtonCtx.textAlign = 'left';
    eButtonCtx.textBaseline = 'middle';
    eButtonCtx.shadowColor = '#000';
    eButtonCtx.shadowBlur = 4;
    eButtonCtx.fillText('to interact', 128, 72);
    eButtonCtx.shadowBlur = 0; // Reset shadow
    const eButtonTex = new THREE.CanvasTexture(eButtonCanvas);
    eButtonTex.needsUpdate = true;
    eButtonTex.minFilter = THREE.LinearFilter;
    eButtonTex.magFilter = THREE.LinearFilter;
    const eButtonMat = new THREE.MeshBasicMaterial({ map: eButtonTex, transparent: true, side: THREE.DoubleSide });
    const eButtonMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(1.6, 0.64), 
      eButtonMat
    );
    eButtonMesh.position.set(terminal.position.x + 0.4, terminal.position.y, terminal.position.z);
    eButtonMesh.rotation.y = Math.PI/2;
    eButtonMesh.name = 'dev_terminal_ebutton';
    eButtonMesh.visible = false; // Start hidden, show based on proximity
    interiorGroup.add(eButtonMesh);
    
    // Create invisible interaction volume for terminal (no changes to original)
    const terminalInteractionGeom = new THREE.BoxGeometry(1.0, 2.0, 2.0);
    const terminalInteractionMat = new THREE.MeshBasicMaterial({ visible: false });
    const terminalInteractionMesh = new THREE.Mesh(terminalInteractionGeom, terminalInteractionMat);
    terminalInteractionMesh.position.set(center.x - size.x/2 + 0.4, center.y + 1.2, center.z);
    terminalInteractionMesh.userData.interactable = true;
    terminalInteractionMesh.userData.isDevTerminal = true;
    terminalInteractionMesh.name = 'dev_terminal_interaction';
    interiorGroup.add(terminalInteractionMesh);
    
    // Register for interaction and proximity logic
    if (!this._devTerminalInteractable) this._devTerminalInteractable = [];
    this._devTerminalInteractable.push({ mesh: terminal, eButton: eButtonMesh, interactionMesh: terminalInteractionMesh });
  }

  /** Creates interior for Film & Cinematography section. */
  async _createFilmInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating FILM interior at ${center.x}, ${center.z}`);
    
    // --- Special lighting at door entrance, similar to Design interior ---
    if (doorPosition) {
      // Create vector from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Create a special warm amber light (matching film color theme) at the entryway
      const entryLight = new THREE.SpotLight(0xfbbc05, 5.0, 8.0, Math.PI/4, 0.5, 1);
      entryLight.position.copy(doorPosition.clone().add(new THREE.Vector3(0, 2.5, 0))); // Above the door
      
      // Point the spotlight into the room
      entryLight.target.position.copy(center);
      entryLight.target.updateMatrixWorld();
      
      interiorGroup.add(entryLight);
      interiorGroup.add(entryLight.target);
    }
    
    // --- Only add: GLTF chairs, lamps, screen, curtain, speakers, projector ---

    const loader = new GLTFLoader();
    const textureLoader = new TextureLoader(); // Create texture loader for posters
    
    // Load chair.gltf
    const chairGltf = await new Promise((resolve, reject) => {
      loader.load('/chair.glb', resolve, undefined, reject);
    });
    // Load lamp.gltf
    const lampGltf = await new Promise((resolve, reject) => {
      loader.load('/lamp.glb', resolve, undefined, reject);
    });
    // Load projector.glb
    const projectorGltf = await new Promise((resolve, reject) => {
      loader.load('/projector.glb', resolve, undefined, reject);
    });
    const projectorScreenGltf = await new Promise((resolve, reject) => {
      loader.load('/projector_screen.glb', resolve, undefined, reject);
    });
    
    // Load poster textures
    const poster1Texture = await textureLoader.loadAsync('/assets/textures/posters/poster1.jpg');
    // const poster2Texture = await textureLoader.loadAsync('/assets/textures/posters/Severance_Photo_0201.jpg');

    const chairMesh = chairGltf.scene;
    const lampMesh = lampGltf.scene;
    const projectorMesh = projectorGltf.scene;
    chairMesh.scale.set(1, 1, 1); // Adjust if needed
    lampMesh.scale.set(1, 1, 1); // Adjust if needed
    projectorMesh.scale.set(1, 1, 1); // Adjust if needed

    // --- Apply custom light shader to lamp bulb ---
    // Find the bulb mesh in lampMesh (by name or material)
    let bulbMeshes = [];
    lampMesh.traverse((child) => {
      if (child.isMesh && (child.name.toLowerCase().includes('bulb') || child.name.toLowerCase().includes('light'))) {
        bulbMeshes.push(child);
      }
    });
    if (bulbMeshes.length === 0) {
      // Try fallback: find mesh with high white/emissive material
      lampMesh.traverse((child) => {
        if (child.isMesh && child.material && child.material.emissive && child.material.emissive.getHex() === 0xffffff) {
          bulbMeshes.push(child);
        }
      });
    }
    if (bulbMeshes.length === 0) {
      console.warn('[Lamp Shader] No bulb mesh found in lamp.glb. No shader applied.');
    } else {
      const lampShaderMat = createLampLightShaderMaterial();
      bulbMeshes.forEach(bulb => {
        bulb.material = lampShaderMat;
        bulb.material.needsUpdate = true;
      });
    }

    // --- Place four GLTF chairs in a gentle arc facing the screen wall (assume screen is on +Z wall) ---
    const chairPositions = [
      { x: center.x - 1.2, z: center.z + 1.2, rot: 0.08 },
      { x: center.x - 0.4, z: center.z + 1.4, rot: 0.03 },
      { x: center.x + 0.4, z: center.z + 1.4, rot: -0.03 },
      { x: center.x + 1.2, z: center.z + 1.2, rot: -0.08 },
    ];
    for (let i = 0; i < 4; i++) {
      const chair = chairMesh.clone(true);
      chair.position.set(chairPositions[i].x, center.y, chairPositions[i].z);
      chair.rotation.y = chairPositions[i].rot;
      chair.position.y = center.y;
      interiorGroup.add(chair);
    }

    // --- Place projector.glb at a realistic position and scale ---
    const projectorScale = 0.4;
    projectorMesh.scale.set(projectorScale, projectorScale, projectorScale);
    const projectorY = center.y + 2.2;
    const projectorZ = center.z + size.z / 2 - 3.0;
    projectorMesh.position.set(center.x, projectorY, projectorZ);
    projectorMesh.rotation.set(-Math.PI / 16, 0, 0);
    interiorGroup.add(projectorMesh);

    // --- Add projector_screen.glb (realistic pull-down screen) ---
    const screen = projectorScreenGltf.scene;
    // Dynamically size and position the screen to fit the room and maintain aspect ratio
    const screenAspect = 16 / 9;
    const marginX = 0.5; // meters from each side wall
    const marginTop = 0.4; // meters from ceiling
    const marginBottom = 0.5; // Reset to previous value for size calculation
    const maxWidth = size.x - 2 * marginX;
    const maxHeight = size.y - marginTop - marginBottom;
    // Compute width and height that fit the aspect ratio and room
    let screenWidth = maxWidth;
    let screenHeight = screenWidth / screenAspect;
    if (screenHeight > maxHeight) {
      screenHeight = maxHeight;
      screenWidth = screenHeight * screenAspect;
    }
    // Scale the screen (reduced by 20% from previous 3x)
    screenWidth *= 2.4; // Reduced from 3 to 2.4 (20% smaller)
    screenHeight *= 2.4; // Reduced from 3 to 2.4 (20% smaller)
    // The GLB's native size (from Blender) is 6.4 x 3.6 meters
    const nativeWidth = 6.4;
    const nativeHeight = 3.6;
    const scaleX = screenWidth / nativeWidth;
    const scaleY = screenHeight / nativeHeight;
    // Use uniform scale for X and Y (Z can match X)
    const scale = Math.min(scaleX, scaleY);
    screen.scale.set(scale, scale, scale);
    // Position: flush with +Z wall, centered horizontally, BOTTOM just above the floor
    const screenZ = center.z + size.z / 2 - 0.08; // 8cm from wall
    // Correct floor Y calculation and add height offset
    const floorY = center.y - size.y / 2;
    const heightOffset = 1.5; // Raise screen by 1 meter from base position
    const screenY = floorY + marginBottom + heightOffset; // Add heightOffset to raise the screen
    screen.position.set(center.x, screenY, screenZ);
    screen.rotation.y = 0; // Facing -Z (into the room)
    interiorGroup.add(screen);
    // --- Place four lamp.glb in the four corners, each with a point light ---
    const margin = 0.45;
    const lampCorners = [
      { x: center.x - size.x / 2 + margin, z: center.z - size.z / 2 + margin },
      { x: center.x + size.x / 2 - margin, z: center.z - size.z / 2 + margin },
      { x: center.x - size.x / 2 + margin, z: center.z + size.z / 2 - margin },
      { x: center.x + size.x / 2 - margin, z: center.z + size.z / 2 - margin },
    ];
    for (let i = 0; i < 4; i++) {
      const lamp = lampMesh.clone(true);
      lamp.position.set(lampCorners[i].x, center.y, lampCorners[i].z);
      interiorGroup.add(lamp);
      // Add a point light at the bulb position (try to find bulb in this lamp instance)
      let bulbPos = null;
      lamp.traverse((child) => {
        if (child.isMesh && (child.name.toLowerCase().includes('bulb') || child.name.toLowerCase().includes('light'))) {
          bulbPos = child.getWorldPosition(new THREE.Vector3());
        }
      });
      // If not found, use lamp's position
      if (!bulbPos) bulbPos = lamp.position.clone();
      const lampLight = new THREE.PointLight(0xffffcc, 2.0, 5.0, 1.0);
      lampLight.position.copy(bulbPos);
      interiorGroup.add(lampLight);
    }

    // --- Add two framed film posters on the wall ---
    const createFramedPoster = (posterTexture, position, rotation) => {
      // Create poster group
      const posterGroup = new THREE.Group();
      
      // Get the aspect ratio from the texture
      const imageAspect = posterTexture.image ? 
        posterTexture.image.width / posterTexture.image.height : 
        0.75; // Default aspect ratio if image data isn't available yet
      
      // Create frame with proper aspect ratio
      const frameHeight = 1.4;
      const frameWidth = frameHeight * imageAspect;
      const frameDepth = 0.04;
      const frameBorderSize = 0.05;
      
      // Frame material - matte black, matching Severance aesthetic
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.8,
        metalness: 0.2
      });
      
      // Poster material with texture
      const posterMaterial = new THREE.MeshStandardMaterial({
        map: posterTexture,
        roughness: 0.6,
        metalness: 0.0
      });
      
      // Create outer frame
      const outerFrameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const outerFrame = new THREE.Mesh(outerFrameGeometry, frameMaterial);
      posterGroup.add(outerFrame);
      
      // Create inner poster (slightly smaller and in front of frame)
      const posterWidth = frameWidth - (frameBorderSize * 2);
      const posterHeight = frameHeight - (frameBorderSize * 2);
      const posterGeometry = new THREE.PlaneGeometry(posterWidth, posterHeight);
      const poster = new THREE.Mesh(posterGeometry, posterMaterial);
      poster.position.z = frameDepth / 2 + 0.001; // Place slightly in front of frame
      posterGroup.add(poster);
      
      // Add subtle matboard/matte between frame and poster
      const matteWidth = frameWidth - frameBorderSize * 0.8;
      const matteHeight = frameHeight - frameBorderSize * 0.8;
      const matteGeometry = new THREE.PlaneGeometry(matteWidth, matteHeight);
      const matteMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        roughness: 0.9,
        metalness: 0.0
      });
      const matte = new THREE.Mesh(matteGeometry, matteMaterial);
      matte.position.z = frameDepth / 2 + 0.0005; // Between frame and poster
      posterGroup.add(matte);
      
      // Add glass in front (slight reflection)
      const glassGeometry = new THREE.PlaneGeometry(frameWidth - frameBorderSize * 0.3, frameHeight - frameBorderSize * 0.3);
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0.05,
        metalness: 0.0,
        transmission: 0.98,
        transparent: true,
        opacity: 0.1,
        reflectivity: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
      });
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.z = frameDepth / 2 + 0.002; // In front of everything
      posterGroup.add(glass);
      
      // Set position and rotation
      posterGroup.position.copy(position);
      posterGroup.rotation.set(rotation.x, rotation.y, rotation.z);
      
      return posterGroup;
    };
    
    // --- Helper to create an interactable mesh and button ---
    function addWatchInteractionToFrame(frameGroup, position, link, filmTitle, filmYear, filmCast, filmRole, filmSummary) {
      // Create an invisible box for interaction
      const interactGeom = new THREE.BoxGeometry(1.3, 1.6, 0.2); // Slightly larger than frame
      // Make interaction mesh invisible (no debugging needed in production)
      const interactMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, visible: false });
      const interactMesh = new THREE.Mesh(interactGeom, interactMat);
      
      // Position the interaction mesh relative to the frame
      interactMesh.position.copy(position);
      
      // Add a small Z offset to ensure it's in front of the frame
      // Extract the orientation from the frame group's rotation
      const frameRotation = frameGroup.rotation.clone();
      const normalVector = new THREE.Vector3(0, 0, 1).applyEuler(frameRotation);
      
      // Offset in the direction the frame is facing
      interactMesh.position.add(normalVector.multiplyScalar(0.25));
      
      // Store frame data
      interactMesh.userData.isWatchInteractable = true;
      interactMesh.userData.interactable = true; // Consistent with doors
      interactMesh.userData.watchLink = link;
      interactMesh.userData.filmTitle = filmTitle;
      interactMesh.userData.filmYear = filmYear;
      interactMesh.userData.filmCast = filmCast;
      interactMesh.userData.filmRole = filmRole;
      interactMesh.userData.filmSummary = filmSummary;
      interactMesh.userData.frameRotation = frameRotation;
      
      // --- Add floating 3D 'E' button mesh ---
      // Create a canvas texture with a bold 'E'
      const canvas = document.createElement('canvas');
      canvas.width = 128; // Increased from 64
      canvas.height = 128; // Increased from 64
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 128, 128);
      ctx.fillStyle = '#5CDED3';
      ctx.beginPath();
      ctx.arc(64, 64, 56, 0, 2 * Math.PI); // Increased from 28
      ctx.fill();
      ctx.font = 'bold 80px Arial'; // Increased from 40px
      ctx.fillStyle = '#000';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('E', 64, 72);
      
      const texture = new THREE.CanvasTexture(canvas);
      const eButtonMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
      const buttonGeom = new THREE.PlaneGeometry(0.5, 0.5); // Increased from 0.35
      const buttonMesh = new THREE.Mesh(buttonGeom, eButtonMat);
      
      // Calculate button position based on frame normal vector
      // We want the button to be above the frame regardless of orientation
      const upVector = new THREE.Vector3(0, 1, 0);
      const rightVector = new THREE.Vector3().crossVectors(normalVector, upVector).normalize();
      const adjustedUpVector = new THREE.Vector3().crossVectors(rightVector, normalVector).normalize();
      
      // Position the button above the frame, positioned to match frame orientation
      buttonMesh.position.set(0, 0, 0);
      buttonMesh.position.add(adjustedUpVector.multiplyScalar(0.9)); // Move up
      buttonMesh.position.add(normalVector.multiplyScalar(0.4)); // Move out from frame
      
      // Store the original vectors for later positioning updates
      buttonMesh.userData.normalVector = normalVector.clone();
      buttonMesh.userData.upVector = adjustedUpVector.clone();
      
      // Add this flag for the renderer to use
      buttonMesh.renderOrder = 9999; // Very high render order to ensure it's on top
      buttonMesh.visible = false; // Only show when in range
      buttonMesh.name = 'posterEButton';
      
      // Set a fixed quaternion to ensure proper orientation
      const lookAtMatrix = new THREE.Matrix4();
      lookAtMatrix.lookAt(
        new THREE.Vector3(0, 0, 0), // origin
        normalVector, // look in the direction the frame is facing
        adjustedUpVector // maintain proper "up" direction
      );
      buttonMesh.setRotationFromMatrix(lookAtMatrix);
      
      // Add button to interact mesh
      interactMesh.add(buttonMesh);
      interactMesh.userData.eButtonMesh = buttonMesh;
      console.log(`[DEBUG] E button mesh created for '${filmTitle}':`, buttonMesh);
      console.log(`[DEBUG] E button mesh initial visibility for '${filmTitle}':`, buttonMesh.visible);
      
      // Add to frame group
      frameGroup.add(interactMesh);
      if (!frameGroup.userData.interactables) frameGroup.userData.interactables = [];
      frameGroup.userData.interactables.push(interactMesh);
      
      // Log position and orientation data
      console.log(`[DEBUG] Created interactable for '${filmTitle}' at (${position.x}, ${position.y}, ${position.z})`);
      
      return interactMesh;
    }

    // First poster - left wall, closer to the screen
    const poster1Position = new THREE.Vector3(
      center.x - size.x / 2 + 0.1, // Left wall
      center.y + 1.5, // Eye level
      center.z + size.z / 2 - 2.0 // Near the screen
    );
    const poster1Rotation = new THREE.Vector3(0, Math.PI / 2, 0);
    const framedPoster1 = createFramedPoster(poster1Texture, poster1Position, poster1Rotation);
    interiorGroup.add(framedPoster1);
    // Add interaction mesh and button to first poster
    const poster1Interact = addWatchInteractionToFrame(
      framedPoster1, poster1Position,
      'https://your-link-here',
      '38:01',
      '2017',
      'parsa azari',
      'actor',
      'A solitary watchmaker, tormented by every sound, becomes obsessed with a silent stranger in his shop, spiraling into a surreal inner crisis that reaches a startling, self-inflicted climax.'
    );

    // --- Collage frame helper ---
    function createFramedCollage(textures, position, rotation) {
      // Collage config
      const n = textures.length;
      let gridRows = 1, gridCols = n;
      if (n === 4) { gridRows = 2; gridCols = 2; }
      else if (n === 3) { gridRows = 1; gridCols = 3; }
      else if (n === 2) { gridRows = 1; gridCols = 2; }
      // Frame size
      const frameHeight = 1.4;
      const frameWidth = frameHeight * gridCols / gridRows;
      const frameDepth = 0.04;
      const frameBorderSize = 0.05;
      // Frame
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111, roughness: 0.8, metalness: 0.2
      });
      const outerFrameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const outerFrame = new THREE.Mesh(outerFrameGeometry, frameMaterial);
      // Matboard
      const matteWidth = frameWidth - frameBorderSize * 0.8;
      const matteHeight = frameHeight - frameBorderSize * 0.8;
      const matteGeometry = new THREE.PlaneGeometry(matteWidth, matteHeight);
      const matteMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee, roughness: 0.9, metalness: 0.0
      });
      const matte = new THREE.Mesh(matteGeometry, matteMaterial);
      matte.position.z = frameDepth / 2 + 0.0005;
      // Glass
      const glassGeometry = new THREE.PlaneGeometry(frameWidth - frameBorderSize * 0.3, frameHeight - frameBorderSize * 0.3);
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, roughness: 0.05, metalness: 0.0, transmission: 0.98,
        transparent: true, opacity: 0.1, reflectivity: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.1
      });
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.z = frameDepth / 2 + 0.002;
      // Collage group
      const group = new THREE.Group();
      group.add(outerFrame);
      group.add(matte);
      // Add images in grid
      const cellW = (matteWidth - 0.04) / gridCols;
      const cellH = (matteHeight - 0.04) / gridRows;
      for (let i = 0; i < n; i++) {
        const row = Math.floor(i / gridCols);
        const col = i % gridCols;
        const x = -matteWidth/2 + cellW/2 + col*cellW;
        const y = matteHeight/2 - cellH/2 - row*cellH;
        const imgGeom = new THREE.PlaneGeometry(cellW*0.95, cellH*0.95);
        const imgMat = new THREE.MeshStandardMaterial({ map: textures[i], roughness: 0.6, metalness: 0.0 });
        const img = new THREE.Mesh(imgGeom, imgMat);
        img.position.set(x, y, frameDepth/2 + 0.001);
        group.add(img);
      }
      group.add(glass);
      group.position.copy(position);
      group.rotation.set(rotation.x, rotation.y, rotation.z);
      return group;
    }

    // Film stills for the second film (collage)
    const stillFilenames = [
      'poster2(1).jpg',
      'poster2(2).jpg',
      'poster2(3).jpg',
      'poster2(4).jpg'
    ];
    const stillBasePath = '/assets/textures/posters/';
    const stillRotation = new THREE.Vector3(0, Math.PI / 2, 0);
    const collagePosition = new THREE.Vector3(
      center.x - size.x / 2 + 0.1,
      center.y + 1.5,
      center.z + size.z / 2 - 4.5 // Place further from the screen
    );
    // Load all still textures asynchronously
    // const stillTextures = await Promise.all(
    //   stillFilenames.map(filename => textureLoader.loadAsync(stillBasePath + filename))
    // );
    // const collage = createFramedCollage(stillTextures, collagePosition, stillRotation);
    // interiorGroup.add(collage);
    // Add interaction mesh and button to collage
    // const collageInteract = addWatchInteractionToFrame(
    //   collage, collagePosition,
    //   'https://youtu.be/PuEuzuM9Mig?si=jDVdbPAFdwopsvJ6',
    //   'The one who dances on your grave',
    //   '2019',
    //   'nastaran moradi',
    //   'cinematographer',
    //   'In a society of systematic erasure, Nastaran navigates her increasing invisibility. Poetic vignettes follow her through daily existence as economic pressures and patriarchal structures intensify around her.'
    // );
    // Add a spotlight above the collage
    const collageSpotPos = collagePosition.clone();
    collageSpotPos.x += 0.5;
    collageSpotPos.y += 0.8;
    // createPosterSpotlight(collageSpotPos, collagePosition); // Disabled: function not defined

    // --- Add to interactables ---
    if (!this._customWatchInteractables) this._customWatchInteractables = [];
    // this._customWatchInteractables.push(poster1Interact, collageInteract);
    console.log('[DEBUG] _customWatchInteractables after push:', this._customWatchInteractables);
    console.log('[DEBUG] Number of poster interactables:', this._customWatchInteractables.length);

    // Spotlights for each poster
    const poster1SpotPosition = poster1Position.clone();
    poster1SpotPosition.x += 0.5;
    poster1SpotPosition.y += 0.8;
    // createPosterSpotlight(poster1SpotPosition, poster1Position); // Disabled: function not defined

    const poster2SpotPosition = collagePosition.clone();
    poster2SpotPosition.x += 0.5;
    poster2SpotPosition.y += 0.8;
    // createPosterSpotlight(poster2SpotPosition, collagePosition); // Disabled: function not defined
    
    // All other 3D elements (screen, curtain, speakers, primitives, lights) are removed for minimalism.
  }

  /** Creates interior for Performance Art section. */
  async _createArtInterior(interiorGroup, center, size, doorPosition) {
    console.log(`Creating ART interior at ${center.x}, ${center.z}`);
    
    // Create a general interior light with warmer gallery lighting
    const interiorLight = new THREE.PointLight(0xfff2e6, 0.8, 0, 1);
    interiorLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(interiorLight);
    
    // Create a central circular stage (kept from original)
    const stageGeometry = new THREE.CylinderGeometry(2.0, 2.0, 0.2, 32);
    const stageMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xdddddd, 
      roughness: 0.2,
      metalness: 0.3 
    });
    const stage = new THREE.Mesh(stageGeometry, stageMaterial);
    stage.position.set(center.x, center.y + 0.1, center.z);
    interiorGroup.add(stage);

    // --- Load and place marina.glb on the stage ---
    try {
      const loader = new GLTFLoader();
      // Path relative to public/
      const gltf = await loader.loadAsync('/assets/models/marina.glb');
      const model = gltf.scene;
      // Compute bounding box to center and place on stage
      const box = new THREE.Box3().setFromObject(model);
      const sizeVec = new THREE.Vector3();
      box.getSize(sizeVec);
      const centerVec = new THREE.Vector3();
      box.getCenter(centerVec);
      // Move model so its base is at y=0
      model.position.y -= box.min.y;
      // Center model at origin
      model.position.x -= centerVec.x;
      model.position.z -= centerVec.z;
      // Optionally scale to fit stage (stage radius = 2.0)
      const desiredMaxDim = 3.8; // nearly fills the stage
      const extraScale = 0.8; // make it even bigger
      const maxDim = Math.max(sizeVec.x, sizeVec.z);
      let scale = desiredMaxDim / maxDim * extraScale;
      model.scale.set(scale, scale, scale);
      // Place model on top of stage, centered
      model.position.x += center.x;
      model.position.z += center.z;
      model.position.y += center.y + 0.2; // stage top is center.y + 0.2
      // Rotate model 90 degrees to face the door
      model.rotation.y = Math.PI / 2;
      interiorGroup.add(model);
    } catch (e) {
      console.error('Failed to load marina.glb:', e);
    }

    // --- Create Gallery Wall ---
    const createGalleryWall = async (wallPosition, wallRotation, images) => {
        const wallGroup = new THREE.Group();
        const textureLoader = new THREE.TextureLoader();
        
        // Create grid layout for images
        const imageWidth = 1.2;
        const imageHeight = 1.6;
        const imageSpacing = 0.2;
        const imagesPerRow = 3;
        
        for (let i = 0; i < images.length; i++) {
            const row = Math.floor(i / imagesPerRow);
            const col = i % imagesPerRow;
            
            // Create image group
            const imageGroup = new THREE.Group();
            
            // Load and create photo with minimal border
            const photoGeometry = new THREE.PlaneGeometry(imageWidth, imageHeight);
            const photoTexture = await textureLoader.loadAsync(images[i]);
            
            // Create a subtle border effect with shader material
            const photoMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: photoTexture },
                    time: { value: 0.0 },
                    borderWidth: { value: 0.03 },
                    borderColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D map;
                    uniform float time;
                    uniform float borderWidth;
                    uniform vec3 borderColor;
                    varying vec2 vUv;
                    
                    void main() {
                        // Calculate distance from edges
                        float distFromEdgeX = min(vUv.x, 1.0 - vUv.x);
                        float distFromEdgeY = min(vUv.y, 1.0 - vUv.y);
                        float distFromEdge = min(distFromEdgeX, distFromEdgeY);
                        
                        // Create subtle border
                        vec4 texColor = texture2D(map, vUv);
                        
                        if (distFromEdge < borderWidth) {
                            // Smooth border transition
                            float borderMix = smoothstep(0.0, borderWidth, distFromEdge);
                            gl_FragColor = mix(vec4(borderColor, 1.0), texColor, borderMix);
                        } else {
                            gl_FragColor = texColor;
                        }
                    }
                `
            });
            
            const photo = new THREE.Mesh(photoGeometry, photoMaterial);
            photo.position.z = 0.02;
            
            // Add image to group
            imageGroup.add(photo);
            
            // Position image in grid
            imageGroup.position.x = (col - 1) * (imageWidth + imageSpacing);
            imageGroup.position.y = center.y + 1.2 + row * (imageHeight + imageSpacing);
            
            wallGroup.add(imageGroup);
            
            // Add subtle spotlight for each image
            const spotlight = new THREE.SpotLight(0xfff2e6, 1.5, 4.0, Math.PI/6, 0.5, 1.0);
            spotlight.position.set(
                imageGroup.position.x,
                imageGroup.position.y + imageHeight/2 + 0.3,
                0.8
            );
            spotlight.target = imageGroup;
            wallGroup.add(spotlight);
            wallGroup.add(spotlight.target);
            
            // Store reference for animation
            if (!this._artRoomAnimations) this._artRoomAnimations = [];
            this._artRoomAnimations.push((deltaTime) => {
                if (photoMaterial.uniforms) {
                    photoMaterial.uniforms.time.value += deltaTime;
                }
            });
        }
        
        wallGroup.position.copy(wallPosition);
        wallGroup.rotation.y = wallRotation;
        interiorGroup.add(wallGroup);
    };

    // --- Create Minimal Video Installation ---
    const createVideoInstallation = () => {
        const videoGroup = new THREE.Group();
        
        // Create minimal video screen with floating design
        const screenGeometry = new THREE.PlaneGeometry(2.6, 1.8);
        const screenMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                resolution: { value: new THREE.Vector2(2.6, 1.8) },
                colorA: { value: new THREE.Color(0xea4335) },
                colorB: { value: new THREE.Color(0x000000) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform vec3 colorA;
                uniform vec3 colorB;
                varying vec2 vUv;
                
                void main() {
                    vec2 pos = vUv * 2.0 - 1.0;
                    float dist = length(pos);
                    float wave = sin(dist * 10.0 - time * 2.0) * 0.5 + 0.5;
                    vec3 color = mix(colorA, colorB, wave);
                    
                    // Add subtle vignette
                    float vignette = 1.0 - smoothstep(0.7, 1.4, dist);
                    color *= vignette;
                    
                    // Add subtle edge glow
                    float edge = 1.0 - smoothstep(0.8, 1.0, dist);
                    color += colorA * (1.0 - edge) * 0.3;
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        
        videoGroup.add(screen);
        
        // Position the installation
        videoGroup.position.set(center.x, center.y + 2.0, center.z - size.z/2 + 0.2);
        videoGroup.rotation.y = 0;
        
        // Add dramatic lighting
        const spotlightLeft = new THREE.SpotLight(0xea4335, 1.5, 5.0, Math.PI/6, 0.5, 1.0);
        spotlightLeft.position.set(-1.5, 2.5, 0.5);
        const spotlightRight = new THREE.SpotLight(0xea4335, 1.5, 5.0, Math.PI/6, 0.5, 1.0);
        spotlightRight.position.set(1.5, 2.5, 0.5);
        
        videoGroup.add(spotlightLeft);
        videoGroup.add(spotlightRight);
        
        // Store reference for animation
        videoGroup.userData.screenMaterial = screenMaterial;
        
        interiorGroup.add(videoGroup);
        return videoGroup;
    };

    // --- Create Gallery Walls ---
    // Left wall gallery (Circle of Confusion series)
    const circleImages = [
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22.jpg',
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22 (2).jpg',
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22 (3).jpg',
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22 (4).jpg',
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22 (5).jpg',
        '/assets/Images/performance/solo performances/circle of confusion/photo_2025-05-01_17-25-22 (6).jpg'
    ];
    createGalleryWall(
        new THREE.Vector3(center.x - size.x/2 + 0.2, center.y, center.z),
        Math.PI/2,
        circleImages
    );

    // Right wall gallery (Friends series)
    const friendsImages = [
        '/assets/Images/performance/solo performances/friends/photo_2025-05-01_17-29-01.jpg',
        '/assets/Images/performance/solo performances/friends/M2RjNjJmMjZk.jpg',
        '/assets/Images/performance/solo performances/friends/NzIwYjJkZmQ1.jpg',
        '/assets/Images/performance/solo performances/friends/ZTBjZDc1NzQ4.jpg',
        '/assets/Images/performance/solo performances/friends/ZTgyOGRjYjRj.jpg',
        '/assets/Images/performance/solo performances/friends/MGE1ZjJiODcw.jpg'
    ];
    createGalleryWall(
        new THREE.Vector3(center.x + size.x/2 - 0.2, center.y, center.z),
        -Math.PI/2,
        friendsImages
    );

    // Create video installation
    const videoInstallation = createVideoInstallation();

    // --- Add Animation Update Function ---
    if (!this._artRoomAnimations) this._artRoomAnimations = [];
    this._artRoomAnimations.push((deltaTime) => {
        if (videoInstallation.userData.screenMaterial) {
            videoInstallation.userData.screenMaterial.uniforms.time.value += deltaTime;
        }
    });

    // --- Add Ambient Sound ---
    // TODO: Add ambient gallery sounds if audio system is implemented

    console.log('Created sophisticated art gallery interior');
}

  /** Loads and places the MDR model */
  async _createMdrInterior(interiorGroup, center, size, doorPosition) { // Added doorPosition
      console.log(`Creating MDR interior at ${center.x}, ${center.z}`);
        try {
          const loader = new GLTFLoader();
          const gltf = await loader.loadAsync("/severance_tv_show_office.glb"); // Path relative to public/
          const model = gltf.scene;

          // --- Material Override & Collision Setup --- (Simplified)
          const wallMaterial = this.materialSystem.getMaterial("wall");
          const floorMaterial = this.materialSystem.getMaterial("floor");
          const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
          const trimMaterial = this.materialSystem.getMaterial("trim"); // Example for desks

          model.traverse((child) => {
            if (child.isMesh) {
              // Simplified material assignment - NEEDS ADJUSTMENT BASED ON MODEL
              if (child.name.toLowerCase().includes("wall")) {
                const wallWorldPos = new THREE.Vector3();
                child.getWorldPosition(wallWorldPos);
                const distanceToDoor = wallWorldPos.distanceTo(doorPosition);
                const entranceWallThreshold = 1.5; // How close to door pos to be considered entrance wall

                if (distanceToDoor < entranceWallThreshold) {
                  console.log(`[MDR Interior] Skipping collidable wall near door: ${child.name}, dist: ${distanceToDoor.toFixed(2)}`);
                  // Optionally make the entrance wall invisible or remove it if needed
                  // child.visible = false;
                } else {
                  child.material = wallMaterial; // Apply material
                  this._addCollidableWall(child); // Add *other* model walls to collision
                }
              } else if (child.name.toLowerCase().includes("floor")) {
                 child.material = floorMaterial;
              } else if (child.name.toLowerCase().includes("ceiling")) {
                 child.material = ceilingMaterial;
              } else if (child.name.toLowerCase().includes("desk")) {
                 child.material = trimMaterial;
                 // Potentially add desks as collidable obstacles too
                 // this._addCollidableWall(child); // If desks should block movement
              } else {
                 // Apply a default or keep original if needed
              }
              child.castShadow = false;
              child.receiveShadow = false;
            }
          });

          // --- Scaling & Positioning --- (Copied from original, needs verification)
          const modelBox = new THREE.Box3().setFromObject(model);
          const modelSize = modelBox.getSize(new THREE.Vector3());
          const desiredSize = size.clone().multiplyScalar(0.9); // Fit within 90% of bounds
          const scaleFactor = Math.min(desiredSize.x / modelSize.x, desiredSize.y / modelSize.y, desiredSize.z / modelSize.z);

          console.log(`MDR Scaling: DeptSize=${size.x.toFixed(2)},${size.z.toFixed(2)} ModelSize=${modelSize.x.toFixed(2)},${modelSize.z.toFixed(2)} ScaleFactor=${scaleFactor.toFixed(2)}`);
          model.scale.set(scaleFactor, scaleFactor, scaleFactor);

          // Re-center model within bounds AFTER scaling
          // Note: Positioning might need adjustment based on model's origin
          model.position.copy(center); // Start at the section center
          const scaledModelBox = new THREE.Box3().setFromObject(model); // Recalculate bounds after scaling
          const scaledModelCenterOffset = scaledModelBox.getCenter(new THREE.Vector3()).sub(model.position); // How far is the model's geom center from its origin
          model.position.sub(scaledModelCenterOffset); // Adjust position to align geometric center with the section center
          model.position.y = center.y; // Ensure floor alignment (assuming model origin is at its base)

          interiorGroup.add(model);
          console.log(`Loaded and processed MDR model: severance_tv_show_office.glb`);
        } catch (error) {
          console.error("Error loading or processing MDR model:", error);
          // Fallback to placeholder if model loading fails
          this._createPlaceholderInterior(interiorGroup, center, size, doorPosition);
      }
  }


  /**
   * Create department interior elements based on department type - REPURPOSED
   * Dispatches to specific interior creation methods based on sectionType.
   * @param {string} sectionName - The portfolio section name (used for naming the group)
   * @param {THREE.Vector3} center - The calculated center of the section bounds
   * @param {THREE.Vector3} size - The calculated size of the section bounds
   * @param {string} sectionType - Identifier for the type of interior to create (e.g., 'DESIGN', 'MDR')
   * @private
   */
  async createPortfolioSectionInteriors(sectionName, center, size, sectionType, doorPosition) {
    console.log(`Creating interior elements for ${sectionName} (Type: ${sectionType})...`);

    const interiorGroup = new THREE.Group();
    interiorGroup.name = `interior_${sectionName}`; // Use sectionName

    // --- DEBUG: Log the doorPosition if available ---
    if (doorPosition) {
      console.log(`[Interior Debug] Door position for ${sectionName}: (${doorPosition.x.toFixed(2)}, ${doorPosition.y.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);
    } else {
      console.warn(`[Interior Debug] No door position provided for ${sectionName}, using center instead.`);
      doorPosition = center.clone();
    }

    // --- Create Bounding Walls --- (Common for most types, except maybe MDR if model includes walls)
    const wallMaterial = this.materialSystem.getMaterial("wall");
    if (sectionType !== 'MDR') { // Only add procedural walls if not using MDR model's walls
        // Create walls but with a CLEAR DOORWAY
        this._createSectionWalls(center, size, wallMaterial, interiorGroup, doorPosition);
    } // MDR method needs to handle its own walls via _addCollidableWall

    // --- Common Floor --- (Always add a floor plane)
    const floorMaterial = this.materialSystem.getMaterial("floor");
    
    const floorGeom = new THREE.PlaneGeometry(size.x, size.z);
    const floor = new THREE.Mesh(floorGeom, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.copy(center);
    floor.position.y = center.y; // Place floor at the base Y
    interiorGroup.add(floor);

    // --- Common Ceiling --- (Always add a ceiling plane)
    const ceilingMaterial = this.materialSystem.getMaterial("ceiling");
    const ceilingGeom = new THREE.PlaneGeometry(size.x, size.z);
    const ceiling = new THREE.Mesh(ceilingGeom, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.copy(center);
    ceiling.position.y = center.y + size.y; // Place ceiling at the top Y
    interiorGroup.add(ceiling);
    
    // Add ceiling to the ceilingMeshes array for indoor rain occlusion detection
    this.ceilingMeshes.push(ceiling);

    // --- FIX: Create a VERY bright entryway light right inside the door ---
    // Create light direction from door to center
    const doorToCenterDir = new THREE.Vector3()
      .subVectors(center, doorPosition)
      .normalize();
    
    // Place MULTIPLE bright lights inside the door
    // First light: Right at the entrance
    const entryLightPos = new THREE.Vector3()
      .copy(doorPosition)
      .add(doorToCenterDir.clone().multiplyScalar(0.5)); // 0.5 unit inside the door
    
    entryLightPos.y = center.y + 1.8; // Head height
    
    // Create an extremely bright light with a useful falloff
    const entryLight = new THREE.PointLight(0xffffff, 8.0, 12.0, 1.0); // Increased intensity from 5.0 to 8.0
    entryLight.position.copy(entryLightPos);
    interiorGroup.add(entryLight);
    
    // Second light: Further inside to illuminate deeper
    const innerLightPos = new THREE.Vector3()
      .copy(doorPosition)
      .add(doorToCenterDir.clone().multiplyScalar(3.0)); // 3 units inside
    
    innerLightPos.y = center.y + 2.0; // Slightly higher
    
    // Create a second bright light with wider radius
    const innerLight = new THREE.PointLight(0xffffff, 4.0, 15.0, 1.0);
    innerLight.position.copy(innerLightPos);
    interiorGroup.add(innerLight);
    
    console.log(`[Interior Debug] Added bright entry lights at entry (${entryLightPos.x.toFixed(2)}, ${entryLightPos.y.toFixed(2)}, ${entryLightPos.z.toFixed(2)}) and inside (${innerLightPos.x.toFixed(2)}, ${innerLightPos.y.toFixed(2)}, ${innerLightPos.z.toFixed(2)})`);
    
    // --- FIX: Create a bright colored entry marker ---
    // Choose a color based on section type
    const sectionColors = {
      'DESIGN': 0x4285f4, // Blue
      'DEV': 0x34a853,    // Green
      'FILM': 0xfbbc05,   // Yellow/gold
      'ART': 0xea4335,    // Red
      'MDR': 0xffffff     // White
    };
    
    const markerColor = sectionColors[sectionType] || 0xffffff;
    
    // Create a visible floor marker at the entrance
    const markerGeometry = new THREE.CircleGeometry(1.0, 32);
    const markerMaterial = new THREE.MeshStandardMaterial({
      color: markerColor,
      emissive: markerColor,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.7,
      roughness: 0.3
    });
    
    const entryMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    entryMarker.rotation.x = -Math.PI / 2; // Flat on floor
    
    // Position marker right at the entrance
    const markerPos = doorPosition.clone();
    markerPos.y = center.y + 0.01; // Just above floor
    entryMarker.position.copy(markerPos);
    
    // interiorGroup.add(entryMarker); // <<< REMOVED - Don't add the floor marker
    // console.log(`[Interior Debug] Added entry marker at (${markerPos.x.toFixed(2)}, ${markerPos.y.toFixed(2)}, ${markerPos.z.toFixed(2)})`);

    // --- Dispatch to specific interior creation method --- //
    try {
      console.log(`[Interior Debug] Creating ${sectionType} interior with doorPosition passed`);
      switch (sectionType) {
          case 'DESIGN':
              this._createDesignInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'DEV':
              this._createDevInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'FILM':
              console.log('[DEBUG] Calling _createFilmInterior', {interiorGroup, center, size, doorPosition});
              this._createFilmInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'ART':
              await this._createArtInterior(interiorGroup, center, size, doorPosition);
              break;
          case 'MDR':
              await this._createMdrInterior(interiorGroup, center, size, doorPosition);
              break;
          default:
              console.warn(`Unknown portfolio section type: ${sectionType}. Creating placeholder.`);
              this._createPlaceholderInterior(interiorGroup, center, size, doorPosition);
          break;
      }
    } catch (error) {
      console.error(`[Interior Error] Failed to create interior for ${sectionName}: ${error.message}`);
      console.log(error.stack);
      // Ensure there's something visible even if creation fails
      this._createEmergencyBackupInterior(interiorGroup, center, doorPosition);
    }

    this.scene.add(interiorGroup);
    console.log(`Finished creating interior for ${sectionName}`);
  }

  // --- FIX: Add emergency backup interior if all else fails ---
  _createEmergencyBackupInterior(interiorGroup, center, doorPosition) {
    console.log(`[EMERGENCY] Creating backup interior visible objects`);
    
    // Create fallback direction if doorPosition is not available
    let doorDir = new THREE.Vector3(1, 0, 0);
    if (doorPosition) {
      doorDir.subVectors(center, doorPosition).normalize();
    }
    
    // Create bright lights along path from door to center
    for (let i = 0; i < 5; i++) {
      const lightPos = doorPosition ? doorPosition.clone().add(doorDir.clone().multiplyScalar(i * 2)) : 
                                      center.clone().add(new THREE.Vector3(i-2, 0, i-2));
      lightPos.y = center.y + 1.5;
      
      const emergencyLight = new THREE.PointLight(0xffffff, 2.0, 5.0, 1.0); // Renamed from 'light' to 'emergencyLight'
      emergencyLight.position.copy(lightPos);
      interiorGroup.add(emergencyLight);
      
      // Add visible light bulb
      const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const bulbMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
      bulb.position.copy(lightPos);
      interiorGroup.add(bulb);
    }
    
    // Create bright colored cubes - REMOVED
    /*
    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
    for (let i = 0; i < 5; i++) {
      const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const cubeMaterial = new THREE.MeshBasicMaterial({ color: colors[i] });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      
      // Position cubes in a line from door to center
      const cubePos = doorPosition ? doorPosition.clone().add(doorDir.clone().multiplyScalar(i * 1.5 + 1)) :
                                    new THREE.Vector3(center.x + i - 2, center.y + 1, center.z + i - 2);
      cube.position.copy(cubePos);
      interiorGroup.add(cube);
    }
    */
  }
  
  /**
   * Updated placeholder interior with doorPosition parameter
   */
  _createPlaceholderInterior(interiorGroup, center, size, doorPosition) {
    // Create a general interior light
    const placeholderLight = new THREE.PointLight(0xffffff, 3.0, 0, 1); // Renamed from interiorLight to placeholderLight
    placeholderLight.position.set(center.x, center.y + size.y * 0.8, center.z);
    interiorGroup.add(placeholderLight);
    
    // If we have a doorPosition, add a special entry area light
    if (doorPosition) {
      // Direction from door to center
      const doorToCenter = new THREE.Vector3().subVectors(center, doorPosition).normalize();
      
      // Place a bright light near the entry
      const entryLightPos = new THREE.Vector3()
        .copy(doorPosition)
        .add(doorToCenter.clone().multiplyScalar(1.5)); // 1.5 units inside from door
      
      entryLightPos.y = center.y + 1.8; // Head height
      
      // Create a bright entry light
      const entryLight = new THREE.PointLight(0xffffff, 3.0, 6.0, 1.0);
      entryLight.position.copy(entryLightPos);
      interiorGroup.add(entryLight);
      
      console.log(`[Placeholder] Added entry light at (${entryLightPos.x.toFixed(2)}, ${entryLightPos.y.toFixed(2)}, ${entryLightPos.z.toFixed(2)})`);
    }
    
    // Add some ceiling lights
    const ceilingLightCount = 4;
    for (let i = 0; i < ceilingLightCount; i++) {
      const lightX = center.x + (Math.random() - 0.5) * size.x * 0.8;
      const lightZ = center.z + (Math.random() - 0.5) * size.z * 0.8;
      
      // Create ceiling light fixture
      const lightFixture = new THREE.Group();
      
      // Light housing
      const housingGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const housingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc, 
        roughness: 0.5,
        metalness: 0.8 
      });
      const housing = new THREE.Mesh(housingGeometry, housingMaterial);
      housing.position.y = -0.05;
      lightFixture.add(housing);
      
      // Light lens
      const lensGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.02, 16);
      const lensMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.1
      });
      const lens = new THREE.Mesh(lensGeometry, lensMaterial);
      lens.position.y = -0.09;
      lightFixture.add(lens);
      
      // Position the fixture
      lightFixture.position.set(lightX, center.y + size.y - 0.05, lightZ);
      interiorGroup.add(lightFixture);
      
      // Add the actual light source below the fixture
      const light = new THREE.PointLight(0xffffee, 1.5, size.y * 2.5, 1); // Increased range
      light.position.set(lightX, center.y + size.y - 0.2, lightZ);
      interiorGroup.add(light);
    }
    
    // Create furniture
    /*
    const placeholderGeometry = new THREE.BoxGeometry(size.x * 0.8, size.y * 0.75, size.z * 0.8);
    const placeholderMaterial = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.8,
        wireframe: false // Change to solid rather than wireframe
    });
    const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    // Position placeholder centered within the section bounds
    placeholderMesh.position.set(center.x, center.y + size.y * 0.375, center.z);
    interiorGroup.add(placeholderMesh);
    */
    
    console.log(`Added placeholder interior with lighting for ${interiorGroup.name}`);
  }

  /**
   * Creates a simple security console for the security department - KEEPING AS EXAMPLE
   * @param {THREE.Vector3} position - Position for the console
   * @param {THREE.Group} parentGroup - Parent group to add to
   * @private
   */
  createSecurityConsole(position, parentGroup) {
    const group = new THREE.Group();
    group.position.copy(position);

    // Console desk
    const deskGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.0);
    const deskMaterial = this.materialSystem.getMaterial("trim");
    const desk = new THREE.Mesh(deskGeometry, deskMaterial);
    desk.position.y = 0.4;
    group.add(desk);

    // Monitors
    const monitorGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.05);
    const monitorMaterial = new THREE.MeshStandardMaterial({
      color: 0x222222,
      emissive: 0x333335,
      emissiveIntensity: 0.5,
    });

    // Create multiple monitors
    for (let i = -1; i <= 1; i++) {
      const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
      monitor.position.set(i * 0.7, 0.9, -0.3);
      monitor.rotation.x = -Math.PI / 12;
      group.add(monitor);

      // Screen
      const screenGeometry = new THREE.PlaneGeometry(0.55, 0.35);
      const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        emissive: 0x0066ff,
        emissiveIntensity: 0.2,
        roughness: 0.3,
        metalness: 0.8,
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.03;
      monitor.add(screen);
    }

    parentGroup.add(group);
    return group;
  }

  /**
   * Builds a new corridor layout based on the CORRIDOR_MAP configuration
   * @private
   */
  async buildNewCorridorLayout() {
    console.log("Building corridor layout from CORRIDOR_MAP...");

    // Get the corridor system (needed for bounds update)
    const corridorSystem = this.systems.get("corridor");
    if (!corridorSystem) {
      console.error("Corridor system not found");
      return;
    }

    // Ensure corridor system is initialized (might still be needed for helper functions)
    if (!corridorSystem.initialized) {
      console.warn("Corridor system not initialized, initializing now...");
      await corridorSystem.initialize(this.container);
    }

    // Create the corridor network based *only* on the map
    this.createCorridorNetwork(); // This now builds the entire structure

    // Create elevator vestibule at the entrance (node 'ELV' at [0,0])
    const elevatorNode = CORRIDOR_MAP.nodes.find(n => n.id === 'ELV');
    const elevatorPos = elevatorNode
        ? new THREE.Vector3(elevatorNode.pos[0] * SEGMENT_LENGTH, 0, -elevatorNode.pos[1] * SEGMENT_LENGTH)
        : new THREE.Vector3(0, 0, 0); // Fallback to origin
    this.createElevatorVestibule(elevatorPos);

    // VALIDATION STEP: Check for and fix potential wall inconsistencies
    this._validateAndFixCorridorWalls();

    // Update corridor bounds and navigation (if the system handles this)
    if (corridorSystem.updateCorridorBounds) {
        corridorSystem.updateCorridorBounds();
    } else {
        console.warn("CorridorSystem does not have updateCorridorBounds method.");
    }

    // Register all generated corridor walls for collision (BoxGeometry meshes)
    for (const segment of this.corridorSegments.values()) {
      segment.traverse((child) => {
        if (child.isMesh && child.geometry instanceof THREE.BoxGeometry) {
          this._addCollidableWall(child);
        }
      });
    }
    console.log("Completed building corridor layout from map.");
  }

  /**
   * Validates corridor walls and fixes inconsistencies
   * @private
   */
  _validateAndFixCorridorWalls() {
    console.log("Validating corridor walls...");
    let wallsRemoved = 0;

    // Restore original check for Performance_Art door
    const checkPerformanceArtDoor = () => {
      if (window.performanceArtDoorPosition) {
        const doorPosition = window.performanceArtDoorPosition;
        console.log(`Precisely checking for walls blocking Performance_Art doorway at (${doorPosition.x.toFixed(2)}, ${doorPosition.z.toFixed(2)})`);
        for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
          const wall = this.wallMeshes[i];
          if (!wall || !wall.position) continue;
          const wallWorldPos = new THREE.Vector3();
          wall.getWorldPosition(wallWorldPos);
          const isInDoorwayOpening = Math.abs(wallWorldPos.x - doorPosition.x) < DOORWAY_WIDTH / 2 &&
                                     Math.abs(wallWorldPos.z - doorPosition.z) < 1.0;
          if (isInDoorwayOpening && wallWorldPos.distanceTo(doorPosition) < 2.0) {
            console.log(`Removing wall directly blocking Performance_Art doorway at (${wallWorldPos.x.toFixed(2)}, ${wallWorldPos.z.toFixed(2)})`);
            if (wall.parent) wall.parent.remove(wall);
            this.wallMeshes.splice(i, 1);
            wallsRemoved++;
          }
        }
      }
    };

    // First, run the special Performance_Art door check
    checkPerformanceArtDoor();

    // Restore original check for general junction/doorway blockages
    for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
      const wall = this.wallMeshes[i];
      if (!wall || !wall.parent) continue;
      const atJunctionConnection = this._isAtJunctionConnection(wall.parent, wall);
      const wallPosition = new THREE.Vector3();
      wall.getWorldPosition(wallPosition);
      const isBlockingDoor = this._isBlockingDoorway(wallPosition);
      if (atJunctionConnection || isBlockingDoor) {
        if (wall.parent) wall.parent.remove(wall);
        this.wallMeshes.splice(i, 1);
        wallsRemoved++;
      }
    }
    
    // Additionally remove any walls still standing in the Security/Testing branch corridor at C6
    // Branch corridor runs at the C6 Z position
    const branchZ = -(-30) * SEGMENT_LENGTH; // C6 map pos [0,-30]
    for (let i = this.wallMeshes.length - 1; i >= 0; i--) {
      const wall = this.wallMeshes[i];
      const worldPos = new THREE.Vector3();
      wall.getWorldPosition(worldPos);
      // If wall lies near branch corridor Z and within side range
      if (Math.abs(worldPos.z - branchZ) < SEGMENT_LENGTH / 2) {
        console.log(`[Env Collision] Removing branch corridor wall at (${worldPos.x.toFixed(2)}, ${worldPos.z.toFixed(2)})`);
        if (wall.parent) wall.parent.remove(wall);
        this.wallMeshes.splice(i, 1);
        wallsRemoved++;
      }
    }
    console.log(`Validation complete. Removed ${wallsRemoved} problematic walls.`);
  }

  /**
   * Checks if a wall is positioned at a junction connection point
   * @private
   */
  _isAtJunctionConnection(parentGroup, wall) {
    if (!parentGroup || !parentGroup.userData) return false;
    
    // For junction parents
    if (parentGroup.name && parentGroup.name.startsWith('junction_')) {
      const nodeId = parentGroup.name.split('_')[1];
      if (!nodeId) return false;
      
      // Find all edges connected to this junction
      const connectedEdges = CORRIDOR_MAP.edges.filter(
        edge => edge.from === nodeId || edge.to === nodeId
      );
      
      if (connectedEdges.length > 0) {
        // The wall might be blocking a corridor connection
        // A more sophisticated check would compare wall orientation to edge direction
        return true;
      }
    }
    
    return false;
  }

  /**
   * Checks if a wall is blocking a doorway
   * @private
   */
  _isBlockingDoorway(wallPosition) {
    if (!window.doorLocations) return false;
    for (const door of window.doorLocations) {
      if (!door.position) continue;
      // Remove: const doorwayWidth = DOORWAY_WIDTH; and const doorwayWidth = 1.8;
      // Use DOORWAY_WIDTH directly below
      if (door.name === "Performance_Art") {
        const distance = wallPosition.distanceTo(door.position);
        const isDirectlyBlockingEntry = Math.abs(wallPosition.x - door.position.x) < DOORWAY_WIDTH/2 && 
                                      Math.abs(wallPosition.z - door.position.z) < 1.0;
        if (distance < 2.0 && isDirectlyBlockingEntry) {
          console.log(`Wall at ${wallPosition.x.toFixed(2)}, ${wallPosition.z.toFixed(2)} is directly blocking ${door.name} doorway - removing`);
          return true;
        }
        return false;
      } else if (door.name === "Film_Cinema") {
        const distance = wallPosition.distanceTo(door.position);
        const isDirectlyBlockingEntry = Math.abs(wallPosition.x - door.position.x) < DOORWAY_WIDTH/2 && 
                                      Math.abs(wallPosition.z - door.position.z) < 1.0;
        if (distance < 2.0 && isDirectlyBlockingEntry) {
          console.log(`Wall at ${wallPosition.x.toFixed(2)}, ${wallPosition.z.toFixed(2)} is directly blocking ${door.name} doorway - removing`);
          return true;
        }
        return false;
      } else {
        const distance = wallPosition.distanceTo(door.position);
        if (distance < door.radius + 0.8) {
          return true;
        }
      }
    }
    return false;
  }

  // --- Added from LumonEnvironment ---

  /**
   * Create wayfinding elements (like colored floor strips) to help navigate.
   * This is an optional feature, potentially enabled via config.
   */
  async createWayfinding() {
    // Check if wayfinding should be enabled (e.g., via options)
    if (!this.options.enableWayfinding) {
      console.log("Wayfinding disabled.");
      return;
    }

    console.log("Creating wayfinding elements...");

    // Define department colors for wayfinding strips
    const deptColors = {
      MDR: 0x4285f4, // Blue
      O_AND_D: 0xea4335, // Red (Optics & Design)
      WELLNESS: 0x34a853, // Green
      BREAK_ROOM: 0x666666, // Gray
      PERPETUITY: 0xfbbc05, // Yellow
      TESTING: 0x9c27b0, // Purple
      SECURITY: 0x000000, // Black
      HUB: 0xffffff, // White (Optional)
    };

    // Define wayfinding paths (example paths, adjust based on final layout)
    // These assume connections radiating from a central point (0,0,0) or junction 'J1'
    const hubPosition = new THREE.Vector3(0, 0.01, 0); // Assuming origin

    const paths = [
      { to: "MDR", color: deptColors.MDR, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 2) },
      { to: "O_AND_D", color: deptColors.O_AND_D, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 2) },
      { to: "WELLNESS", color: deptColors.WELLNESS, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 4) },
      { to: "BREAK_ROOM", color: deptColors.BREAK_ROOM, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 4, 0.01, -SEGMENT_LENGTH * 4) },
      { to: "PERPETUITY", color: deptColors.PERPETUITY, targetPos: new THREE.Vector3(0, 0.01, -SEGMENT_LENGTH * 9) },
      { to: "TESTING", color: deptColors.TESTING, targetPos: new THREE.Vector3(CORRIDOR_WIDTH * 3, 0.01, -SEGMENT_LENGTH * 9) },
      { to: "SECURITY", color: deptColors.SECURITY, targetPos: new THREE.Vector3(-CORRIDOR_WIDTH * 3, 0.01, -SEGMENT_LENGTH * 9) },
    ];

    // Create strips for each defined path
    paths.forEach(path => {
      // Find the nearest junction to the target department door
      // This provides a more logical endpoint for the wayfinding strip
      const nearestJunctionPos = this.findNearestJunction(path.targetPos);
      if (nearestJunctionPos) {
        this.createWayfindingStrip(hubPosition, nearestJunctionPos, path.color);
      } else {
        // Fallback: draw directly to the department door position if no junction found
        this.createWayfindingStrip(hubPosition, path.targetPos, path.color);
      }
    });
  }

  /**
   * Create a colored strip on the floor for wayfinding.
   * @param {THREE.Vector3} start - Start position (slightly above floor)
   * @param {THREE.Vector3} end - End position (slightly above floor)
   * @param {number} color - Strip color
   * @private
   */
  createWayfindingStrip(start, end, color) {
    // Calculate direction and length
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    if (length < 0.1) return; // Avoid creating zero-length strips
    direction.normalize();

    // Create strip geometry
    const stripWidth = 0.1; // Width of the wayfinding line
    const stripGeometry = new THREE.PlaneGeometry(stripWidth, length);
    const stripMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.7,
      side: THREE.DoubleSide,
    });

    // Create and position the strip
    const strip = new THREE.Mesh(stripGeometry, stripMaterial);

    // Position at midpoint between start and end
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    strip.position.copy(midpoint);
    strip.position.y = 0.015; // Ensure slightly above floor to avoid z-fighting

    // Rotate to align with direction
    strip.rotation.x = -Math.PI / 2; // Flat on floor

    // Calculate angle in XZ plane (for wayfinding direction)
    const angle = Math.atan2(direction.x, direction.z);
    strip.rotation.z = -angle; // Rotate around Y-axis (which is now Z after X rotation)

    this.scene.add(strip);
    const stripId = `strip_${start.x}_${start.z}_${end.x}_${end.z}`;
    this.wayfinding.set(stripId, strip);
    this.registerDisposable(stripGeometry);
    this.registerDisposable(stripMaterial);
  }

  /**
   * Returns an array of meshes that the player can collide with.
   * @returns {THREE.Mesh[]} List of collidable wall meshes.
   */
  getCollidableWalls() {
    // Filter out any potentially null or undefined entries just in case
    const validWalls = this.wallMeshes.filter(mesh => mesh instanceof THREE.Mesh);
    console.log(`[Env] getCollidableWalls called. Returning ${validWalls.length} initial wall meshes.`); // DEBUG - Updated log

    // Add closed door panels to the collidable list
    for (const [doorName, doorState] of this.doorStates) {
      // Check if the door is considered closed (angle close to 0)
      if (Math.abs(doorState.currentAngle) < 0.1) { 
        // Find the corresponding door data in the main doors map
        const doorData = this.doors.get(doorName);
        if (doorData && doorData.doorPanel instanceof THREE.Mesh) {
          validWalls.push(doorData.doorPanel);
          console.log(`[Env Collision] Added closed door panel to collidables: ${doorName}`);
        }
      }
    }

    if (validWalls.length === 0) {
      console.warn("[Env] getCollidableWalls returning 0 meshes. Collision will not work.");
    }
    return validWalls; // Use the filtered array
  }

  /**
   * Returns an array of meshes that the player can interact with.
   * Currently, this includes the main panel of each portfolio door.
   * @returns {THREE.Mesh[]} List of interactable door panel meshes.
   */
  getInteractableObjects() {
      const interactables = [];
      // Always include the invisible interaction meshes for doors
      if (this._doorInteractionMeshes) {
        for (const mesh of this._doorInteractionMeshes.values()) {
          interactables.push(mesh);
        }
      }
      // Optionally, still include door panels, groups, and frames for legacy/other interactions
      for (const [name, doorData] of this.doors) {
          if (doorData && doorData.doorPanel instanceof THREE.Mesh) {
              doorData.doorPanel.userData.doorName = name;
              doorData.doorPanel.userData.name = name;
              doorData.doorPanel.name = name;
              doorData.doorPanel.userData.interactable = true;
              interactables.push(doorData.doorPanel);
              if (doorData.doorGroup) {
                  doorData.doorGroup.userData.doorName = name;
                  doorData.doorGroup.userData.isParentObject = true;
                  interactables.push(doorData.doorGroup);
              }
              if (doorData.frame) {
                  doorData.frame.userData.doorName = name;
                  doorData.frame.userData.isFrameObject = true;
                  interactables.push(doorData.frame);
              }
          }
      }
      // === Add dev terminal and E button as interactables ===
      if (this._devTerminalInteractable) {
        for (const obj of this._devTerminalInteractable) {
          if (obj.mesh) {
            obj.mesh.userData.interactable = true;
            obj.mesh.userData.isDevTerminal = true;
            interactables.push(obj.mesh);
          }
          if (obj.eButton) {
            obj.eButton.userData.interactable = true;
            obj.eButton.userData.isDevTerminalEButton = true;
            interactables.push(obj.eButton);
              }
          }
      }
      if (this._customWatchInteractables) {
        for (const obj of this._customWatchInteractables) {
          if (obj) {
            interactables.push(obj);
            console.log('[DEBUG] getInteractableObjects: found custom watch interactable', obj.userData.filmTitle, obj.position);
          }
        }
      }
      console.log(`[Env Interaction] getInteractableObjects returning ${interactables.length} meshes.`);
      return interactables;
  }

  // Add new method for door animation update
  updateDoorAnimations(deltaTime) {
    if (!this.camera) return;

    // Update each door's state based on player proximity
    for (const [doorName, doorState] of this.doorStates) {
      // Skip if current angle already matches target angle
      if (Math.abs(doorState.currentAngle - doorState.targetAngle) < 0.01) {
        doorState.currentAngle = doorState.targetAngle;
        continue;
      }
      
      // Calculate angle difference and step
      const angleDiff = doorState.targetAngle - doorState.currentAngle;
      const step = Math.sign(angleDiff) * this.DOOR_ANIMATION_SPEED * deltaTime;
      
      // Apply easing to make animation more natural
      const easedStep = step * (1 - Math.pow(1 - Math.abs(angleDiff / this.DOOR_MAX_ANGLE), 3));
      
      // Update angle with easing and clamping
      doorState.currentAngle += easedStep;
      
      // Prevent overshoot
      if (Math.abs(doorState.targetAngle - doorState.currentAngle) < Math.abs(easedStep)) {
        doorState.currentAngle = doorState.targetAngle;
      }

      // Apply rotation to pivot
      doorState.pivot.rotation.y = doorState.currentAngle;
    }
  }

  /**
   * Toggles the open/closed state of a specific door by setting its target angle.
   * Called by interaction logic (e.g., UnifiedMovementController).
   * @param {string} doorName The name of the door to toggle (matching keys in this.doorStates and doorData.doorPanel.userData.doorName)
   */
  toggleDoorState(doorName) {
    console.log(`[Door Toggle] Attempting to toggle door: ${doorName}`);
    
    let doorState = this.doorStates.get(doorName);
    
    // If not found directly, search case-insensitively
    if (!doorState) {
        console.log(`[Door Toggle] Direct lookup failed, trying case-insensitive match`);
        for (const [key, state] of this.doorStates.entries()) {
            if (key.toLowerCase() === doorName.toLowerCase()) {
                doorName = key; // Use the correct case
                doorState = state;
                console.log(`[Door Toggle] Found match with key: ${key}`);
                break;
            }
        }
    }
    
    if (!doorState) {
        console.warn(`[Door Toggle] Door state not found for: ${doorName}`);
        console.log(`[Door Toggle] Available doors: ${Array.from(this.doorStates.keys()).join(', ')}`);
        return;
    }

    // Toggle the door's open/closed state
    doorState.isOpen = !doorState.isOpen;
    
    // Set the target angle based on the door's state
    if (doorState.isOpen) {
        doorState.targetAngle = this.DOOR_MAX_ANGLE * doorState.openDirection;
    } else {
        doorState.targetAngle = 0;
    }
    
    console.log(`[Door Toggle] Door '${doorName}' ${doorState.isOpen ? 'opening' : 'closing'} to angle ${doorState.targetAngle}`);
  }

  // Add method to update post-processing effects
  updatePostProcessing(deltaTime) {
    if (this.postProcessingPasses) {
      // Subtle animation of chromatic aberration
      if (this.postProcessingPasses.chromaticAberration) {
        const offset = Math.sin(deltaTime * 2) * 0.0005 + this.postProcessingConfig.chromaticAberration.offset;
        this.postProcessingPasses.chromaticAberration.uniforms.offset.value = offset;
      }

      // Subtle bloom pulse
      if (this.postProcessingPasses.bloom) {
        const strength = Math.sin(deltaTime) * 0.1 + this.postProcessingConfig.bloom.strength;
        this.postProcessingPasses.bloom.strength = strength;
      }
    }
  }

  // Add a new method to create doorframe walls around doors
  createDoorFrameWalls() {
    console.log("Creating door frame walls...");
    
    if (!window.doorLocations) return;
    
    // Retrieve door configs to get rotation information
    const doorConfigs = this.portfolioSectionsConfig;

    for (const doorLocation of window.doorLocations) {
      if (!doorLocation.position || !doorLocation.name) continue;
      
      // Find the corresponding config for rotation
      const config = Object.values(doorConfigs).find(c => c.name === doorLocation.name);
      if (!config) {
          console.warn(`Config not found for door: ${doorLocation.name}`);
          continue;
      }

      const doorPos = doorLocation.position;
      const doorWidth = 1.2; // Standard door width
      const doorHeight = 2.5; // Standard door height
      const wallThickness = 0.1;
      
      // Identify if this is a problem door
      const needsExtraExtension = ["Interaction_Design", "Development"].includes(doorLocation.name);
      
      // Increase frame dimensions - especially height and vertical extension
      const frameWidth = 1.0; // Width of the side frame pieces
      const frameDepth = 0.4; // Depth of the frame
      const topFrameHeight = 0.3; // Increased height of the top frame piece
      
      // Extend the side walls significantly higher above the door for problem doors
      const extensionFactor = needsExtraExtension ? 1.5 : 1.0;
      // Make the side pieces much taller for problem doors
      const sideWallHeight = needsExtraExtension ? doorHeight * 1.8 : doorHeight;
      // Add extra height to the side walls to extend above the door
      const sideWallYOffset = needsExtraExtension ? doorHeight * 0.4 : 0;

      // Create wall material
      const wallMaterial = this.materialSystem.getMaterial("wall").clone();
      if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
        wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
        wallMaterial.needsUpdate = true;
      } else if (wallMaterial.color) {
        wallMaterial.color.setHex(0xffffff);
      }
      
      // Make the wall material transparent to allow seeing through when doors are open
      wallMaterial.transparent = true;
      wallMaterial.opacity = 1.0;
      wallMaterial.depthWrite = true;
      wallMaterial.side = THREE.DoubleSide;
      wallMaterial.needsUpdate = true;
      
      const doorFrameGroup = new THREE.Group();
      doorFrameGroup.name = `doorframe_${doorLocation.name}`;
      
      // Get door's rotation from the config, ensuring it's normalized
      const doorRotation = (config.rotation + Math.PI * 2) % (Math.PI * 2); // Normalize rotation

      // Create frame pieces using BoxGeometry - making side pieces taller
      const leftWallGeom = new THREE.BoxGeometry(frameWidth, sideWallHeight, frameDepth * extensionFactor);
      const rightWallGeom = new THREE.BoxGeometry(frameWidth, sideWallHeight, frameDepth * extensionFactor);
      // Make top piece wider to better connect with side pieces
      const topWallGeom = new THREE.BoxGeometry(doorWidth + frameWidth * 3, topFrameHeight, frameDepth * extensionFactor);
      
      const leftWall = new THREE.Mesh(leftWallGeom, wallMaterial.clone());
      const rightWall = new THREE.Mesh(rightWallGeom, wallMaterial.clone());
      const topWall = new THREE.Mesh(topWallGeom, wallMaterial.clone());

      // Position frame pieces relative to the door center, then apply door rotation
      // Adjust center offset to extend deeper into the wall
      const centerOffset = new THREE.Vector3(0, 0, -frameDepth * extensionFactor / 2);

      // Position left wall relative to center - added Y offset to make it taller
      const leftOffset = new THREE.Vector3(-doorWidth / 2 - frameWidth / 2, doorHeight / 2 + sideWallYOffset, 0);
      leftWall.position.copy(centerOffset).add(leftOffset);
      
      // Position right wall relative to center - added Y offset to make it taller
      const rightOffset = new THREE.Vector3(doorWidth / 2 + frameWidth / 2, doorHeight / 2 + sideWallYOffset, 0);
      rightWall.position.copy(centerOffset).add(rightOffset);

      // Position top wall relative to center - make it higher for problem doors
      const topWallY = needsExtraExtension ? doorHeight + topFrameHeight : doorHeight + topFrameHeight / 2;
      const topOffset = new THREE.Vector3(0, topWallY, 0);
      topWall.position.copy(centerOffset).add(topOffset);

      // Add pieces to the group BEFORE rotating the group
      doorFrameGroup.add(leftWall);
      doorFrameGroup.add(rightWall);
      doorFrameGroup.add(topWall);

      // For problem doors, create additional extension walls to ensure complete coverage
      if (needsExtraExtension) {
        console.log(`Adding extra wall extensions for ${doorLocation.name} door frame`);
        
        // Extended wall height (much taller than door)
        const extendedHeight = doorHeight * 1.5;
        
        // Create extension walls on both sides that extend further into the corridor and higher up
        const extensionDepth = 0.6; // Deep extension into wall
        const extensionWidth = 0.5; // Wider than frame for better coverage
        
        // Create left and right extension walls that go deeper into the corridor wall and extend higher
        const leftExtGeom = new THREE.BoxGeometry(extensionWidth, extendedHeight, extensionDepth);
        const rightExtGeom = new THREE.BoxGeometry(extensionWidth, extendedHeight, extensionDepth);
        
        const leftExt = new THREE.Mesh(leftExtGeom, wallMaterial.clone());
        const rightExt = new THREE.Mesh(rightExtGeom, wallMaterial.clone());
        
        // Position these extensions further back (deeper into the wall) and higher up
        const deeperOffset = new THREE.Vector3(0, 0, -extensionDepth/2 - frameDepth/2);
        
        // Position left extension - adding extra height
        const leftExtOffset = new THREE.Vector3(-doorWidth / 2 - extensionWidth / 2, doorHeight / 2 + extendedHeight * 0.15, 0);
        leftExt.position.copy(deeperOffset).add(leftExtOffset);
        
        // Position right extension - adding extra height
        const rightExtOffset = new THREE.Vector3(doorWidth / 2 + extensionWidth / 2, doorHeight / 2 + extendedHeight * 0.15, 0);
        rightExt.position.copy(deeperOffset).add(rightExtOffset);
        
        // Add the extensions to the door frame group
        doorFrameGroup.add(leftExt);
        doorFrameGroup.add(rightExt);
        
        // Add them to collidable walls
        this._addCollidableWall(leftExt);
        this._addCollidableWall(rightExt);
        
        // Add horizontal extension above the door to connect the side pieces
        const topExtGeom = new THREE.BoxGeometry(doorWidth + extensionWidth * 2, 0.4, extensionDepth);
        const topExt = new THREE.Mesh(topExtGeom, wallMaterial.clone());
        
        // Position it above the door, connecting the left and right extensions
        topExt.position.copy(deeperOffset).add(new THREE.Vector3(0, doorHeight + 0.8, 0));
        
        doorFrameGroup.add(topExt);
        this._addCollidableWall(topExt);
      }

      // Position and rotate the entire frame group
      doorFrameGroup.position.copy(doorPos);
      doorFrameGroup.rotation.y = doorRotation;

      // Link this door frame group to the door state for visibility toggling
      const doorObj = this.doors.get(doorLocation.name);
      if (doorObj && doorObj.doorPanel) {
        // Store reference to frame group in door panel's userData
        doorObj.doorPanel.userData.doorFrameWalls = doorFrameGroup;
      }

      // Add to scene and collidable walls list
      this.scene.add(doorFrameGroup);
      this._addCollidableWall(leftWall);
      this._addCollidableWall(rightWall);
      this._addCollidableWall(topWall);
      
      console.log(`Created doorframe for ${doorLocation.name} at position (${doorPos.x.toFixed(2)}, ${doorPos.y.toFixed(2)}, ${doorPos.z.toFixed(2)}) with rotation ${doorRotation.toFixed(2)}`);
    }
  }

  /**
   * Update weather effects
   * @private
   */
  updateWeather(deltaTime) {
    const currentTime = Date.now();
    const rainSystem = this.systems.get("rain");
    if (!rainSystem) return;

    // Check if enough time has passed since last weather change
    if (currentTime - this.weatherState.lastWeatherChange > this.weatherState.minWeatherDuration) {
      // 5% chance to change weather state every update when enough time has passed
      if (Math.random() < 0.0005) { // Adjusted for deltaTime assuming ~60fps
        this.weatherState.isRaining = !this.weatherState.isRaining;
        this.weatherState.lastWeatherChange = currentTime;
      }
    }

    // Always enable/disable rain system based on isRaining
    if (this.weatherState.isRaining) {
      if (!rainSystem.enabled) rainSystem.enable();
      // Always update outdoors state for sound/visuals
      rainSystem.setOutdoors(this.isPlayerOutdoors());
      rainSystem.update(deltaTime);
    } else {
      if (rainSystem.enabled) rainSystem.disable();
    }
  }

  /**
   * Check if the player is in an outdoor area
   * @private
   * @returns {boolean} True if player is outdoors
   */
  isPlayerOutdoors() {
    if (!this.camera) return false;
    // Raycast upward to detect nearby ceilings
    const origin = this.camera.position.clone();
    const upward = new THREE.Vector3(0, 1, 0);
    const maxDistance = 5.0; // Check up to 5 units above
    const raycaster = new THREE.Raycaster(origin, upward, 0, maxDistance);
    const hits = raycaster.intersectObjects(this.ceilingMeshes, true);
    if (hits.length > 0) {
      // Ceiling detected overhead: indoors
      return false;
    }
    // No ceiling overhead: outdoors
    return true;
  }

  updateInteractionButtons(camera) {
    // Skip if no watch interactables or no camera
    if (!this._customWatchInteractables || !this._customWatchInteractables.length || !camera) {
      return;
    }
    
    // Get current time for animations
    const time = performance.now() * 0.001; // Convert to seconds
    
    // Update each E button to face the camera
    for (const interactable of this._customWatchInteractables) {
      if (!interactable || !interactable.userData.eButtonMesh) continue;
      
      const eButton = interactable.userData.eButtonMesh;
      
      // Skip if not visible
      if (!eButton.visible) continue;
      
      // Simple billboard effect - make button face the camera
      eButton.lookAt(camera.position);
      
      // Add a pulsing animation to the button when visible
      // Scale between 0.9 and 1.1 of original size
      const pulseFactor = 0.1; // 10% size variation
      const pulseSpeed = 1.5; // Full cycle in 1.5 seconds
      const pulse = 1 + pulseFactor * Math.sin(time * pulseSpeed * Math.PI);
      
      // Apply pulse to scale
      eButton.scale.set(pulse, pulse, 1);
      
      // Apply a small hover effect
      const hoverOffset = Math.sin(time * 2) * 0.03; // Subtle float up/down
      
      // Get original position or set it if not already stored
      if (!eButton.userData.originalY) {
        eButton.userData.originalY = eButton.position.y;
      }
      
      // Apply hover effect to y position
      eButton.position.y = eButton.userData.originalY + hoverOffset;
    }
    
    // --- Terminal E button proximity logic ---
    if (this._devTerminalInteractable && camera) {
      const playerPos = camera.position;
      for (const obj of this._devTerminalInteractable) {
        if (!obj.eButton || !obj.interactionMesh) continue;
        
        // Calculate distance to terminal interaction volume
        const interactionPos = new THREE.Vector3();
        obj.interactionMesh.getWorldPosition(interactionPos);
        
        const distanceToPlayer = playerPos.distanceTo(interactionPos);
        const proximityThreshold = 3.0; // Show E button when within 3 units
        
        // Show/hide E button based on proximity
        if (distanceToPlayer < proximityThreshold) {
          if (!obj.eButton.visible) {
            obj.eButton.visible = true;
            console.log('[Dev Terminal] Player in proximity, showing E button');
          }
          
          // Make E button face the camera (billboard effect)
          obj.eButton.lookAt(camera.position);
          
          // Add pulse animation
          const pulseFactor = 0.1;
          const pulseSpeed = 1.5;
          const pulse = 1 + pulseFactor * Math.sin(time * pulseSpeed * Math.PI);
          
          // Store original scale if not already set
          if (!obj.eButton.userData.originalScale) {
            obj.eButton.userData.originalScale = { 
              x: obj.eButton.scale.x,
              y: obj.eButton.scale.y,
              z: obj.eButton.scale.z
            };
          }
          
          // Apply pulse to scale
          const origScale = obj.eButton.userData.originalScale;
          obj.eButton.scale.set(
            origScale.x * pulse,
            origScale.y * pulse,
            origScale.z
          );
          
          // Add hover animation
          const hoverOffset = Math.sin(time * 2) * 0.03;
          
          // Store original Y position if not already set
          if (!obj.eButton.userData.originalY) {
            obj.eButton.userData.originalY = obj.eButton.position.y;
          }
          
          // Apply hover effect
          obj.eButton.position.y = obj.eButton.userData.originalY + hoverOffset;
        } else if (obj.eButton.visible) {
          obj.eButton.visible = false;
          console.log('[Dev Terminal] Player moved away, hiding E button');
        }
      }
    }
  }

  /**
   * Finds the nearest point on the main corridor wall to the given door position.
   * Returns { point: THREE.Vector3, segment: THREE.Group } or null if not found.
   */
  _findNearestCorridorWallPoint(doorPos) {
    let minDist = Infinity;
    let bestPoint = null;
    let bestSegment = null;
    // Only consider main corridor segments
    for (const [id, segment] of this.corridorSegments) {
      if (!id.startsWith('C')) continue; // Only main corridor segments
      const start = segment.userData.startPoint;
      const end = segment.userData.endPoint;
      // Project doorPos onto segment line (XZ only)
      const segVec = new THREE.Vector3().subVectors(end, start);
      const segLen = segVec.length();
      if (segLen === 0) continue;
      const segDir = segVec.clone().normalize();
      const doorVec = new THREE.Vector3().subVectors(doorPos, start);
      const t = Math.max(0, Math.min(1, segDir.dot(doorVec) / segLen));
      const proj = start.clone().add(segDir.clone().multiplyScalar(segLen * t));
      // Find perpendicular direction (in XZ)
      const perp = new THREE.Vector3(-segDir.z, 0, segDir.x).normalize();
      // Offset to the wall (assume right wall for now, can be improved)
      const wallPoint = proj.clone().add(perp.clone().multiplyScalar(CORRIDOR_WIDTH / 2));
      const dist = wallPoint.distanceTo(doorPos);
      if (dist < minDist) {
        minDist = dist;
        bestPoint = wallPoint;
        bestSegment = segment;
      }
      // Also check left wall
      const wallPointLeft = proj.clone().add(perp.clone().multiplyScalar(-CORRIDOR_WIDTH / 2));
      const distLeft = wallPointLeft.distanceTo(doorPos);
      if (distLeft < minDist) {
        minDist = distLeft;
        bestPoint = wallPointLeft;
        bestSegment = segment;
      }
    }
    if (bestPoint) {
      return { point: bestPoint, segment: bestSegment };
    }
    return null;
  }

  /**
   * Creates a tunnel from the main corridor wall to the door.
   * @param {THREE.Vector3} corridorPoint - Start point on the corridor wall
   * @param {THREE.Vector3} doorPos - End point at the door
   * @param {number} width - Tunnel width
   * @param {number} height - Tunnel height
   */
  _createCorridorToDoorTunnel(corridorPoint, doorPos, width, height) {
    const depth = corridorPoint.distanceTo(doorPos);
    if (depth < 0.05) return;
    const wallThickness = 0.12;
    const ceilingHeight = height;
    // Widen tunnel to fit both corridor and room wall, plus a small overlap to prevent leaks
    const vestibuleWidth = Math.max(width, CORRIDOR_WIDTH) + 0.15;
    const dir = new THREE.Vector3().subVectors(doorPos, corridorPoint).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3().crossVectors(dir, up).normalize();
    const wallMaterial = this.materialSystem.getMaterial('corridorWall').clone();
    if (wallMaterial.uniforms && wallMaterial.uniforms.wallColor) {
      wallMaterial.uniforms.wallColor.value = new THREE.Color(0xffffff);
      wallMaterial.needsUpdate = true;
    } else if (wallMaterial.color) {
      wallMaterial.color.setHex(0xffffff);
    }

    // Calculate the four corners of the tunnel
    const leftOffset = right.clone().multiplyScalar(-(vestibuleWidth/2 - wallThickness/2));
    const rightOffset = right.clone().multiplyScalar((vestibuleWidth/2 - wallThickness/2));
    const corridorLeft = corridorPoint.clone().add(leftOffset);
    const corridorRight = corridorPoint.clone().add(rightOffset);
    const doorLeft = doorPos.clone().add(leftOffset);
    const doorRight = doorPos.clone().add(rightOffset);

    // Ceiling (spans the rectangle defined by the four corners)
    const ceilingCenter = corridorPoint.clone().add(doorPos).multiplyScalar(0.5);
    ceilingCenter.y = corridorPoint.y + ceilingHeight - wallThickness/2;
    const ceilingLength = depth;
    const ceilingWidth = vestibuleWidth;
    const ceilingGeom = new THREE.BoxGeometry(ceilingWidth, wallThickness, ceilingLength);
    const ceiling = new THREE.Mesh(ceilingGeom, wallMaterial.clone());
    ceiling.position.copy(ceilingCenter);
    // Align ceiling with tunnel direction
    const tunnelQuat = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, 1),
      dir
    );
    ceiling.setRotationFromQuaternion(tunnelQuat);
    this.scene.add(ceiling);
    this._addCollidableWall(ceiling);
    // Add tunnel ceiling to ceilingMeshes for weather occlusion
    this.ceilingMeshes.push(ceiling);

    // Side walls (left and right)
    const wallLength = depth;
    const wallGeom = new THREE.BoxGeometry(wallThickness, height, wallLength);

    // Left wall
    const leftWallCenter = corridorLeft.clone().add(doorLeft).multiplyScalar(0.5);
    leftWallCenter.y = corridorPoint.y + height/2;
    const leftWall = new THREE.Mesh(wallGeom, wallMaterial.clone());
    leftWall.position.copy(leftWallCenter);
    leftWall.setRotationFromQuaternion(tunnelQuat);
    this.scene.add(leftWall);
    this._addCollidableWall(leftWall);

    // Right wall
    const rightWallCenter = corridorRight.clone().add(doorRight).multiplyScalar(0.5);
    rightWallCenter.y = corridorPoint.y + height/2;
    const rightWall = new THREE.Mesh(wallGeom, wallMaterial.clone());
    rightWall.position.copy(rightWallCenter);
    rightWall.setRotationFromQuaternion(tunnelQuat);
    this.scene.add(rightWall);
    this._addCollidableWall(rightWall);

    // Log
    console.log(`[Corridor Tunnel] Created tunnel from corridor to door (rectangular prism) with width ${ceilingWidth}, depth ${ceilingLength}`);
  }

  /**
   * Load shader file content
   * @param {string} path - Path to the shader file
   * @returns {Promise<string>} - Promise resolving to shader code
   */
  async _loadShaderFile(path) {
    try {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Failed to load shader at ${path}: ${response.status} ${response.statusText}`);
      }
      return await response.text();
    } catch (error) {
      console.error(`Error loading shader file ${path}:`, error);
      throw error;
    }
  }
}

// Helper to create a glowing lamp bulb shader material
function createLampLightShaderMaterial() {
  // Simple glowing emissive shader
  return new THREE.ShaderMaterial({
    uniforms: {
      glowColor: { value: new THREE.Color(0xffffcc) },
      intensity: { value: 1.5 },
    },
    vertexShader: `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      uniform float intensity;
      varying vec3 vNormal;
      void main() {
        float glow = pow(0.6 + 0.4 * abs(vNormal.y), 2.0) * intensity;
        gl_FragColor = vec4(glowColor * glow, 1.0);
      }
    `,
    transparent: false,
    side: THREE.FrontSide,
  });
}

// === Kruger Text Utility ===
function createKrugerTextTexture(text, { width = 1024, height = 256, bgColor = '#fff', fgColor = '#e10600', font = 'bold 96px Helvetica Neue, Arial, sans-serif', align = 'center', vAlign = 'middle' } = {}) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  // Background
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, width, height);
  // Text
  ctx.font = font;
  ctx.fillStyle = fgColor;
  ctx.textAlign = align;
  ctx.textBaseline = vAlign;
  // Auto-wrap: split text if too long
  const words = text.split(' ');
  let line = '', lines = [], maxWidth = width * 0.9;
  for (let w of words) {
    const test = line + w + ' ';
    if (ctx.measureText(test).width > maxWidth) {
      lines.push(line);
      line = w + ' ';
    } else {
      line = test;
    }
  }
  lines.push(line);
  const lineHeight = 100;
  const yStart = height/2 - (lines.length-1)*lineHeight/2;
  lines.forEach((l, i) => ctx.fillText(l.trim(), width/2, yStart + i*lineHeight));
  return new THREE.CanvasTexture(canvas);
}

// === Placeholder async MCP fetch ===
async function fetchMCPContent(key) {
  // Simulate async fetch; in real use, replace with MCP server call
  const data = {
    'dev_slogans': [
      'YOU COMPILE > YOU FAIL',
      'YOUR CODE IS A MIRROR',
      'DEBUGGING IS SELF-REFLECTION',
      'ERRORS ARE INSTRUCTIONS',
      'YOUR IDENTITY = YOUR OUTPUT',
      'STACK OVERFLOWED',
      'WHO OWNS YOUR CODE?',
      'YOU ARE THE BUG',
    ],
    'cv_keywords': [
      'Full-Stack Alchemist',
      'Data Witch',
      'API Whisperer',
      'DevOps Druid',
      'TypeScript Tamer',
      'CI/CD Sorcerer',
      'Cloud Conjurer',
      'Security Sentinel',
    ],
    'terminal_cv': 'NAME: {{PLACEHOLDER}}\nSKILLS: {{PLACEHOLDER}}\nEXPERIENCE: {{PLACEHOLDER}}',
    'terminal_bio': 'BIO: {{PLACEHOLDER}}',
    'terminal_contact': 'PGP: {{PLACEHOLDER}}',
  };
  return data[key] || ['{{PLACEHOLDER}}'];
}
